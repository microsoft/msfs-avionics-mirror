"use strict";(self.webpackChunkdocs_api=self.webpackChunkdocs_api||[]).push([[95843],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>w});var a=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},p="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),p=c(n),m=i,w=p["".concat(l,".").concat(m)]||p[m]||h[m]||r;return n?a.createElement(w,o(o({ref:t},d),{},{components:n})):a.createElement(w,o({ref:t},d))}));function w(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[p]="string"==typeof e?e:i,o[1]=s;for(var c=2;c<r;c++)o[c]=n[c];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},92039:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>r,metadata:()=>s,toc:()=>c});var a=n(87462),i=(n(67294),n(3905));const r={sidebar_label:"GTC Framework",sidebar_position:10},o="G3000 GTC Framework",s={unversionedId:"g3000/gtc-framework",id:"g3000/gtc-framework",title:"G3000 GTC Framework",description:"GTC Views and the View Stack",source:"@site/docs/g3000/gtc-framework.md",sourceDirName:"g3000",slug:"/g3000/gtc-framework",permalink:"/msfs-avionics-mirror/docs/g3000/gtc-framework",draft:!1,tags:[],version:"current",sidebarPosition:10,frontMatter:{sidebar_label:"GTC Framework",sidebar_position:10},sidebar:"sidebar",previous:{title:"Display Panes",permalink:"/msfs-avionics-mirror/docs/g3000/display-panes"},next:{title:"CAS",permalink:"/msfs-avionics-mirror/docs/g3000/cas"}},l={},c=[{value:"GTC Views and the View Stack",id:"gtc-views-and-the-view-stack",level:2},{value:"Control Modes",id:"control-modes",level:2},{value:"View Lifecycle",id:"view-lifecycle",level:2},{value:"The GTC Service",id:"the-gtc-service",level:2},{value:"Registering Views",id:"registering-views",level:2},{value:"The Button Bar and Label Bar",id:"the-button-bar-and-label-bar",level:2}],d={toc:c},p="wrapper";function h(e){let{components:t,...n}=e;return(0,i.kt)(p,(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"g3000-gtc-framework"},"G3000 GTC Framework"),(0,i.kt)("h2",{id:"gtc-views-and-the-view-stack"},"GTC Views and the View Stack"),(0,i.kt)("p",null,"The G3000's GTC framework is centered around the concept of ",(0,i.kt)("em",{parentName:"p"},"views")," and the ",(0,i.kt)("em",{parentName:"p"},"view stack"),"."),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Views")," render content to be displayed on the GTC and handle user interactions with the touchscreen, knobs, and softkeys. All views are FS components that extend the abstract class ",(0,i.kt)("inlineCode",{parentName:"p"},"GtcView"),". There are two types of views: ",(0,i.kt)("em",{parentName:"p"},"pages")," and ",(0,i.kt)("em",{parentName:"p"},"popups"),". Only one page can be open at a time. Meanwhile, multiple popups can be open simultaneously."),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"Views on horizontal GTCs (580 model) are 990px in width and 768px in height. Views on vertical GTCs (570/575 model) are 480px in width and 413 px in height. These dimensions include the area used to display the view title.")),(0,i.kt)("p",null,"Open views are stored on the ",(0,i.kt)("em",{parentName:"p"},"view stack"),". The open page is located at the bottom of the stack, and popups are pushed onto the stack in the order in which they were opened. The view at the top of the stack is considered the ",(0,i.kt)("em",{parentName:"p"},"active view"),". Typically, all user interactions are routed to the active view, though there are some exceptions."),(0,i.kt)("p",null,"The view stack also maintains a history. Each time a view is pushed to the view stack, a new history snapshot of the view stack state is created and pushed onto the history stack. This allows previous view stack states to be restored via a 'Back' operation."),(0,i.kt)("h2",{id:"control-modes"},"Control Modes"),(0,i.kt)("p",null,"GTCs operate in one of three control modes:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"PFD"),(0,i.kt)("li",{parentName:"ul"},"MFD"),(0,i.kt)("li",{parentName:"ul"},"NAV/COM")),(0,i.kt)("p",null,"A particular GTC does not necessarily have access to all three control modes. Horizontal GTCs (580 model) can be configured to support all three modes or only the PFD and NAV/COM modes. Vertical GTCs (570/575 model) can only support either the PFD or MFD modes, and cannot freely switch between them."),(0,i.kt)("p",null,"Each control mode maintains its own view stack. Switching between control modes switches the active view stack and therefore which view(s) are visible. The view stacks of non-active control modes are retained, ready to be resumed when the user switches back to those modes."),(0,i.kt)("p",null,"The MFD control mode is unique in that it maintains not just one view stack but one view stack for each controllable display pane. When the MFD control mode is active, the user can select any non-hidden controllable display pane to control, and that pane's view stack becomes the active view stack. Like with other view stacks, non-active display pane view stacks are retained and ready to be resumed when the user selects their associated pane again."),(0,i.kt)("h2",{id:"view-lifecycle"},"View Lifecycle"),(0,i.kt)("p",null,"GTC views have a complicated lifecycle, since they can move between many different states. Each view stack has its own instance of any particular view. Therefore, views of the same type in different stacks do not implicitly share state."),(0,i.kt)("p",null,"A view is considered ",(0,i.kt)("em",{parentName:"p"},"in-use")," when it appears in any historical version of its view stack (including the current version) and ",(0,i.kt)("em",{parentName:"p"},"out-of-use")," otherwise."),(0,i.kt)("p",null,"A view is considered ",(0,i.kt)("em",{parentName:"p"},"open")," when it appears in the current (most recent) version of its view stack and ",(0,i.kt)("em",{parentName:"p"},"closed")," otherwise. The ",(0,i.kt)("inlineCode",{parentName:"p"},"onOpen()")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"onClose()")," lifecycle methods are called when a view switches between these two states."),(0,i.kt)("p",null,"A view is considered ",(0,i.kt)("em",{parentName:"p"},"awake")," when it appears in the current (most recent) version of the active view stack, and ",(0,i.kt)("em",{parentName:"p"},"asleep")," otherwise."),(0,i.kt)("p",null,"Finally, a view is considered ",(0,i.kt)("em",{parentName:"p"},"active")," or ",(0,i.kt)("em",{parentName:"p"},"resumed")," when it appears at the top of the current (most recent) version of the active view stack, and ",(0,i.kt)("em",{parentName:"p"},"inactive")," or ",(0,i.kt)("em",{parentName:"p"},"paused")," otherwise. The ",(0,i.kt)("inlineCode",{parentName:"p"},"onResume()")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"onPause()")," lifecycle methods are called when a view switches between these two states. Each GTC only has one active view at a time, and it is with this view that the user primarily interacts."),(0,i.kt)("p",null,"Views are always created initially in an ",(0,i.kt)("em",{parentName:"p"},"out of use")," state. Views can also have different lifespans, determined by their ",(0,i.kt)("em",{parentName:"p"},"lifecycle policy"),". The different possible lifecycle policies are included as members of the ",(0,i.kt)("inlineCode",{parentName:"p"},"GtcViewLifecyclePolicy")," enum:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Static: The view is created immediately when it is registered (see below) and is never destroyed. Should only be used by views that have persistent state and need to be created when the GTC instrument is first initialized."),(0,i.kt)("li",{parentName:"ul"},"Persistent: The view is created immediately before the first time it transitions to an in-use state and is never destroyed. Should be used by views that have persistent state."),(0,i.kt)("li",{parentName:"ul"},"Transient: The view is created immediately before the first time it transitions to an in-use state and is destroyed when it transitions back to an out-of-use state. Should be used by views that do not have persistent state.")),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"Views have a non-negligible memory footprint when created. Therefore, it is recommended that the transient lifecycle policy be used whenever possible to reduce memory load and increase stability in memory-limited scenarios oftentimes seen in low-spec PCs and the XBox consoles.")),(0,i.kt)("admonition",{type:"caution"},(0,i.kt)("p",{parentName:"admonition"},"Ensure that transient views properly release all resources they use when they are destroyed to avoid memory leaks. Cleanup code should be included in the view's ",(0,i.kt)("inlineCode",{parentName:"p"},"destroy()")," method."),(0,i.kt)("p",{parentName:"admonition"},"It is also good practice to ensure ",(0,i.kt)("em",{parentName:"p"},"all")," views contain cleanup code, regardless of their lifecycle policy. This is because a mod or plugin can theoretically replace any registered view with another one (see ",(0,i.kt)("a",{parentName:"p",href:"#registering-views"},"Registering Views"),").")),(0,i.kt)("h2",{id:"the-gtc-service"},"The GTC Service"),(0,i.kt)("p",null,"Each GTC instrument contains one instance of ",(0,i.kt)("inlineCode",{parentName:"p"},"GtcService"),", which is the class that controls all view-related state and logic. Switching control modes, selecting controllable display panes, opening and closing views - all of these actions and more are handled by ",(0,i.kt)("inlineCode",{parentName:"p"},"GtcService"),". All views are passed a reference to their parent ",(0,i.kt)("inlineCode",{parentName:"p"},"GtcService")," instance as a prop."),(0,i.kt)("h2",{id:"registering-views"},"Registering Views"),(0,i.kt)("p",null,"Views must be registered with ",(0,i.kt)("inlineCode",{parentName:"p"},"GtcService")," before they can be used. Each view is registered under a unique string key, which is then used to open and retrieve the view from ",(0,i.kt)("inlineCode",{parentName:"p"},"GtcService"),". Views are registered on a per-control mode basis; different views may be registered under the same key to different control modes. Finally, views are registered as factories - functions that create and return the registered view as a ",(0,i.kt)("inlineCode",{parentName:"p"},"VNode")," - instead of directly as instances of the view. This is to allow ",(0,i.kt)("inlineCode",{parentName:"p"},"GtcService")," to handle the process of creating views with various lifecycle policies, and in the case of MFD control mode views, to allow the creation of one instance of the registered view for each controllable display pane view stack."),(0,i.kt)("p",null,"If a view is registered to a control mode under key that is already registered to that control mode, the new view will replace the existing view registered under that key. If an instance of the existing view has already been created, it will be destroyed when it is replaced."),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"The ",(0,i.kt)("inlineCode",{parentName:"p"},"GtcViewKeys")," enum contains all GTC view keys defined and used by the base G3000.")),(0,i.kt)("h2",{id:"the-button-bar-and-label-bar"},"The Button Bar and Label Bar"),(0,i.kt)("p",null,"In addition to content rendered by views, the GTC also displays a ",(0,i.kt)("em",{parentName:"p"},"button bar")," and ",(0,i.kt)("em",{parentName:"p"},"label bar")," on the edge of the screen (the right edge on horizontal GTCs and the bottom edge on vertical GTCs). Collectively, these are known as the ",(0,i.kt)("em",{parentName:"p"},"sidebar"),", and they contain context-dependent buttons and labels."),(0,i.kt)("p",null,"Views can control what appears in the sidebar using the ",(0,i.kt)("inlineCode",{parentName:"p"},"this._sidebarState")," property defined by ",(0,i.kt)("inlineCode",{parentName:"p"},"GtcView"),". The state defined by ",(0,i.kt)("inlineCode",{parentName:"p"},"this._sidebarState")," is automatically applied to the sidebar when the view becomes the active view. Correspondingly, when a view is no longer the active view, it automatically passes control of the sidebar state to the new active view."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"GtcSidebar")," class contains utility methods for working with the sidebar."))}h.isMDXComponent=!0}}]);