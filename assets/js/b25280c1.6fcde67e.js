"use strict";(self.webpackChunkdocs_api=self.webpackChunkdocs_api||[]).push([[84980],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>b});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),c=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=c(e.components);return a.createElement(s.Provider,{value:t},e.children)},p="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),p=c(n),h=r,b=p["".concat(s,".").concat(h)]||p[h]||u[h]||i;return n?a.createElement(b,o(o({ref:t},d),{},{components:n})):a.createElement(b,o({ref:t},d))}));function b(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=h;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[p]="string"==typeof e?e:r,o[1]=l;for(var c=2;c<i;c++)o[c]=n[c];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},97963:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>l,toc:()=>c});var a=n(87462),r=(n(67294),n(3905));const i={sidebar_label:"GTC Plugins",sidebar_position:8},o="G3000 GTC Plugins",l={unversionedId:"g3000/gtc-plugins",id:"g3000/gtc-plugins",title:"G3000 GTC Plugins",description:"Introduction",source:"@site/docs/g3000/gtc-plugins.md",sourceDirName:"g3000",slug:"/g3000/gtc-plugins",permalink:"/msfs-avionics-mirror/docs/g3000/gtc-plugins",draft:!1,tags:[],version:"current",sidebarPosition:8,frontMatter:{sidebar_label:"GTC Plugins",sidebar_position:8},sidebar:"sidebar",previous:{title:"MFD Plugins",permalink:"/msfs-avionics-mirror/docs/g3000/mfd-plugins"},next:{title:"Display Panes",permalink:"/msfs-avionics-mirror/docs/g3000/display-panes"}},s={},c=[{value:"Introduction",id:"introduction",level:2},{value:"Importing Libraries",id:"importing-libraries",level:2},{value:"Binder",id:"binder",level:2},{value:"GTC Views",id:"gtc-views",level:2},{value:"Knob Control State Overrides",id:"knob-control-state-overrides",level:2},{value:"Label Bar Handlers",id:"label-bar-handlers",level:2},{value:"Interaction Event Handling",id:"interaction-event-handling",level:2}],d={toc:c},p="wrapper";function u(e){let{components:t,...n}=e;return(0,r.kt)(p,(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"g3000-gtc-plugins"},"G3000 GTC Plugins"),(0,r.kt)("h2",{id:"introduction"},"Introduction"),(0,r.kt)("p",null,"G3000 GTC plugins allow you to register views to the GTC. GTC plugins must implement the ",(0,r.kt)("inlineCode",{parentName:"p"},"G3000GtcPlugin")," interface."),(0,r.kt)("p",null,"For convenience, you may elect to have GTC plugins extend the ",(0,r.kt)("inlineCode",{parentName:"p"},"AbstractG3000GtcPlugin")," abstract class. This class defines no-op versions of all methods required by the GTC plugin interface. Simply override the methods required for the functionality you wish to add without having to worry about the others."),(0,r.kt)("h2",{id:"importing-libraries"},"Importing Libraries"),(0,r.kt)("p",null,"GTC plugins can import and use code from the following framework libraries:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"@microsoft/msfs-sdk")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"@microsoft/msfs-garminsdk")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"@microsoft/msfs-wtg3000-common")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"@microsoft/msfs-wtg3000-gtc"))),(0,r.kt)("p",null,"When building your plugin, you should configure your build tools to consume the above libraries as global externals."),(0,r.kt)("h2",{id:"binder"},"Binder"),(0,r.kt)("p",null,"In addition to the ",(0,r.kt)("a",{parentName:"p",href:"/msfs-avionics-mirror/docs/g3000/plugin-basics#plugin-interface"},"references")," passed to all G3000 plugins, GTC plugins are given the following additional references through ",(0,r.kt)("inlineCode",{parentName:"p"},"binder"),":"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The instrument configuration object specific to the GTC instance."),(0,r.kt)("li",{parentName:"ul"},"A collection of navigation indicators containing only the active NAV source indicator."),(0,r.kt)("li",{parentName:"ul"},"The GTC service."),(0,r.kt)("li",{parentName:"ul"},"The flight plan store (only if the GTC supports the MFD control mode).")),(0,r.kt)("h2",{id:"gtc-views"},"GTC Views"),(0,r.kt)("p",null,"The G3000 GTC displays content using a page and popup system, and within the GTC framework, both of those elements are implemented using GTC views. As such, GTC views are the primary means by which you can inject aircraft/plugin-specific GTC content. For more information on GTC views, please refer to the ",(0,r.kt)("a",{parentName:"p",href:"/msfs-avionics-mirror/docs/g3000/gtc-framework"},(0,r.kt)("em",{parentName:"a"},"G3000 GTC Framework"))," page."),(0,r.kt)("p",null,"You can register your own views to be displayed on the GTC using the GTC plugin's ",(0,r.kt)("inlineCode",{parentName:"p"},"registerGtcViews()")," method. This method is guaranteed to be called ",(0,r.kt)("em",{parentName:"p"},"after")," the base G3000 has registered all of its views. Therefore, you may replace views registered by the base G3000 by registering your own view under the same key."),(0,r.kt)("p",null,"In addition to the GTC service, a context object is also passed to ",(0,r.kt)("inlineCode",{parentName:"p"},"registerGtcViews()"),". The context object contains references to all items not already referenced by the plugin binder that are required to create the base G3000 views. These references are provided primarily to make it easy to override and replace any of the base G3000 views. However, you are also free to use them when creating brand new views."),(0,r.kt)("h2",{id:"knob-control-state-overrides"},"Knob Control State Overrides"),(0,r.kt)("p",null,'Each GTC has a set of "physical" hardware ',(0,r.kt)("a",{parentName:"p",href:"/msfs-avionics-mirror/docs/g3000/gtc-framework#knobs-and-control-state"},"knobs"),", each with an associated control state that helps to define the knob's context-dependent function and how the knob is labeled in the label bar. You can inject your own knob control states using the GTC plugin's ",(0,r.kt)("inlineCode",{parentName:"p"},"getKnobStateOverrides()")," method. If an override is defined, the control state override will replace the state computed by the base G3000 package whenever the override is not ",(0,r.kt)("inlineCode",{parentName:"p"},"null"),"."),(0,r.kt)("p",null,"You may define overrides separately for each knob. In the following example, we define overrides for the center and map knob control states."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"class MyGtcPlugin extends AbstractG3000GtcPlugin {\n  // Tracks whether the GTC is controlling a display pane view with the key 'MyDisplayPaneView'.\n  private readonly isMyDisplayPaneViewActive = MappedSubject.create(\n    ([selectedPaneIndex, viewKey]) => {\n      return selectedPaneIndex !== -1 && viewKey === 'MyDisplayPaneView';\n    },\n    this.binder.gtcService.selectedDisplayPane\n    this.binder.gtcService.selectedPaneSettings.getSetting('displayPaneView')\n  );\n\n  public getKnobStateOverrides(gtcService: GtcService): Readonly<GtcKnobStatePluginOverrides> | null {\n    // If the GTC is controlling the 'MyDisplayPaneView' display pane view, then override the center knob state to be\n    // GtcCenterKnobState.Blank and the map knob state to be GtcMapKnobState.MapNoPointer.\n\n    // Because we have left the dualKnobState property on the returned object undefined, there are no dual concentric\n    // knob state overrides.\n\n    return {\n      centerKnobState: this.isMyDisplayPaneViewActive.map(isActive => isActive ? GtcCenterKnobState.Blank : null),\n\n      mapKnobState: this.isMyDisplayPaneViewActive.map(isActive => isActive ? GtcMapKnobState.MapNoPointer : null)\n    };\n  }\n}\n")),(0,r.kt)("p",null,"If multiple plugins define overrides for the same knob, all overrides are evaluated with those belonging to plugins loaded last taking precedence. For example, if plugins A, B, C are loaded in that order and all define a map knob control state override, C's override will be used unless it is ",(0,r.kt)("inlineCode",{parentName:"p"},"null"),", in which case B's override will be used unless it is ",(0,r.kt)("inlineCode",{parentName:"p"},"null"),", etc."),(0,r.kt)("admonition",{type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"Plugins that inject custom knob control states that are not defined in the base G3000 package ",(0,r.kt)("em",{parentName:"p"},"must")," also define ",(0,r.kt)("a",{parentName:"p",href:"#label-bar-handlers"},"label bar handlers")," that generate appropriate labels for those states. If the label bar cannot find a label to render for a control state, it will throw a runtime error.")),(0,r.kt)("h2",{id:"label-bar-handlers"},"Label Bar Handlers"),(0,r.kt)("p",null,"The GTC label bar is an area on the edge of the screen located next to the GTC knobs which displays text describing the knobs' context-dependent functions. Unless overridden by the active GTC view, what the label bar displays is determined by the ",(0,r.kt)("a",{parentName:"p",href:"/msfs-avionics-mirror/docs/g3000/gtc-framework#knobs-and-control-state"},"control states")," of each GTC knob. You can override how the label bar maps knob control states to labels by using the GTC plugin's ",(0,r.kt)("inlineCode",{parentName:"p"},"getLabelBarHandlers()")," method. When a handler returns a label that is not ",(0,r.kt)("inlineCode",{parentName:"p"},"null"),", it will be displayed in place of the label selected by the base G3000 package."),(0,r.kt)("p",null,"You may define overrides separately for each knob. In the following example, we define overrides for the center and map knobs to provide custom label text."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"class MyGtcPlugin extends AbstractG3000GtcPlugin {\n  // ...\n\n  public getKnobStateOverrides(gtcService: GtcService): Readonly<GtcKnobStatePluginOverrides> | null {\n    // Inject custom knob control states for the center and map knobs while the GTC is controlling a specific display\n    // pane view.\n\n    return {\n      centerKnobState: this.isMyDisplayPaneViewActive.map(isActive => isActive ? 'MyCenterKnobState' : null),\n\n      mapKnobState: this.isMyDisplayPaneViewActive.map(isActive => isActive ? 'MyMapKnobState' : null)\n    };\n  }\n\n  public getLabelBarHandlers(): Readonly<LabelBarPluginHandlers> | null {\n    // Override the center and map knob labels with custom strings when the knob control states are equal to the custom\n    // states we injected using getKnobStateOverrides().\n\n    // Because we have left the dualKnobState property on the returned object undefined, there are no dual concentric\n    // knob label overrides.\n\n    return {\n      centerKnobLabel: knobState => {\n        return knobState === 'MyCenterKnobState' ? 'My Center Knob Label' : null;\n      },\n\n      mapKnobLabel: knobState => {\n        return knobState === 'MyMapKnobState' ? 'My Map Knob Label' : null;\n      }\n    };\n  }\n}\n")),(0,r.kt)("p",null,"If multiple plugins define handlers for the same knob, all handlers are evaluated with those belonging to plugins loaded last taking precedence. For example, if plugins A, B, C are loaded in that order and all define a map knob label handler, the label returned by C's handler will be used unless it is ",(0,r.kt)("inlineCode",{parentName:"p"},"null"),", in which case the label returned by B's handler will be used unless it is ",(0,r.kt)("inlineCode",{parentName:"p"},"null"),", etc."),(0,r.kt)("h2",{id:"interaction-event-handling"},"Interaction Event Handling"),(0,r.kt)("p",null,"When the user ",(0,r.kt)("a",{parentName:"p",href:"/msfs-avionics-mirror/docs/g3000/gtc-framework#interaction-events"},"interacts")," with the GTC's hardware knobs, joysticks, bezel keys, or on-screen button bar, a ",(0,r.kt)("inlineCode",{parentName:"p"},"GtcInteractionEvent")," is generated. The event is routed to a series of handlers implementing the ",(0,r.kt)("inlineCode",{parentName:"p"},"GtcInteractionHandler")," interface, each of which has the option to handle the event or defer to the next handler. The first handler notified is always the active GTC view. If the view does not handle the event, it is then routed to all GTC plugins in the reverse order in which they were loaded. Therefore, you can define custom event handling behavior that is not specific to a GTC view by using the GTC plugin's ",(0,r.kt)("inlineCode",{parentName:"p"},"onGtcInteractionEvent()")," method."),(0,r.kt)("p",null,"In the following example, we define event handling logic for a custom center knob control state."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"class MyGtcPlugin extends AbstractG3000GtcPlugin {\n  // ...\n\n  public getKnobStateOverrides(gtcService: GtcService): Readonly<GtcKnobStatePluginOverrides> | null {\n    // Inject a custom knob control state for the center knob while the GTC is controlling a specific display pane\n    // view.\n\n    return {\n      centerKnobState: this.isMyDisplayPaneViewActive.map(isActive => isActive ? 'MyCenterKnobState' : null)\n    };\n  }\n\n  // ...\n\n  public onGtcInteractionEvent(event: GtcInteractionEvent): boolean {\n    // If the center knob control state is equal to 'MyCenterKnobState', then handle the various center knob events\n    // with custom logic.\n\n    if (this.binder.gtcService.gtcKnobStates.centerKnobState.get() === 'MyCenterKnobState') {\n      switch (event) {\n        case GtcInteractionEvent.CenterKnobDec:\n          // Do something...\n          return true;\n        case GtcInteractionEvent.CenterKnobInc:\n          // Do something...\n          return true;\n        case GtcInteractionEvent.CenterKnobPush:\n          // Do something...\n          return true;\n        default:\n          return false;\n      }\n    } else {\n      return false;\n    }\n  }\n}\n")),(0,r.kt)("admonition",{type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"Make sure to always return ",(0,r.kt)("inlineCode",{parentName:"p"},"true")," from ",(0,r.kt)("inlineCode",{parentName:"p"},"onGtcInteractionEvent()")," when a plugin handles a specific interaction event. Otherwise, the event will continue to be routed to other handlers and may end up being handled more than once.")))}u.isMDXComponent=!0}}]);