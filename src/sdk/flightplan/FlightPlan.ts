import { AltitudeRestrictionType, FlightPlanLeg, LegTurnDirection, LegType, OneWayRunway, SpeedRestrictionType } from '../navigation/Facilities';
import { IcaoValue } from '../navigation/Icao';
import { ICAO } from '../navigation/IcaoUtils';
import { UUID } from '../utils/uuid/UUID';
import { FlightPathCalculator } from './flightpath/FlightPathCalculator';
import {
  FlightPlanLegIndexes, FlightPlanSegment, FlightPlanSegmentType, LegDefinition, ProcedureDetails, SpeedUnit, VerticalData, VerticalFlightPhase
} from './FlightPlanning';

export enum LegEventType {
  Added = 'Added',
  Removed = 'Removed',
  Changed = 'Changed',
}

export enum SegmentEventType {
  Added = 'Added',
  Removed = 'Removed',
  Changed = 'Changed',
  Inserted = 'Inserted',
}

export enum ActiveLegType {
  Lateral = 'Lateral',
  Vertical = 'Vertical',
  Calculating = 'Calculating'
}

export enum OriginDestChangeType {
  OriginAdded = 'OriginAdded',
  OriginRemoved = 'OriginRemoved',
  DestinationAdded = 'DestinationAdded',
  DestinationRemoved = 'DestinationRemoved'
}

/**
 * Indexes describing the location of the direct to target leg in a flight plan.
 */
export type DirectToData = FlightPlanLegIndexes;

/**
 * A flight plan modification batch.
 */
export type FlightPlanModBatch = {
  /** This batch's unique ID. */
  uuid: string;

  /** This batch's name. */
  name?: string;
};

/**
 * Events generated by changes in the flight plan.
 */
export interface PlanEvents {
  /**
   * A callback which is executed when a flight plan leg is added, removed, or its vertical data is changed.
   * @param segmentIndex The index of the segment containing the changed flight plan leg.
   * @param segmentLegIndex The index of the changed flight plan leg in its containing segment.
   * @param type The type of change.
   * @param leg The leg that was changed.
   * @param batch The modification batch stack to which the change was assigned, in order of increasing nestedness.
   * Not defined if the change was not assigned to any batches.
   */
  onLegChanged?(segmentIndex: number, segmentLegIndex: number, type: LegEventType, leg: LegDefinition, batch?: readonly Readonly<FlightPlanModBatch>[]): void;

  /**
   * A callback which is executed when a flight plan segment is added, removed, or changed.
   * @param index The index of the changed flight plan segment.
   * @param type The type of change.
   * @param segment The segment that was changed.
   * @param batch The modification batch stack to which the change was assigned, in order of increasing nestedness.
   * Not defined if the change was not assigned to any batches.
   */
  onSegmentChanged?(index: number, type: SegmentEventType, segment?: FlightPlanSegment, batch?: readonly Readonly<FlightPlanModBatch>[]): void;

  /**
   * A callback which is executed when an active leg is changed.
   * @param index The global index of the leg.
   * @param segmentIndex The index of the flight plan segment.
   * @param previousSegmentIndex The index of the previously active segment.
   * @param previousLegIndex The index of the previously active leg in the previously active segment.
   * @param type The type of leg that was changed.
   * @param batch The modification batch stack to which the change was assigned, in order of increasing nestedness.
   * Not defined if the change was not assigned to any batches.
   */
  onActiveLegChanged?(
    index: number,
    segmentIndex: number,
    legIndex: number,
    previousSegmentIndex: number,
    previousLegIndex: number,
    type: ActiveLegType,
    batch?: readonly Readonly<FlightPlanModBatch>[]
  ): void;

  /**
   * A callback which is executed when the origin or destination changes.
   * @param type The origin/destination change type.
   * @param airportIcao The ICAO value of the airport that was changed, or `undefined` if no airport was changed.
   * @param batch The modification batch stack to which the change was assigned, in order of increasing nestedness.
   * Not defined if the change was not assigned to any batches.
   */
  onOriginDestChanged?(type: OriginDestChangeType, airportIcao: IcaoValue | undefined, batch?: readonly Readonly<FlightPlanModBatch>[]): void;

  /**
   * A callback which is executed when the procedure details change.
   * @param details The details that were changed.
   * @param batch The modification batch stack to which the change was assigned, in order of increasing nestedness.
   * Not defined if the change was not assigned to any batches.
   */
  onProcedureDetailsChanged?(details: Readonly<ProcedureDetails>, batch?: readonly Readonly<FlightPlanModBatch>[]): void;

  /**
   * A callback which is executed when a global key-value user data pair is set.
   * @param key The key of the user data.
   * @param data The user data that was set.
   * @param batch The modification batch stack to which the change was assigned, in order of increasing nestedness.
   * Not defined if the change was not assigned to any batches.
   */
  onUserDataSet?(key: string, data: any, batch?: readonly Readonly<FlightPlanModBatch>[]): void;

  /**
   * A callback which is executed when a global key-value user data pair is deleted.
   * @param key The key of the user data that was deleted.
   * @param batch The modification batch stack to which the change was assigned, in order of increasing nestedness.
   * Not defined if the change was not assigned to any batches.
   */
  onUserDataDelete?(key: string, batch?: readonly Readonly<FlightPlanModBatch>[]): void;

  /**
   * A callback which is executed when a flight plan leg key-value user data pair is set.
   * @param segmentIndex The index of the segment containing the user data's flight plan leg.
   * @param segmentLegIndex The index of the user data's flight plan leg in its containing segment.
   * @param leg The user data's flight plan leg.
   * @param key The key of the user data.
   * @param data The data that was set.
   * @param batch The modification batch stack to which the change was assigned, in order of increasing nestedness.
   * Not defined if the change was not assigned to any batches.
   */
  onLegUserDataSet?(segmentIndex: number, segmentLegIndex: number, leg: LegDefinition, key: string, data: any, batch?: readonly Readonly<FlightPlanModBatch>[]): void;

  /**
   * A callback which is executed when a flight plan leg key-value user data pair is deleted.
   * @param segmentIndex The index of the segment containing the user data's flight plan leg.
   * @param segmentLegIndex The index of the user data's flight plan leg in its containing segment.
   * @param leg The user data's flight plan leg.
   * @param key The key of the user data that was deleted.
   * @param batch The modification batch stack to which the change was assigned, in order of increasing nestedness.
   * Not defined if the change was not assigned to any batches.
   */
  onLegUserDataDelete?(segmentIndex: number, segmentLegIndex: number, leg: LegDefinition, key: string, batch?: readonly Readonly<FlightPlanModBatch>[]): void;

  /**
   * A callback which is executed when direct to data is changed in the plan.
   * @param directToData The direct to data.
   * @param batch The modification batch stack to which the change was assigned, in order of increasing nestedness.
   * Not defined if the change was not assigned to any batches.
   */
  onDirectDataChanged?(directToData: DirectToData, batch?: readonly Readonly<FlightPlanModBatch>[]): void;

  /**
   * A callback which is executed when a flight plan vectorization begins.
   * @param index The global index of the flight plan leg that the path is to be generated from.
   * @param batch The modification batch stack to which the calculation was assigned, in order of increasing
   * nestedness. Not defined if the calculation was not assigned to any batches.
   */
  onCalculatePended?(index?: number, batch?: readonly Readonly<FlightPlanModBatch>[]): void;

  /**
   * A callback which is executed when a flight plan vectorization completes.
   * @param index The global index of the flight plan leg that the path was generated from.
   * @param batch The modification batch stack to which the calculation was assigned, in order of increasing
   * nestedness. Not defined if the calculation was not assigned to any batches.
   */
  onCalculated?(index?: number, batch?: readonly Readonly<FlightPlanModBatch>[]): void;

  /**
   * A callback which is executed when a flight plan modification batch is opened.
   * @param batch The batch that was opened.
   */
  onBatchOpened?(batch: Readonly<FlightPlanModBatch>): void;

  /**
   * A callback which is executed when a flight plan modification batch is closed.
   * @param batch The batch that was closed.
   */
  onBatchClosed?(batch: Readonly<FlightPlanModBatch>): void;

  /**
   * A callback which is executed when a flight plan modification batch has been closed and all pending asynchronous
   * operations assigned to the batch have finished.
   * @param batch The batch that was closed.
   */
  onBatchAsyncClosed?(batch: Readonly<FlightPlanModBatch>): void;
}

/**
 * An entry describing a flight plan modification batch.
 */
type FlightPlanModBatchEntry = {
  /** This entry's flight plan modification batch. */
  batch: FlightPlanModBatch;

  /** The batch's immediate parent. */
  parent: FlightPlanModBatchEntry | undefined;

  /** Whether the batch is closed. */
  isClosed: boolean;

  /** The number of lateral vectorization calculations assigned to this batch that are still pending. */
  pendingCalculateCount: number;
};

/**
 * A flight plan managed by the flight plan system.
 */
export class FlightPlan {

  private _originAirportIcao?: IcaoValue;
  // eslint-disable-next-line jsdoc/require-returns
  /** The ICAO value of the flight plan's origin airport, or `undefined` if the flight plan has no origin airport. */
  public get originAirportIcao(): IcaoValue | undefined {
    return this._originAirportIcao;
  }

  private _destinationAirportIcao?: IcaoValue;
  // eslint-disable-next-line jsdoc/require-returns
  /**
   * The ICAO value of the flight plan's destination airport, or `undefined` if the flight plan has no destination
   * airport.
   */
  public get destinationAirportIcao(): IcaoValue | undefined {
    return this._destinationAirportIcao;
  }

  private _originAirport?: string;
  // eslint-disable-next-line jsdoc/require-returns
  /**
   * The ICAO string (V1) of the flight plan's origin airport, or `undefined` if the flight plan has no origin airport.
   * @deprecated Please use `originAirportIcao` instead.
   */
  public get originAirport(): string | undefined {
    return this._originAirport;
  }

  private _destinationAirport?: string;
  // eslint-disable-next-line jsdoc/require-returns
  /**
   * The ICAO string (V1) of the flight plan's destination airport, or `undefined` if the flight plan has no
   * destination airport.
   * @deprecated Please use `destinationAirportIcao` instead.
   */
  public get destinationAirport(): string | undefined {
    return this._destinationAirport;
  }

  private _activeLateralLeg = 0;
  // eslint-disable-next-line jsdoc/require-returns
  /** The global index of the currently active lateral navigation leg. */
  public get activeLateralLeg(): number {
    return this._activeLateralLeg;
  }

  private _activeVerticalLeg = 0;
  // eslint-disable-next-line jsdoc/require-returns
  /** The global index of the currently active vertical navigation leg. */
  public get activeVerticalLeg(): number {
    return this._activeVerticalLeg;
  }

  private _activeCalculatingLeg = 0;
  // eslint-disable-next-line jsdoc/require-returns
  /** The global index of the currently active calculating leg. */
  public get activeCalculatingLeg(): number {
    return this._activeCalculatingLeg;
  }

  /** The direct to metadata for this plan. */
  public readonly directToData: FlightPlanLegIndexes = { segmentIndex: -1, segmentLegIndex: -1 };

  /**
   * Gets the current number of legs in the flight plan.
   * @returns The number of legs in the plan.
   */
  public get length(): number {
    const segment = this.planSegments[this.planSegments.length - 1];
    if (segment !== undefined) {
      return segment.offset + segment.legs.length;
    }

    return 0;
  }

  /**
   * Gets the current number of segments in the flight plan.
   * @returns The number of legs in the plan.
   */
  public get segmentCount(): number {
    return this.planSegments.length;
  }

  /** Events fired when the plan is modified. */
  public events: PlanEvents = {};

  /** The details about the selected procedures. */
  public readonly procedureDetails = FlightPlan.createProcedureDetails();

  /** The flight plan segments that make up this flight plan. */
  private readonly planSegments: (FlightPlanSegment | undefined)[] = [];

  /** User assignable data. */
  private readonly userData: { [index: string]: any } = {};

  private readonly batchEntryStack: FlightPlanModBatchEntry[] = [];
  private batchToCloseIndex: number | undefined = undefined;

  private readonly legIndexesCache: DirectToData = { segmentIndex: -1, segmentLegIndex: -1 };

  /**
   * Creates an instance of a FlightPlan.
   * @param planIndex The index within the flight planner of this flight plan.
   * @param calculator The flight path calculator to use to calculate the flight path.
   * @param onLegNameRequested A callback fired when a flight plan leg is to be named.
   */
  public constructor(
    public planIndex: number,
    public calculator: FlightPathCalculator,
    private onLegNameRequested: ((leg: FlightPlanLeg) => string | undefined)
  ) { }

  /**
   * Gets this flight plan's legs.
   * @param reverse Whether to get the legs in reverse order. False by default.
   * @param startIndex The global leg index of the leg at which to start, inclusive. Defaults to `0` if `reverse` is
   * `false` or `this.length - 1` if `reverse` is `true`.
   * @param endIndex The global leg index of the leg at which to end, exclusive. Defaults to `this.length` if `reverse`
   * is `false` or `-1` if `reverse` is `true`.
   * @returns A generator which yields this flight plan's legs.
   */
  public legs(reverse = false, startIndex?: number, endIndex?: number): Generator<LegDefinition, void> {
    return reverse ? this._legsReverse(startIndex, endIndex) : this._legs(startIndex, endIndex);
  }

  /**
   * Gets this flight plan's legs in forward order.
   * @param startIndex The global leg index of the leg at which to start, inclusive. Defaults to `0`.
   * @param endIndex The global leg index of the leg at which to end, exclusive. Defaults to `this.length`.
   * @yields This flight plan's legs in forward order.
   */
  private *_legs(startIndex = 0, endIndex = this.length): Generator<LegDefinition, void> {
    endIndex = Math.min(this.length, endIndex);

    for (let i = 0; i < this.planSegments.length; i++) {
      const segment = this.planSegments[i];

      if (segment !== undefined && segment.legs.length > 0) {
        const end = Math.min(segment.legs.length, endIndex - segment.offset);

        if (end <= 0) {
          return;
        }

        for (let l = Math.max(0, startIndex - segment.offset); l < end; l++) {
          yield segment.legs[l];
        }
      }
    }
  }

  /**
   * Gets this flight plan's legs in reverse order.
   * @param startIndex The global leg index of the leg at which to start, inclusive. Defaults to `this.length - 1`.
   * @param endIndex The global leg index of the leg at which to end, exclusive. Defaults to `-1`.
   * @yields This flight plan's legs in reverse order.
   */
  private *_legsReverse(startIndex = this.length - 1, endIndex = -1): Generator<LegDefinition, void> {
    endIndex = Math.max(-1, endIndex);

    for (let i = this.planSegments.length - 1; i > -1; i--) {
      const segment = this.planSegments[i];

      if (segment !== undefined && segment.legs.length > 0) {
        const end = Math.max(-1, endIndex - segment.offset);

        if (end >= segment.legs.length) {
          return;
        }

        for (let l = Math.min(segment.legs.length - 1, startIndex - segment.offset); l > end; l--) {
          yield segment.legs[l];
        }
      }
    }
  }

  /**
   * Gets the segments for the flightplan.
   * @yields The flight plan segments.
   */
  public *segments(): Generator<FlightPlanSegment, void> {
    for (let i = 0; i < this.planSegments.length; i++) {
      const segment = this.planSegments[i];

      if (segment !== undefined) {
        yield segment;
      }
    }
  }


  /**
   * Gets all of the segments of a given type.
   * @param segmentType The type of the segments to retrieve.
   * @yields The segments of the requested type.
   */
  public *segmentsOfType(segmentType: FlightPlanSegmentType): Generator<FlightPlanSegment, void> {
    for (const segment of this.segments()) {
      if (segment.segmentType == segmentType) {
        yield segment;
      }
    }
  }

  /**
   * Gets a flight plan segment from the plan.
   * @param segmentIndex The index of the segment to get; if not specified returns the active segment.
   * @returns The requested flight plan segment.
   * @throws An error if the flight plan segment could not be found.
   */
  public getSegment(segmentIndex?: number): FlightPlanSegment {
    const segment = this.tryGetSegment(segmentIndex);

    if (segment === null) {
      throw new Error(`Flight plan segment with ${segmentIndex === undefined ? 'active leg' : `segment index ${segmentIndex}`} could not be found.`);
    } else {
      return segment;
    }
  }

  /**
   * Attempts to get a flight plan segment from the plan.
   * @param segmentIndex The index of the segment to get; if not specified returns the active segment.
   * @returns The requested flight plan segment, or `null` if it could not be found.
   */
  public tryGetSegment(segmentIndex?: number): FlightPlanSegment | null {
    if (segmentIndex === undefined) {
      let calculatedSegmentIndex = 0;
      for (const segment of this.segments()) {
        if (this.activeLateralLeg == 0 && segment.legs.length == 0) {
          calculatedSegmentIndex++;
        } else if (this.activeLateralLeg > segment.offset + segment.legs.length) {
          calculatedSegmentIndex++;
        } else {
          break;
        }
      }
      const segment = this.planSegments[calculatedSegmentIndex];
      if (segment !== undefined) {
        return segment;
      }
    } else if (segmentIndex >= 0) {
      const segment = this.planSegments[segmentIndex];
      if (segment !== undefined) {
        return segment;
      }
    }

    return null;
  }

  /**
   * Gets a leg from the flight plan.
   * @param indexes The indexes describing the location of the leg to get.
   * @returns A flight plan leg.
   * @throws Error if the leg could not be found.
   */
  public getLeg(indexes: Readonly<FlightPlanLegIndexes>): LegDefinition;
  /**
   * Gets a leg from the flight plan.
   * @param segmentIndex The index of the segment containing the leg to get.
   * @param segmentLegIndex The index of the leg to get in its segment.
   * @returns A flight plan leg.
   * @throws Error if the leg could not be found.
   */
  public getLeg(segmentIndex: number, segmentLegIndex: number): LegDefinition;
  /**
   * Gets a leg from the flight plan.
   * @param globalLegIndex The global leg index of the leg to get.
   * @returns A flight plan leg.
   * @throws Error if the leg could not be found.
   */
  public getLeg(globalLegIndex: number): LegDefinition;
  // eslint-disable-next-line jsdoc/require-jsdoc
  public getLeg(arg1: number | Readonly<FlightPlanLegIndexes>, arg2?: number): LegDefinition {
    const leg = this._tryGetLeg(arg1, arg2);

    if (leg) {
      return leg;
    }

    const indexes = typeof arg1 === 'object' || arg2 !== undefined
      ? arg2 === undefined
        ? `segment index ${(arg1 as Readonly<FlightPlanLegIndexes>).segmentIndex}, segment leg index ${(arg1 as Readonly<FlightPlanLegIndexes>).segmentLegIndex}`
        : `segment index ${arg1}, segment leg index ${arg2}`
      : `global leg index ${arg1}`;
    throw new Error(`Leg with ${indexes} could not be found.`);
  }

  /**
   * Attempts to get a leg from the flight plan.
   * @param indexes The indexes describing the location of the leg to get.
   * @returns A flight plan leg, or `null` if one could not be found at the specified location.
   */
  public tryGetLeg(indexes: Readonly<FlightPlanLegIndexes>): LegDefinition | null;
  /**
   * Attempts to get a leg from the flight plan.
   * @param segmentIndex The index of the segment containing the leg to get.
   * @param segmentLegIndex The index of the leg to get in its segment.
   * @returns A flight plan leg, or `null` if one could not be found at the specified index.
   */
  public tryGetLeg(segmentIndex: number, segmentLegIndex: number): LegDefinition | null;
  /**
   * Attempts to get a leg from the flight plan.
   * @param globalLegIndex The global leg index of the leg to get.
   * @returns A flight plan leg, or `null` if one could not be found at the specified index.
   */
  public tryGetLeg(globalLegIndex: number): LegDefinition | null;
  // eslint-disable-next-line jsdoc/require-jsdoc
  public tryGetLeg(arg1: number | Readonly<FlightPlanLegIndexes>, arg2?: number): LegDefinition | null {
    return this._tryGetLeg(arg1, arg2);
  }

  /**
   * Attempts to get a leg from the flight plan.
   * @param arg1 The global leg index of the leg to get, or the index of the segment containing the leg to get.
   * @param arg2 The index of the leg to get in its segment.
   * @returns A flight plan leg, or `null` if one could not be found at the specified index.
   */
  private _tryGetLeg(arg1: number | Readonly<FlightPlanLegIndexes>, arg2?: number): LegDefinition | null {
    if (typeof arg1 === 'object' || arg2 !== undefined) {
      let segmentIndex: number;
      let segmentLegIndex: number;
      if (arg2 === undefined) {
        ({ segmentIndex, segmentLegIndex } = arg1 as Readonly<FlightPlanLegIndexes>);
      } else {
        segmentIndex = arg1 as number;
        segmentLegIndex = arg2;
      }
      return this.planSegments[segmentIndex]?.legs[segmentLegIndex] ?? null;
    } else {
      const legIndex = arg1;
      for (let i = 0; i < this.planSegments.length; i++) {
        const segment = this.planSegments[i];
        if (segment && segment.offset <= legIndex && legIndex < segment.offset + segment.legs.length) {
          return segment.legs[legIndex - segment.offset];
        }
      }
      return null;
    }
  }

  /**
   * Gets the global index of a flight plan leg in this flight plan.
   * @param leg A flight plan leg definition.
   * @returns the global index of the leg, or -1 if the leg is not in this flight plan.
   */
  public getLegIndexFromLeg(leg: LegDefinition): number {
    let index = 0;
    for (const toCompare of this.legs()) {
      if (toCompare === leg) {
        return index;
      }
      index++;
    }

    return -1;
  }

  /**
   * Gets the indexes describing the location of a flight plan leg in this flight plan.
   * @param leg The flight plan leg for which to get indexes.
   * @param out The object to which to write the result. If not defined, then a new index object will be created.
   * @returns The indexes describing the location of the specified flight plan leg in this flight plan. If the leg
   * is not in this flight plan, then all indexes will be equal to `-1`.
   */
  public getLegIndexesFromLeg(leg: LegDefinition, out?: FlightPlanLegIndexes): FlightPlanLegIndexes {
    out ??= {
      segmentIndex: -1,
      segmentLegIndex: -1
    };

    for (let segmentIndex = 0; segmentIndex < this.planSegments.length; segmentIndex++) {
      const segment = this.planSegments[segmentIndex];

      if (segment !== undefined && segment.legs.length > 0) {
        for (let segmentLegIndex = 0; segmentLegIndex < segment.legs.length; segmentLegIndex++) {
          if (segment.legs[segmentLegIndex] === leg) {
            out.segmentIndex = segmentIndex;
            out.segmentLegIndex = segmentLegIndex;
            return out;
          }
        }
      }
    }

    return out;
  }

  /**
   * Gets the indexes describing the location of a global leg index in this flight plan.
   * @param globalLegIndex The global leg index for which to get indexes.
   * @param out The object to which to write the result. If not defined, then a new index object will be created.
   * @returns The indexes describing the location of the specified global leg index this flight plan. If the global leg
   * index does not point to a valid leg in this flight plan, then all indexes will be equal to `-1`.
   */
  public getLegIndexesFromGlobalLegIndex(globalLegIndex: number, out?: FlightPlanLegIndexes): FlightPlanLegIndexes {
    out ??= {
      segmentIndex: -1,
      segmentLegIndex: -1
    };

    if (globalLegIndex >= 0 && globalLegIndex < this.length) {
      for (let i = 0; i < this.planSegments.length; i++) {
        const segment = this.planSegments[i];
        if (segment && segment.offset <= globalLegIndex && globalLegIndex < segment.offset + segment.legs.length) {
          out.segmentIndex = segment.segmentIndex;
          out.segmentLegIndex = globalLegIndex - segment.offset;
          return out;
        }
      }
    }

    return out;
  }

  /**
   * Gets the segment index for a given global leg index.
   * @param globalLegIndex The global leg index to get the segment index for.
   * @returns The segment index for the given global leg index, or -1 if not found.
   */
  public getSegmentIndex(globalLegIndex: number): number {
    return this.getLegIndexesFromGlobalLegIndex(globalLegIndex, this.legIndexesCache).segmentIndex;
  }

  /**
   * Gets the segment leg index (the index of the leg in its segment) for a given global leg index.
   * @param globalLegIndex The global leg index to get the segment leg index for.
   * @returns The segment leg index, or -1 if not found.
   */
  public getSegmentLegIndex(globalLegIndex: number): number {
    return this.getLegIndexesFromGlobalLegIndex(globalLegIndex, this.legIndexesCache).segmentLegIndex;
  }

  /**
   * Gets the flight plan segment to which a leg belongs.
   * @param leg A flight plan leg definition.
   * @returns The segment to which the leg belongs, or null if the leg is not in this flight plan.
   */
  public getSegmentFromLeg(leg: LegDefinition): FlightPlanSegment | null {
    for (const segment of this.segments()) {
      if (segment.legs.includes(leg)) {
        return segment;
      }
    }

    return null;
  }

  /**
   * Gets the leg immediately previous to a position in this flight plan.
   * @param legIndexes The indexes describing the position for which to get the previous leg.
   * @returns The leg immediately previous to the specified position, or `null` if there is no such leg.
   */
  public getPrevLeg(legIndexes: Readonly<FlightPlanLegIndexes>): LegDefinition | null;
  /**
   * Gets the leg immediately previous to a position in this flight plan.
   * @param segmentIndex The index of the segment containing the position for which to get the previous leg.
   * @param segmentLegIndex The index of the position for which to get the previous leg in its containing segment.
   * @returns The leg immediately previous to the specified position, or `null` if there is no such leg.
   */
  public getPrevLeg(segmentIndex: number, segmentLegIndex: number): LegDefinition | null;
  // eslint-disable-next-line jsdoc/require-jsdoc
  public getPrevLeg(arg1: number | Readonly<FlightPlanLegIndexes>, arg2?: number): LegDefinition | null {
    let segmentIndex: number;
    let segmentLegIndex: number;

    if (arg2 === undefined) {
      ({ segmentIndex, segmentLegIndex } = arg1 as Readonly<FlightPlanLegIndexes>);
    } else {
      segmentIndex = arg1 as number;
      segmentLegIndex = arg2;
    }

    if (segmentIndex < 0) {
      return null;
    }

    segmentIndex = Math.min(segmentIndex, this.planSegments.length);
    segmentLegIndex = Math.min(segmentLegIndex, this.planSegments[segmentIndex]?.legs.length ?? 0);

    let segment = this.planSegments[segmentIndex];
    let leg = segment?.legs[segmentLegIndex - 1];
    while (!leg && --segmentIndex >= 0) {
      segment = this.planSegments[segmentIndex];
      if (segment) {
        leg = segment.legs[segment.legs.length - 1];
      }
    }

    return leg ?? null;
  }

  /**
   * Gets the leg immediately after a position in this flight plan.
   * @param legIndexes The indexes describing the position for which to get the next leg.
   * @returns The leg immediately after the specified position, or `null` if there is no such leg.
   */
  public getNextLeg(legIndexes: Readonly<FlightPlanLegIndexes>): LegDefinition | null;
  /**
   * Gets the leg immediately after a position in this flight plan.
   * @param segmentIndex The index of the segment containing the position for which to get the next leg.
   * @param segmentLegIndex The index of the position for which to get the next leg in its containing segment.
   * @returns The leg immediately after the specified position, or `null` if there is no such leg.
   */
  public getNextLeg(segmentIndex: number, segmentLegIndex: number): LegDefinition | null;
  // eslint-disable-next-line jsdoc/require-jsdoc
  public getNextLeg(arg1: number | Readonly<FlightPlanLegIndexes>, arg2?: number): LegDefinition | null {
    let segmentIndex: number;
    let segmentLegIndex: number;

    if (arg2 === undefined) {
      ({ segmentIndex, segmentLegIndex } = arg1 as Readonly<FlightPlanLegIndexes>);
    } else {
      segmentIndex = arg1 as number;
      segmentLegIndex = arg2;
    }

    if (segmentIndex >= this.planSegments.length) {
      return null;
    }

    segmentIndex = Math.max(segmentIndex, -1);
    segmentLegIndex = Math.max(segmentLegIndex, -1);

    let segment = this.planSegments[segmentIndex];
    let leg = segment?.legs[segmentLegIndex + 1];
    while (!leg && ++segmentIndex < this.planSegments.length) {
      segment = this.planSegments[segmentIndex];
      if (segment) {
        leg = segment.legs[0];
      }
    }

    return leg ?? null;
  }

  /**
   * Finds a leg in this flight plan that satisfies a given condition.
   * @param predicate A function that evaluates whether each leg satisfies the condition to be returned by this method.
   * The function is called once for each evaluated leg and should return `true` if the leg satisfies the condition and
   * `false` otherwise.
   * @param reverse Whether to evaluate the legs in reverse order. Defaults to `false`.
   * @param startIndex The global leg index of the first leg to evaluate, inclusive. Defaults to `0` if `reverse` is
   * `false` or `this.length - 1` if `reverse` is `true`.
   * @param endIndex The global leg index of the last leg to evaluate, exclusive. Defaults to `this.length` if `reverse`
   * is `false` or `-1` if `reverse` is `true`.
   * @returns The first evaluated leg in this flight plan that satisfies the condition defined by the specified
   * predicate function, or `null` if no leg satisfies the condition.
   */
  public findLeg(
    predicate: (leg: LegDefinition, segment: FlightPlanSegment, segmentIndex: number, segmentLegIndex: number, plan: FlightPlan) => boolean,
    reverse = false,
    startIndex?: number,
    endIndex?: number
  ): LegDefinition | null {
    return reverse
      ? this.findLegReverse(predicate, startIndex, endIndex)
      : this.findLegForward(predicate, startIndex, endIndex);
  }

  /**
   * Evaluates legs in this flight plan in forward order and returns the first evaluated leg that satisfies a given
   * condition.
   * @param predicate A function that evaluates whether each leg satisfies the condition to be returned by this method.
   * The function is called once for each evaluated leg and should return `true` if the leg satisfies the condition and
   * `false` otherwise.
   * @param startIndex The global leg index of the first leg to evaluate, inclusive. Defaults to `0`.
   * @param endIndex The global leg index of the last leg to evaluate, exclusive. Defaults to `this.length`.
   * @returns The first evaluated leg in this flight plan that satisfies the condition defined by the specified
   * predicate function, or `null` if no leg satisfies the condition.
   */
  private findLegForward(
    predicate: (leg: LegDefinition, segment: FlightPlanSegment, segmentIndex: number, segmentLegIndex: number, plan: FlightPlan) => boolean,
    startIndex = 0,
    endIndex = this.length
  ): LegDefinition | null {
    endIndex = Math.min(this.length, endIndex);

    for (let segmentIndex = 0; segmentIndex < this.planSegments.length; segmentIndex++) {
      const segment = this.planSegments[segmentIndex];

      if (segment !== undefined && segment.legs.length > 0) {
        const end = Math.min(segment.legs.length, endIndex - segment.offset);

        if (end <= 0) {
          return null;
        }

        for (let segmentLegIndex = Math.max(0, startIndex - segment.offset); segmentLegIndex < end; segmentLegIndex++) {
          if (predicate(segment.legs[segmentLegIndex], segment, segment.segmentIndex, segmentLegIndex, this)) {
            return segment.legs[segmentLegIndex];
          }
        }
      }
    }

    return null;
  }

  /**
   * Evaluates legs in this flight plan in reverse order and returns the first evaluated leg that satisfies a given
   * condition.
   * @param predicate A function that evaluates whether each leg satisfies the condition to be returned by this method.
   * The function is called once for each evaluated leg and should return `true` if the leg satisfies the condition and
   * `false` otherwise.
   * @param startIndex The global leg index of the first leg to evaluate, inclusive. Defaults to `this.length - 1`.
   * @param endIndex The global leg index of the last leg to evaluate, exclusive. Defaults to `-1`.
   * @returns The first evaluated leg in this flight plan that satisfies the condition defined by the specified
   * predicate function, or `null` if no leg satisfies the condition.
   */
  private findLegReverse(
    predicate: (leg: LegDefinition, segment: FlightPlanSegment, segmentIndex: number, segmentLegIndex: number, plan: FlightPlan) => boolean,
    startIndex = this.length - 1,
    endIndex = -1
  ): LegDefinition | null {
    endIndex = Math.max(-1, endIndex);

    for (let segmentIndex = this.planSegments.length - 1; segmentIndex > -1; segmentIndex--) {
      const segment = this.planSegments[segmentIndex];

      if (segment !== undefined && segment.legs.length > 0) {
        const end = Math.max(-1, endIndex - segment.offset);

        if (end >= segment.legs.length) {
          return null;
        }

        for (let segmentLegIndex = Math.min(segment.legs.length - 1, startIndex - segment.offset); segmentLegIndex > end; segmentLegIndex--) {
          if (predicate(segment.legs[segmentLegIndex], segment, segment.segmentIndex, segmentLegIndex, this)) {
            return segment.legs[segmentLegIndex];
          }
        }
      }
    }

    return null;
  }

  /**
   * Gets user data from the flight plan.
   * @param key The key of the user data.
   * @returns The user data, if found.
   */
  public getUserData<T>(key: string): T | undefined {
    return this.userData[key];
  }

  /**
   * Gets the current modification batch stack.
   * @returns The current modification batch stack, or `undefined` if there are no open batches.
   */
  public getBatchStack(): readonly Readonly<FlightPlanModBatch>[] | undefined {
    return this.batchEntryStack.length > 0 ? this.batchEntryStack.map(entry => entry.batch) : undefined;
  }

  /**
   * Opens a new modification batch. The new batch will be nested within the most recently opened batch that has not
   * yet been closed. While a batch is open, all modifications made to this flight plan will be assigned to the batch.
   * The use of batches is informational only and will not affect the timing or execution of flight plan modifications.
   * All modifications are carried out immediately when the corresponding method is called regardless of whether they
   * are assigned to a batch.
   * @param name The name to assign to the new batch.
   * @returns The UUID of the new batch.
   */
  public openBatch(name?: string): string {
    const parent = this.batchEntryStack[this.batchEntryStack.length - 1] as FlightPlanModBatchEntry | undefined;

    const uuid = UUID.GenerateUuid();
    const batch = { uuid, name };
    const entry: FlightPlanModBatchEntry = {
      batch,
      parent,
      isClosed: false,
      pendingCalculateCount: 0,
    };
    this.batchEntryStack.push(entry);

    try {
      this.events.onBatchOpened && this.events.onBatchOpened(batch);
    } catch (e) {
      console.error(e);
      if (e instanceof Error) {
        console.error(e.stack);
      }
    }

    return uuid;
  }

  /**
   * Closes a modification batch.
   * @param uuid The UUID of the batch to close. If defined, then the batch with the specified UUID and all open
   * batches that are nested within it will be closed (with the most-nested batch closed first, followed by the next
   * most-nested batch, and so on). If not defined, then the most recently opened batch that has not yet been closed
   * (i.e. the most-nested open batch) will be closed.
   */
  public closeBatch(uuid?: string): void {
    let stopIndex = this.batchEntryStack.length;

    if (uuid === undefined) {
      if (this.batchEntryStack.length > 0) {
        stopIndex = this.batchEntryStack.length - 1;
      }
    } else {
      const index = this.batchEntryStack.findIndex(entry => entry.batch.uuid === uuid);
      if (index >= 0) {
        stopIndex = index;
      }
    }

    this.closeBatchIndex(stopIndex);
  }

  /**
   * Closes all currently open modification batches.
   */
  public closeAllBatches(): void {
    this.closeBatchIndex(0);
  }

  /**
   * Closes an indexed modification batch and all batches that are nested within it.
   * @param index The index of the batch to close.
   */
  private closeBatchIndex(index: number): void {
    index = Math.max(index, 0);

    // Check if a batch closure operation is currently in progress. If one is not, then start a new batch closure
    // operation. If one is in progress, then mark the index of the new batch to close if and only if it is less-
    // nested than the in-progress operation's current batch to close.
    if (this.batchToCloseIndex === undefined) {
      this.batchToCloseIndex = index;

      while (this.batchEntryStack.length > this.batchToCloseIndex) {
        const entry = this.batchEntryStack.pop() as FlightPlanModBatchEntry;
        const currentBatchToCloseIndex: number = this.batchToCloseIndex;
        const isClosingLast = this.batchEntryStack.length === currentBatchToCloseIndex + 1;

        entry.isClosed = true;
        this.events.onBatchClosed && this.events.onBatchClosed(entry.batch);
        if (entry.pendingCalculateCount === 0) {
          this.events.onBatchAsyncClosed && this.events.onBatchAsyncClosed(entry.batch);
        }

        // If we closed the last batch and no less-nested batches were marked for closure, then we will end the
        // loop. This is to prevent us from closing any batches that were newly opened in the callbacks for closing
        // the last batch.
        if (isClosingLast && this.batchToCloseIndex === currentBatchToCloseIndex) {
          break;
        }
      }

      this.batchToCloseIndex = undefined;
    } else {
      this.batchToCloseIndex = Math.min(this.batchToCloseIndex, index);
    }
  }

  /**
   * Adds a segment to the flight plan at a specified index.
   * @param segmentIndex The index of the flight plan segment.
   * @param segmentType The type of segment this will be.
   * @param airway The airway this segment is made up of, if any.
   * @param notify Whether or not to send notifications after the operation.
   * @returns The new flight plan segment.
   */
  public addSegment(segmentIndex: number,
    segmentType: FlightPlanSegmentType = FlightPlanSegmentType.Enroute, airway?: string, notify = true): FlightPlanSegment {
    const segment = new FlightPlanSegment(segmentIndex, -1, [], segmentType, airway);
    this.planSegments[segmentIndex] = segment;

    this.reflowSegmentOffsets();
    notify && this.events.onSegmentChanged && this.events.onSegmentChanged(segmentIndex, SegmentEventType.Added, segment, this.getBatchStack());

    return segment;
  }

  /**
   * Inserts a segment into the flight plan at the specified index and
   * reflows the subsequent segments.
   * @param segmentIndex The index to insert the flight plan segment.
   * @param segmentType The type of segment this will be.
   * @param airway The airway this segment is made up of, if any
   * @param notify Whether or not to send notifications after the operation.
   * @returns The new flight plan segment.
   */
  public insertSegment(segmentIndex: number,
    segmentType: FlightPlanSegmentType = FlightPlanSegmentType.Enroute, airway?: string, notify = true): FlightPlanSegment {
    const segment = this.planSegments[segmentIndex];
    if (segment !== undefined) {
      const newSegment = new FlightPlanSegment(segmentIndex, -1, [], segmentType, airway);
      this.planSegments.splice(segmentIndex, 0, newSegment);

      this.reflowSegments();
      this.reflowSegmentOffsets();
      notify && this.events.onSegmentChanged && this.events.onSegmentChanged(segmentIndex, SegmentEventType.Inserted, newSegment, this.getBatchStack());

      return newSegment;
    } else {
      return this.addSegment(segmentIndex, segmentType, airway, notify);
    }
  }

  /**
   * Reflows the flight plan segments after an insert.
   */
  private reflowSegments(): void {
    for (let i = 0; i < this.planSegments.length; i++) {
      const segment = this.planSegments[i];
      if (segment !== undefined && segment.segmentIndex !== i) {
        segment.segmentIndex = i;
      }
    }
  }

  /**
   * Deletes a segment from the flight plan, leaving an empty segment at the specified index.
   * @param segmentIndex The index of the segment to remove.
   * @param notify Whether or not to send notifications after the operation.
   */
  public deleteSegment(segmentIndex: number, notify = true): void {
    const segment = this.planSegments[segmentIndex];

    if (segmentIndex === this.planSegments.length - 1) {
      this.planSegments.splice(segmentIndex, 1);
    } else {
      delete this.planSegments[segmentIndex];
    }

    if (this.directToData.segmentIndex === segmentIndex) {
      // TODO: Do we want to automatically do this?
      //this.setDirectToData(-1);
    }

    this.reflowSegmentOffsets();
    notify && this.events.onSegmentChanged && this.events.onSegmentChanged(segmentIndex, SegmentEventType.Removed, segment, this.getBatchStack());
  }

  /**
   * Removes a segment from the flight plan and reflows the segments following
   * the removed segment, not leaving an empty segment at the specified index.
   * @param segmentIndex The index of the segment to remove.
   * @param notify Whether or not to send notifications after the operation.
   */
  public removeSegment(segmentIndex: number, notify = true): void {
    const segment = this.planSegments[segmentIndex];
    this.planSegments.splice(segmentIndex, 1);

    this.reflowSegments();
    this.reflowSegmentOffsets();
    notify && this.events.onSegmentChanged && this.events.onSegmentChanged(segmentIndex, SegmentEventType.Removed, segment, this.getBatchStack());
  }

  /**
   * Adds a leg to the flight plan.
   * @param segmentIndex The segment to add the leg to.
   * @param leg The leg to add to the plan.
   * @param segmentLegIndex The index of the leg in the segment to insert. Will add to the end of the segment if omitted.
   * @param flags Leg definition flags to apply to the new leg. Defaults to `None` (0).
   * @param notify Whether or not to send notifications after the operation.
   * @returns the leg that was added.
   */
  public addLeg(segmentIndex: number, leg: FlightPlanLeg, segmentLegIndex?: number, flags = 0, notify = true): LegDefinition {
    const segment = this.getSegment(segmentIndex);
    const legDefinition: LegDefinition = {
      name: this.onLegNameRequested(leg),
      leg,
      flags,
      verticalData: {
        phase: VerticalFlightPhase.Descent,
        altDesc: AltitudeRestrictionType.Unused,
        altitude1: 0,
        altitude2: 0,
        displayAltitude1AsFlightLevel: false,
        displayAltitude2AsFlightLevel: false,
        isAltitude1TempCompensated: false,
        isAltitude2TempCompensated: false,
        speedDesc: SpeedRestrictionType.Unused,
        speed: 0,
        speedUnit: SpeedUnit.IAS,
      },
      userData: {}
    };

    if (segmentLegIndex === undefined) {
      segment.legs.push(legDefinition);
      segmentLegIndex = segment.legs.length - 1;
    } else {
      segment.legs.splice(segmentLegIndex, 0, legDefinition);
    }

    this.reflowSegmentOffsets();
    notify && this.events.onLegChanged && this.events.onLegChanged(segmentIndex, segmentLegIndex, LegEventType.Added, legDefinition, this.getBatchStack());
    return legDefinition;
  }

  /**
   * Removes a leg from the flight plan.
   * @param segmentIndex The segment to add the leg to.
   * @param segmentLegIndex The index of the leg in the segment to remove. Will remove from the end of the segment if ommitted.
   * @param notify Whether or not to send notifications after the operation.
   * @returns the leg that was removed, or null if a leg was not removed.
   */
  public removeLeg(segmentIndex: number, segmentLegIndex?: number, notify = true): LegDefinition | null {
    const segment = this.getSegment(segmentIndex);

    let legDefinition: LegDefinition | undefined;

    if (segmentLegIndex === undefined) {
      legDefinition = segment.legs.pop();
      segmentLegIndex = segment.legs.length;
    } else {
      const deleted = segment.legs.splice(segmentLegIndex, 1);
      legDefinition = deleted[0] as LegDefinition | undefined;
    }

    if (this.directToData.segmentIndex === segmentIndex && this.directToData.segmentLegIndex === segmentLegIndex) {
      // TODO: Do we want to automatically do this?
      //this.setDirectToData(-1);
    }

    this.reflowSegmentOffsets();
    notify && legDefinition && this.events.onLegChanged && this.events.onLegChanged(segmentIndex, segmentLegIndex, LegEventType.Removed, legDefinition, this.getBatchStack());
    return legDefinition ?? null;
  }

  /**
   * Reflows all flight plan segment offsets after a plan change.
   */
  private reflowSegmentOffsets(): void {
    let nextOffset: number | undefined = undefined;
    for (let i = 0; i < this.planSegments.length; i++) {
      const segment = this.planSegments[i];

      if (segment) {
        if (nextOffset === undefined) {
          segment.offset = 0;
        } else {
          segment.offset = nextOffset;
        }

        nextOffset = segment.legs.length + segment.offset;
      }
    }
  }

  /**
   * Sets the origin airport in the flight plan.
   * @param facilityIcao The ICAO value of the origin airport to set.
   * @param notify Whether to notify subscribers of the change. Defaults to `true`.
   */
  public setOriginAirport(facilityIcao: IcaoValue, notify?: boolean): void;
  /**
   * Sets the origin airport in the flight plan.
   * @param facilityIcao The ICAO string (V1) of the origin airport to set.
   * @param notify Whether to notify subscribers of the change. Defaults to `true`.
   * @deprecated Please use the signature that takes an `IcaoValue` for the `facilityIcao` parameter.
   */
  public setOriginAirport(facilityIcao: string, notify?: boolean): void;
  // eslint-disable-next-line jsdoc/require-jsdoc
  public setOriginAirport(facilityIcao: IcaoValue | string, notify = true): void {
    if (typeof facilityIcao === 'object') {
      this._originAirportIcao = facilityIcao;
      this._originAirport = ICAO.valueToStringV1(facilityIcao);
    } else {
      this._originAirportIcao = ICAO.stringV1ToValue(facilityIcao);
      this._originAirport = facilityIcao;
    }

    notify && this.events.onOriginDestChanged
      && this.events.onOriginDestChanged(OriginDestChangeType.OriginAdded, this._originAirportIcao, this.getBatchStack());
  }

  /**
   * Removes the origin airport from the flight plan.
   * @param notify Whether to notify subscribers of the change. Defaults to `true`.
   */
  public removeOriginAirport(notify = true): void {
    const facilityIcao = this._originAirportIcao;

    this._originAirportIcao = undefined;
    this._originAirport = undefined;

    this.procedureDetails.departureIndex = -1;
    this.procedureDetails.departureRunwayIndex = -1;
    this.procedureDetails.departureTransitionIndex = -1;
    this.procedureDetails.originRunway = undefined;

    notify && this.events.onOriginDestChanged
      && this.events.onOriginDestChanged(OriginDestChangeType.OriginRemoved, facilityIcao, this.getBatchStack());
  }

  /**
   * Sets the destination airport in the flight plan.
   * @param facilityIcao The ICAO value of the destination airport to set.
   * @param notify Whether to notify subscribers of the change. Defaults to `true`.
   */
  public setDestinationAirport(facilityIcao: IcaoValue, notify?: boolean): void;
  /**
   * Sets the destination airport in the flight plan.
   * @param facilityIcao The ICAO string (V1) of the destination airport to set.
   * @param notify Whether to notify subscribers of the change. Defaults to `true`.
   * @deprecated Please use the signature that takes an `IcaoValue` for the `facilityIcao` parameter.
   */
  public setDestinationAirport(facilityIcao: string, notify?: boolean): void;
  // eslint-disable-next-line jsdoc/require-jsdoc
  public setDestinationAirport(facilityIcao: IcaoValue | string, notify = true): void {
    if (typeof facilityIcao === 'object') {
      this._destinationAirportIcao = facilityIcao;
      this._destinationAirport = ICAO.valueToStringV1(facilityIcao);
    } else {
      this._destinationAirportIcao = ICAO.stringV1ToValue(facilityIcao);
      this._destinationAirport = facilityIcao;
    }

    notify && this.events.onOriginDestChanged &&
      this.events.onOriginDestChanged(OriginDestChangeType.DestinationAdded, this._destinationAirportIcao, this.getBatchStack());
  }

  /**
   * Removes the destination airport from the flight plan.
   * @param notify Whether to notify subscribers of the change. Defaults to `true`.
   */
  public removeDestinationAirport(notify = true): void {
    const facilityIcao = this._destinationAirportIcao;

    this._destinationAirportIcao = undefined;
    this._destinationAirport = undefined;

    this.procedureDetails.approachIndex = -1;
    this.procedureDetails.approachTransitionIndex = -1;
    this.procedureDetails.arrivalIndex = -1;
    this.procedureDetails.arrivalRunwayTransitionIndex = -1;
    this.procedureDetails.arrivalRunway = undefined;
    this.procedureDetails.arrivalTransitionIndex = -1;
    this.procedureDetails.destinationRunway = undefined;

    notify && this.events.onOriginDestChanged
      && this.events.onOriginDestChanged(OriginDestChangeType.DestinationRemoved, facilityIcao, this.getBatchStack());
  }

  /**
   * Sets the active lateral leg index in the flight plan.
   * @param globalLegIndex The global leg index to set.
   * @param notify Whether or not to send notifications after the operation.
   */
  public setLateralLeg(globalLegIndex: number, notify = true): void {
    let previousLegIndex = -1;
    let previousSegmentIndex = -1;
    let segmentIndex = -1;
    let segmentLegIndex = -1;

    if (this.length > 0) {
      previousSegmentIndex = this.getSegmentIndex(this._activeLateralLeg);
      if (previousSegmentIndex > -1) {
        previousLegIndex = this._activeLateralLeg - this.getSegment(previousSegmentIndex).offset;
      }
      this._activeLateralLeg = Utils.Clamp(globalLegIndex, 0, this.length - 1);
      segmentIndex = this.getSegmentIndex(this._activeLateralLeg);
      if (segmentIndex > -1) {
        segmentLegIndex = this._activeLateralLeg - this.getSegment(segmentIndex).offset;
      }
    } else {
      this._activeLateralLeg = 0;
    }

    notify
      && this.events.onActiveLegChanged
      && this.events.onActiveLegChanged(
        this._activeLateralLeg,
        segmentIndex, segmentLegIndex,
        previousSegmentIndex, previousLegIndex,
        ActiveLegType.Lateral,
        this.getBatchStack()
      );
  }

  /**
   * Sets the active lateral leg index in the flight plan.
   * @param globalLegIndex The global leg index to set.
   * @param notify Whether or not to send notifications after the operation.
   */
  public setVerticalLeg(globalLegIndex: number, notify = true): void {
    let previousLegIndex = -1;
    let previousSegmentIndex = -1;
    let segmentIndex = -1;
    let segmentLegIndex = -1;

    if (this.length > 0) {
      previousSegmentIndex = this.getSegmentIndex(this._activeVerticalLeg);
      if (previousSegmentIndex > -1) {
        previousLegIndex = this._activeVerticalLeg - this.getSegment(previousSegmentIndex).offset;
      }
      this._activeVerticalLeg = Utils.Clamp(globalLegIndex, 0, this.length - 1);
      segmentIndex = this.getSegmentIndex(this._activeVerticalLeg);
      if (segmentIndex > -1) {
        segmentLegIndex = this._activeVerticalLeg - this.getSegment(segmentIndex).offset;
      }
    } else {
      this._activeVerticalLeg = 0;
    }

    notify
      && this.events.onActiveLegChanged
      && this.events.onActiveLegChanged(
        this._activeVerticalLeg,
        segmentIndex, segmentLegIndex,
        previousSegmentIndex, previousLegIndex,
        ActiveLegType.Vertical,
        this.getBatchStack()
      );
  }

  /**
   * Sets the active calculating leg index in the flight plan.
   * @param globalLegIndex The global leg index to set.
   * @param notify Whether or not to send notifications after the operation.
   */
  public setCalculatingLeg(globalLegIndex: number, notify = true): void {
    let previousLegIndex = -1;
    let previousSegmentIndex = -1;
    let segmentIndex = -1;
    let segmentLegIndex = -1;

    if (this.length > 0) {
      previousSegmentIndex = this.getSegmentIndex(this._activeCalculatingLeg);
      if (previousSegmentIndex > -1) {
        previousLegIndex = this._activeCalculatingLeg - this.getSegment(previousSegmentIndex).offset;
      }
      this._activeCalculatingLeg = Utils.Clamp(globalLegIndex, 0, this.length - 1);
      segmentIndex = this.getSegmentIndex(this._activeCalculatingLeg);
      if (segmentIndex > -1) {
        segmentLegIndex = this._activeCalculatingLeg - this.getSegment(segmentIndex).offset;
      }
    } else {
      this._activeCalculatingLeg = 0;
    }

    notify
      && this.events.onActiveLegChanged
      && this.events.onActiveLegChanged(
        this._activeCalculatingLeg,
        segmentIndex, segmentLegIndex,
        previousSegmentIndex, previousLegIndex,
        ActiveLegType.Calculating,
        this.getBatchStack()
      );
  }

  /**
   * Sets this flight plan's procedure details.
   * @param details An object containing the procedure details properties to set. Properties omitted from the object
   * (i.e. that are not enumerable) will not be set. Properties that are present in the object (including those whose
   * values are equal to `undefined`) will set the corresponding properties in the flight plan procedure details with
   * the same values.
   * @param notify Whether to notify subscribers of the change. Defaults to `true`.
   */
  public setProcedureDetails(details: Partial<Readonly<ProcedureDetails>>, notify = true): void {
    // Temporary fix to ensure the various ICAO struct properties are always in sync with the ICAO string properties.
    // TODO: Remove this when the deprecated ICAO string properties are removed.

    const modifiedDetails: Partial<ProcedureDetails> = Object.assign({}, details);

    this.reconcileProcedureDetailsIcaoPropPair(modifiedDetails, 'departureFacilityIcaoStruct', 'departureFacilityIcao');
    this.reconcileProcedureDetailsIcaoPropPair(modifiedDetails, 'arrivalFacilityIcaoStruct', 'arrivalFacilityIcao');
    this.reconcileProcedureDetailsIcaoPropPair(modifiedDetails, 'approachFacilityIcaoStruct', 'approachFacilityIcao');

    // We iterate of the keys of `details` because we need to be able to set fields to undefined
    // and we only want to overwrite fields that were in the `details` object
    for (const key of Object.keys(modifiedDetails)) {
      (this.procedureDetails as any)[key] = modifiedDetails[key as keyof ProcedureDetails];
    }

    notify && this.events.onProcedureDetailsChanged && this.events.onProcedureDetailsChanged(this.procedureDetails, this.getBatchStack());
  }

  /**
   * Reconciles a pair of associated ICAO properties in a `ProcedureDetails` object. If one of the pair is defined but
   * the other is not, then the undefined property will be added to the object with a value derived from its defined
   * partner. If both of the pair are defined but have incompatible values, then the string (V1) property will be
   * redefined to be compatible with the struct property. Otherwise, the object will remain unchanged.
   * @param details The object containing the properties to reconcile.
   * @param icaoStructProp The name of the ICAO struct property to reconcile.
   * @param icaoStringProp The name of the ICAO string (V1) property to reconcile.
   */
  private reconcileProcedureDetailsIcaoPropPair(
    details: Partial<ProcedureDetails>,
    icaoStructProp: keyof Pick<ProcedureDetails, 'departureFacilityIcaoStruct' | 'arrivalFacilityIcaoStruct' | 'approachFacilityIcaoStruct'>,
    icaoStringProp: keyof Pick<ProcedureDetails, 'departureFacilityIcao' | 'arrivalFacilityIcao' | 'approachFacilityIcao'>,
  ): void {
    const isStructPropDefined = icaoStructProp in details;
    const isStringPropDefined = icaoStringProp in details;

    if (isStructPropDefined && !isStringPropDefined) {
      // Struct prop is defined but string prop is not -> need to set string prop from struct prop
      details[icaoStringProp] = details[icaoStructProp]
        ? ICAO.tryValueToStringV1(details[icaoStructProp]!)
        : undefined;
    } else if (!isStructPropDefined && isStringPropDefined) {
      // String prop is defined but struct prop is not -> need to set struct prop from string prop
      details[icaoStructProp] = details[icaoStringProp] !== undefined
        ? ICAO.stringV1ToValue(details[icaoStringProp]!)
        : undefined;
    } else if (isStructPropDefined && isStringPropDefined) {
      const structProp = details[icaoStructProp];
      const stringProp = details[icaoStringProp];

      if (
        (structProp !== undefined && stringProp === undefined)
        || (structProp === undefined && stringProp !== undefined)
        || (structProp !== undefined && stringProp !== undefined && ICAO.valueToStringV1(structProp) !== stringProp)
      ) {
        // Both struct and string props are defined but their values are incompatible -> need to set string prop from struct prop
        details[icaoStringProp] = structProp
          ? ICAO.tryValueToStringV1(structProp)
          : undefined;
      }
    }
  }

  /**
   * Sets the direct to data for this plan.
   * @param globalLegIndex The global leg index of the direct to target, or -1 if the direct to data is to be cleared.
   * @param notify Whether to send an event for this change. Defaults to true.
   */
  public setDirectToData(globalLegIndex: number, notify?: boolean): void;
  /**
   * Sets the direct to data for this plan.
   * @param segmentIndex The segment index of the direct to target, or -1 if the direct to data is to be cleared.
   * @param segmentLegIndex The segment leg index of the direct to target, or -1 if the direct to data is to be
   * cleared.
   * @param notify Whether to send an event for this change. Defaults to true.
   */
  public setDirectToData(segmentIndex: number, segmentLegIndex: number, notify?: boolean): void;
  /**
   * Sets the direct to data for this plan.
   * @param leg The target leg of the direct to, or null if the direct to data is to be cleared.
   * @param notify Whether to send an event for this change. Defaults to true.
   */
  public setDirectToData(leg: LegDefinition | null, notify?: boolean): void;
  // eslint-disable-next-line jsdoc/require-jsdoc
  public setDirectToData(arg1: number | LegDefinition | null, arg2?: number | boolean, arg3?: boolean): void {
    if (typeof arg1 !== 'number') {
      // arg1 is a LegDefinition or null.
      arg1 = arg1 ? this.getLegIndexFromLeg(arg1) : -1;
    }

    let segmentIndex = -1;
    let segmentLegIndex = -1;
    let notify = true;
    if (typeof arg2 !== 'number') {
      const globalLegIndex = arg1;
      if (globalLegIndex >= 0) {
        segmentIndex = this.getSegmentIndex(globalLegIndex);
        if (segmentIndex >= 0) {
          segmentLegIndex = globalLegIndex - this.getSegment(segmentIndex).offset;
        }
      }
      notify = arg2 ?? true;
    } else {
      segmentIndex = arg1;
      segmentLegIndex = arg2;
      notify = arg3 ?? true;
    }

    this.directToData.segmentIndex = segmentIndex;
    this.directToData.segmentLegIndex = segmentLegIndex;

    notify && this.events.onDirectDataChanged && this.events.onDirectDataChanged(this.directToData, this.getBatchStack());
  }

  /**
   * Sets the vertical data for a flight plan leg.
   * @param segmentIndex The segment index of the leg for which to set vertical data.
   * @param segmentLegIndex The segment leg index of the leg for which to set vertical data.
   * @param verticalData The vertical data to set. The values of the enumerable properties of this object will be
   * copied to the flight plan leg. Any vertical data property that is not enumerated in this object will be left as-is
   * in the flight plan leg.
   * @param notify Whether to send an event for this change. Defaults to true.
   */
  public setLegVerticalData(segmentIndex: number, segmentLegIndex: number, verticalData: Partial<VerticalData>, notify?: boolean): void;
  /**
   * Sets the vertical data for a flight plan leg.
   * @param globalLegIndex The global leg index in the plan for the leg for which to set vertical data.
   * @param verticalData The vertical data to set. The values of the enumerable properties of this object will be
   * copied to the flight plan leg. Any vertical data property that is not enumerated in this object will be left as-is
   * in the flight plan leg.
   * @param notify Whether to send an event for this change. Defaults to true.
   */
  public setLegVerticalData(globalLegIndex: number, verticalData: Partial<VerticalData>, notify?: boolean): void;
  // eslint-disable-next-line jsdoc/require-jsdoc
  public setLegVerticalData(arg1: number, arg2: number | Partial<VerticalData>, arg3?: boolean | Partial<VerticalData>, arg4?: boolean): void {
    let notify = true;
    let segmentIndex = -1;
    let segmentLegIndex = -1;
    let verticalData: Partial<VerticalData> | undefined;

    if (typeof arg2 !== 'number') {
      segmentIndex = this.getSegmentIndex(arg1);
      const segment = this.getSegment(segmentIndex);
      segmentLegIndex = arg1 - segment.offset;
      verticalData = arg2 as Partial<VerticalData>;
      notify = arg3 !== undefined ? arg3 as boolean : notify;
    } else {
      segmentIndex = arg1;
      segmentLegIndex = arg2;
      verticalData = arg3 as Partial<VerticalData>;
      notify = arg4 !== undefined ? arg4 : notify;
    }

    const leg = this.tryGetLeg(segmentIndex, segmentLegIndex);
    if (leg) {
      Object.assign(leg.verticalData, verticalData);
      notify && this.events.onLegChanged && this.events.onLegChanged(segmentIndex, segmentLegIndex, LegEventType.Changed, leg, this.getBatchStack());
    } else {
      console.warn(`Failed to set Leg Vertical Data for Segment ${segmentIndex} Leg ${segmentLegIndex}.`);
    }
  }

  /**
   * Sets the airway for a segment.
   * @param segmentIndex A segment index.
   * @param airway The airway name.
   * @param notify is whether to send an event for this change
   */
  public setAirway(segmentIndex: number, airway?: string, notify = true): void {
    const segment = this.getSegment(segmentIndex);
    if (!airway) {
      segment.airway = undefined;
    } else {
      segment.airway = airway;
    }
    this.events.onSegmentChanged && notify && this.events.onSegmentChanged(segmentIndex, SegmentEventType.Changed, segment, this.getBatchStack());
  }

  /**
   * Sets a global key-value user data pair for this flight plan. Setting a key's user data to `undefined` will delete
   * the key instead.
   * @param key The key of the user data.
   * @param data The data to set.
   * @param notify Whether or not to notify subscribers. Defaults to true.
   */
  public setUserData<T>(key: string, data: T, notify = true): void {
    if (data === undefined) {
      this.deleteUserData(key, notify);
      return;
    }

    this.userData[key] = data;
    this.events.onUserDataSet && notify && this.events.onUserDataSet(key, data, this.getBatchStack());
  }

  /**
   * Deletes a global key-value user data pair for this flight plan.
   * @param key The key to delete.
   * @param notify Whether or not to notify subscribers.
   */
  public deleteUserData(key: string, notify = true): void {
    if (this.userData[key] !== undefined) {
      delete this.userData[key];
    }
    this.events.onUserDataDelete && notify && this.events.onUserDataDelete(key, this.getBatchStack());
  }

  /**
   * Sets a key-value user data pair for a flight plan leg. Setting a key's user data to `undefined` will delete the
   * key instead.
   * @param segmentIndex The index of the segment containing the flight plan leg for which to set the user data.
   * @param segmentLegIndex The index of the flight plan leg for which to set the user data in its containing segment.
   * @param key The key under which to set the user data.
   * @param data The user data to set under the key.
   * @param notify Whether to send an event for this change. Defaults to true.
   */
  public setLegUserData<T>(segmentIndex: number, segmentLegIndex: number, key: string, data: T, notify?: boolean): void;
  /**
   * Sets a key-value user data pair for a flight plan leg. Setting a key's user data to `undefined` will delete the
   * key instead.
   * @param globalLegIndex The global index of the flight plan leg for which to set the user data.
   * @param key The key under which to set the user data.
   * @param data The user data to set under the key.
   * @param notify Whether to send an event for this change. Defaults to true.
   */
  public setLegUserData<T>(globalLegIndex: number, key: string, data: T, notify?: boolean): void;
  // eslint-disable-next-line jsdoc/require-jsdoc
  public setLegUserData(arg1: number, arg2: number | string, arg3?: any, arg4?: any, arg5?: boolean): void {
    let notify: boolean;
    let segmentIndex = -1;
    let segmentLegIndex = -1;
    let key: string;
    let data: any;

    if (typeof arg2 !== 'number') {
      segmentIndex = this.getSegmentIndex(arg1);
      const segment = this.getSegment(segmentIndex);
      segmentLegIndex = arg1 - segment.offset;
      key = arg2 as string;
      data = arg3;
      notify = arg4 === undefined ? true : arg4 as boolean;
    } else {
      segmentIndex = arg1;
      segmentLegIndex = arg2;
      key = arg3 as string;
      data = arg4;
      notify = arg5 === undefined ? true : arg5;
    }

    if (data === undefined) {
      this.deleteLegUserData(segmentIndex, segmentLegIndex, key, notify);
      return;
    }

    const leg = this.tryGetLeg(segmentIndex, segmentLegIndex);
    if (leg) {
      leg.userData[key] = data;
      notify && this.events.onLegUserDataSet && this.events.onLegUserDataSet(segmentIndex, segmentLegIndex, leg, key, data, this.getBatchStack());
    } else {
      console.warn(`FlightPlan: failed to set leg user data; leg does not exist at segment index ${segmentIndex}, segment leg index ${segmentLegIndex}.`);
    }
  }

  /**
   * Deletes a key-value user data pair for a flight plan leg.
   * @param segmentIndex The index of the segment containing the flight plan leg for which to delete the user data.
   * @param segmentLegIndex The index of the flight plan leg for which to delete the user data in its containing
   * segment.
   * @param key The key to delete.
   * @param notify Whether to send an event for this change. Defaults to true.
   */
  public deleteLegUserData(segmentIndex: number, segmentLegIndex: number, key: string, notify?: boolean): void;
  /**
   * Deletes a key-value user data pair for a flight plan leg.
   * @param globalLegIndex The global index of the flight plan leg for which to delete the user data.
   * @param key The key to delete.
   * @param notify Whether to send an event for this change. Defaults to true.
   */
  public deleteLegUserData(globalLegIndex: number, key: string, notify?: boolean): void;
  // eslint-disable-next-line jsdoc/require-jsdoc
  public deleteLegUserData(arg1: number, arg2: number | string, arg3?: string | boolean, arg4?: boolean): void {
    let notify: boolean;
    let segmentIndex = -1;
    let segmentLegIndex = -1;
    let key: string;

    if (typeof arg2 !== 'number') {
      segmentIndex = this.getSegmentIndex(arg1);
      const segment = this.getSegment(segmentIndex);
      segmentLegIndex = arg1 - segment.offset;
      key = arg2 as string;
      notify = arg3 === undefined ? true : arg3 as boolean;
    } else {
      segmentIndex = arg1;
      segmentLegIndex = arg2;
      key = arg3 as string;
      notify = arg4 === undefined ? true : arg4;
    }

    const leg = this.tryGetLeg(segmentIndex, segmentLegIndex);
    if (leg) {
      delete leg.userData[key];
      notify && this.events.onLegUserDataDelete && this.events.onLegUserDataDelete(segmentIndex, segmentLegIndex, leg, key, this.getBatchStack());
    } else {
      console.warn(`FlightPlan: failed to delete leg user data; leg does not exist at segment index ${segmentIndex}, segment leg index ${segmentLegIndex}.`);
    }
  }

  /**
   * Sets the origin runway in procedure details.
   * @param runway The oneway runway to set as the origin, or undefined
   * @param notify Whether or not to notify subscribers.
   */
  public setOriginRunway(runway: OneWayRunway | undefined = undefined, notify = true): void {
    this.procedureDetails.originRunway = runway;
    const details = Object.assign(FlightPlan.createProcedureDetails(), this.procedureDetails);

    this.events.onProcedureDetailsChanged && notify && this.events.onProcedureDetailsChanged(details, this.getBatchStack());
  }

  /**
   * Sets the destination runway in procedure details.
   * @param runway The oneway runway to set as the destination, or undefined
   * @param notify Whether or not to notify subscribers.
   */
  public setDestinationRunway(runway: OneWayRunway | undefined = undefined, notify = true): void {
    this.procedureDetails.destinationRunway = runway;
    const details = Object.assign(FlightPlan.createProcedureDetails(), this.procedureDetails);

    this.events.onProcedureDetailsChanged && notify && this.events.onProcedureDetailsChanged(details, this.getBatchStack());
  }

  /**
   * Sets the departure procedure details.
   * @param facilityIcao The ICAO value of the facility containing the procedure. Defaults to `undefined`.
   * @param departureIndex The index of the departure procedure in the departure airport facility's departures array.
   * Defaults to `-1`.
   * @param departureTransitionIndex The index of the departure enroute transition in the departure procedure's enroute
   * transitions array. Defaults to `-1`.
   * @param departureRunwayIndex The index of the departure runway transition in the departure procedure's runway
   * transitions array. Defaults to `-1`.
   * @param notify Whether to notify subscribers of the change. Defaults to `true`.
   */
  public setDeparture(facilityIcao?: IcaoValue, departureIndex?: number, departureTransitionIndex?: number, departureRunwayIndex?: number, notify?: boolean): void;
  /**
   * Sets the departure procedure details.
   * @param facilityIcao The ICAO string (V1) of the facility containing the procedure. Defaults to `undefined`.
   * @param departureIndex The index of the departure procedure in the departure airport facility's departures array.
   * Defaults to `-1`.
   * @param departureTransitionIndex The index of the departure enroute transition in the departure procedure's enroute
   * transitions array. Defaults to `-1`.
   * @param departureRunwayIndex The index of the departure runway transition in the departure procedure's runway
   * transitions array. Defaults to `-1`.
   * @param notify Whether to notify subscribers of the change. Defaults to `true`.
   * @deprecated Please use the signature that takes an `IcaoValue` for the `facilityIcao` parameter.
   */
  public setDeparture(facilityIcao?: string, departureIndex?: number, departureTransitionIndex?: number, departureRunwayIndex?: number, notify?: boolean): void;
  // eslint-disable-next-line jsdoc/require-jsdoc
  public setDeparture(facilityIcao?: IcaoValue | string, departureIndex = -1, departureTransitionIndex = -1, departureRunwayIndex = -1, notify = true): void {
    this.procedureDetails.departureIndex = departureIndex;
    if (facilityIcao === undefined) {
      this.procedureDetails.departureFacilityIcaoStruct = undefined;
      this.procedureDetails.departureFacilityIcao = undefined;
    } else if (typeof facilityIcao === 'object') {
      this.procedureDetails.departureFacilityIcaoStruct = facilityIcao;
      this.procedureDetails.departureFacilityIcao = ICAO.valueToStringV1(facilityIcao);
    } else {
      this.procedureDetails.departureFacilityIcaoStruct = ICAO.stringV1ToValue(facilityIcao);
      this.procedureDetails.departureFacilityIcao = facilityIcao;
    }
    this.procedureDetails.departureTransitionIndex = departureTransitionIndex;
    this.procedureDetails.departureRunwayIndex = departureRunwayIndex;
    const details = Object.assign(FlightPlan.createProcedureDetails(), this.procedureDetails);

    this.events.onProcedureDetailsChanged && notify && this.events.onProcedureDetailsChanged(details, this.getBatchStack());
  }

  /**
   * Sets the arrival procedure details.
   * @param facilityIcao The ICAO value of the facility containing the procedure. Defaults to `undefined`.
   * @param arrivalIndex The index of the arrival procedure in the arrival airport facility's arrivals array.
   * Defaults to `-1`.
   * @param arrivalTransitionIndex The index of the arrival enroute transition in the arrival procedure's enroute
   * transitions array. Defaults to `-1`.
   * @param arrivalRunwayTransitionIndex The index of the arrival runway transition in the arrival procedure's runway
   * transitions array. Defaults to `-1`.
   * @param arrivalRunway The arrival procedure runway. Defaults to `undefined.
   * @param notify Whether to notify subscribers of the change. Defaults to `true`.
   */
  public setArrival(
    facilityIcao?: IcaoValue,
    arrivalIndex?: number,
    arrivalTransitionIndex?: number,
    arrivalRunwayTransitionIndex?: number,
    arrivalRunway?: OneWayRunway,
    notify?: boolean,
  ): void;
  /**
   * Sets the arrival procedure details.
   * @param facilityIcao The ICAO string (V1) of the facility containing the procedure. Defaults to `undefined`.
   * @param arrivalIndex The index of the arrival procedure in the arrival airport facility's arrivals array.
   * Defaults to `-1`.
   * @param arrivalTransitionIndex The index of the arrival enroute transition in the arrival procedure's enroute
   * transitions array. Defaults to `-1`.
   * @param arrivalRunwayTransitionIndex The index of the arrival runway transition in the arrival procedure's runway
   * transitions array. Defaults to `-1`.
   * @param arrivalRunway The arrival procedure runway. Defaults to `undefined.
   * @param notify Whether to notify subscribers of the change. Defaults to `true`.
   * @deprecated Please use the signature that takes an `IcaoValue` for the `facilityIcao` parameter.
   */
  public setArrival(
    facilityIcao?: string,
    arrivalIndex?: number,
    arrivalTransitionIndex?: number,
    arrivalRunwayTransitionIndex?: number,
    arrivalRunway?: OneWayRunway,
    notify?: boolean,
  ): void;
  // eslint-disable-next-line jsdoc/require-jsdoc
  public setArrival(
    facilityIcao?: IcaoValue | string,
    arrivalIndex = -1,
    arrivalTransitionIndex = -1,
    arrivalRunwayTransitionIndex = -1,
    arrivalRunway?: OneWayRunway,
    notify = true,
  ): void {
    this.procedureDetails.arrivalIndex = arrivalIndex;
    if (facilityIcao === undefined) {
      this.procedureDetails.arrivalFacilityIcaoStruct = undefined;
      this.procedureDetails.arrivalFacilityIcao = undefined;
    } else if (typeof facilityIcao === 'object') {
      this.procedureDetails.arrivalFacilityIcaoStruct = facilityIcao;
      this.procedureDetails.arrivalFacilityIcao = ICAO.valueToStringV1(facilityIcao);
    } else {
      this.procedureDetails.arrivalFacilityIcaoStruct = ICAO.stringV1ToValue(facilityIcao);
      this.procedureDetails.arrivalFacilityIcao = facilityIcao;
    }
    this.procedureDetails.arrivalTransitionIndex = arrivalTransitionIndex;
    this.procedureDetails.arrivalRunwayTransitionIndex = arrivalRunwayTransitionIndex;
    this.procedureDetails.arrivalRunway = arrivalRunway;
    const details = Object.assign(FlightPlan.createProcedureDetails(), this.procedureDetails);

    this.events.onProcedureDetailsChanged && notify && this.events.onProcedureDetailsChanged(details, this.getBatchStack());
  }

  /**
   * Sets the approach procedure details.
   * @param facilityIcao The ICAO value of the facility containing the procedure. Defaults to `undefined`.
   * @param approachIndex The index of the approach procedure in the approach airport facility's approaches array.
   * Defaults to `-1`.
   * @param approachTransitionIndex The index of the approach transition in the approach procedure's transitions array.
   * Defaults to `-1`.
   * @param notify Whether to notify subscribers of the change. Defaults to `true`.
   * @deprecated Please use the signature that takes an `IcaoValue` for the `facilityIcao` parameter.
   */
  public setApproach(facilityIcao?: IcaoValue, approachIndex?: number, approachTransitionIndex?: number, notify?: boolean): void;
  /**
   * Sets the approach procedure details.
   * @param facilityIcao The ICAO string (V1) of the facility containing the procedure. Defaults to `undefined`.
   * @param approachIndex The index of the approach procedure in the approach airport facility's approaches array.
   * Defaults to `-1`.
   * @param approachTransitionIndex The index of the approach transition in the approach procedure's transitions array.
   * Defaults to `-1`.
   * @param notify Whether to notify subscribers of the change. Defaults to `true`.
   * @deprecated Please use the signature that takes an `IcaoValue` for the `facilityIcao` parameter.
   */
  public setApproach(facilityIcao?: string, approachIndex?: number, approachTransitionIndex?: number, notify?: boolean): void;
  // eslint-disable-next-line jsdoc/require-jsdoc
  public setApproach(facilityIcao?: IcaoValue | string, approachIndex = -1, approachTransitionIndex = -1, notify = true): void {
    this.procedureDetails.approachIndex = approachIndex;
    if (facilityIcao === undefined) {
      this.procedureDetails.approachFacilityIcaoStruct = undefined;
      this.procedureDetails.approachFacilityIcao = undefined;
    } else if (typeof facilityIcao === 'object') {
      this.procedureDetails.approachFacilityIcaoStruct = facilityIcao;
      this.procedureDetails.approachFacilityIcao = ICAO.valueToStringV1(facilityIcao);
    } else {
      this.procedureDetails.approachFacilityIcaoStruct = ICAO.stringV1ToValue(facilityIcao);
      this.procedureDetails.approachFacilityIcao = facilityIcao;
    }
    this.procedureDetails.approachIndex = approachIndex;
    this.procedureDetails.approachTransitionIndex = approachTransitionIndex;
    const details = Object.assign(FlightPlan.createProcedureDetails(), this.procedureDetails);

    this.events.onProcedureDetailsChanged && notify && this.events.onProcedureDetailsChanged(details, this.getBatchStack());
  }

  /**
   * Calculates the flight path for the plan.
   * @param globalLegIndex The global leg index to start calculating from.
   * @param notify Whether or not to send notifications after the operation.
   */
  public async calculate(globalLegIndex?: number, notify = true): Promise<void> {
    const batchStack = this.getBatchStack();
    const batchEntry = this.batchEntryStack[this.batchEntryStack.length - 1] as FlightPlanModBatchEntry | undefined;

    let currentBatchEntry = batchEntry;
    while (currentBatchEntry) {
      currentBatchEntry.pendingCalculateCount++;
      currentBatchEntry = currentBatchEntry.parent;
    }

    notify && this.events.onCalculatePended && this.events.onCalculatePended(globalLegIndex, batchStack);

    const legs = [...this.legs()];
    try {
      await this.calculator.calculateFlightPath(legs, this.activeLateralLeg, globalLegIndex === undefined ? this.activeCalculatingLeg : globalLegIndex);
    } catch (e) {
      console.error(e);
      if (e instanceof Error) {
        console.error(e.stack);
      }
    }

    notify && this.events.onCalculated && this.events.onCalculated(globalLegIndex, batchStack);

    currentBatchEntry = batchEntry;
    while (currentBatchEntry) {
      currentBatchEntry.pendingCalculateCount--;
      if (currentBatchEntry.isClosed && currentBatchEntry.pendingCalculateCount === 0) {
        this.events.onBatchAsyncClosed && this.events.onBatchAsyncClosed(currentBatchEntry.batch);
      }
      currentBatchEntry = currentBatchEntry.parent;
    }
  }

  /**
   * Copies the flight plan.
   * @param planIndex The flight plan index to assign to this plan, or the same plan
   * index if not provided.
   * @param copyCalcs Whether to copy leg calculations (defaults to false).
   * @returns The copied flight plan.
   */
  public copy(planIndex?: number, copyCalcs = false): FlightPlan {
    if (planIndex === undefined) {
      planIndex = this.planIndex;
    }
    const newPlan = new FlightPlan(planIndex, this.calculator, this.onLegNameRequested);

    newPlan.copyFrom(this, copyCalcs);

    return newPlan;
  }

  /**
   * Copies a source flight plan into this one, overriding everything in this plan with everything from the source plan.
   * @param sourcePlan The plan to copy from.
   * @param copyCalcs Whether to copy leg calculations (defaults to false).
   */
  public copyFrom(sourcePlan: FlightPlan, copyCalcs = false): void {

    if (sourcePlan._originAirportIcao !== undefined) {
      this.setOriginAirport(sourcePlan._originAirportIcao, false);
    } else {
      this.removeOriginAirport(false);
    }

    if (sourcePlan._destinationAirportIcao !== undefined) {
      this.setDestinationAirport(sourcePlan._destinationAirportIcao, false);
    } else {
      this.removeDestinationAirport(false);
    }

    // We do object assign against new proc details in case the incoming details are missing fields because of coming from json
    // and because we want to overwrite the entire object, instead of just some fields.
    this.setProcedureDetails(Object.assign(FlightPlan.createProcedureDetails(), sourcePlan.procedureDetails), false);

    const targetPlanSegmentsCount = this.planSegments.length;
    for (let i = 0; i < targetPlanSegmentsCount; i++) {
      this.removeSegment(0, false);
    }

    for (let i = 0; i < sourcePlan.planSegments.length; i++) {
      const segment = sourcePlan.planSegments[i];

      if (segment !== undefined) {
        this.addSegment(segment.segmentIndex, segment.segmentType, segment.airway, false);
        for (const leg of segment.legs) {
          const newLeg = this.addLeg(segment.segmentIndex, leg.leg, undefined, leg.flags, false);
          const legIndex = this.getLegIndexFromLeg(newLeg);
          this.setLegVerticalData(legIndex, leg.verticalData, false);

          for (const key in leg.userData) {
            this.setLegUserData(legIndex, key, leg.userData[key], false);
          }

          copyCalcs && FlightPlan.copyLegCalculations(leg, newLeg);
        }
      }
    }

    this.setDirectToData(sourcePlan.directToData.segmentIndex, sourcePlan.directToData.segmentLegIndex, false);

    // Have to copy from the private fields, because the public ones are getters, which would be lost when stringified
    this.setLateralLeg(sourcePlan._activeLateralLeg, false);
    this.setVerticalLeg(sourcePlan._activeVerticalLeg, false);
    this.setCalculatingLeg(sourcePlan._activeCalculatingLeg, false);

    for (const key in this.userData) {
      this.deleteUserData(key, false);
    }

    for (const key in sourcePlan.userData) {
      this.setUserData(key, sourcePlan.userData[key], false);
    }
  }

  /**
   * Copies leg calcs from an existing leg to a new leg.
   * @param existingLeg The leg that we want to copy the calcs from.
   * @param newLeg The leg that we want to copy the calcs to.
   * @returns the newLeg with the copied calcs.
   */
  private static copyLegCalculations(existingLeg: LegDefinition, newLeg: LegDefinition): LegDefinition {
    if (existingLeg.calculated !== undefined) {
      newLeg.calculated = {
        courseMagVar: existingLeg.calculated.courseMagVar,
        initialDtk: existingLeg.calculated.initialDtk,
        distance: existingLeg.calculated.distance,
        cumulativeDistance: existingLeg.calculated.cumulativeDistance,
        distanceWithTransitions: existingLeg.calculated.distanceWithTransitions,
        cumulativeDistanceWithTransitions: existingLeg.calculated.cumulativeDistanceWithTransitions,
        startLat: existingLeg.calculated.startLat,
        startLon: existingLeg.calculated.startLon,
        endLat: existingLeg.calculated.endLat,
        endLon: existingLeg.calculated.endLon,
        flightPath: existingLeg.calculated.flightPath.map(vector => Object.assign({}, vector)),
        ingress: existingLeg.calculated.ingress.map(vector => Object.assign({}, vector)),
        ingressJoinIndex: existingLeg.calculated.ingressJoinIndex,
        ingressToEgress: existingLeg.calculated.ingressToEgress.map(vector => Object.assign({}, vector)),
        egressJoinIndex: existingLeg.calculated.egressJoinIndex,
        egress: existingLeg.calculated.egress.map(vector => Object.assign({}, vector)),
        endsInDiscontinuity: existingLeg.calculated.endsInDiscontinuity,
        endsInFallback: existingLeg.calculated.endsInFallback
      };
    }
    return newLeg;
  }

  /**
   * Creates a new flight plan leg.
   * @param partial The properties to initialize on the new leg. Any undefined properties will be initialized to
   * default values. For ICAO property pairs - struct and string (V1) - only one of each pair needs to be defined; the
   * other property in the pair will be set from the property that is defined. If paired ICAO properties are not
   * consistent with each other, then the struct property will take precedence.
   * @returns A new flight plan leg.
   */
  public static createLeg(partial: Partial<FlightPlanLeg>): FlightPlanLeg {
    partial = Object.assign({}, partial);

    FlightPlan.reconcileFlightPlanLegIcaoPropPair(partial, 'fixIcaoStruct', 'fixIcao');
    FlightPlan.reconcileFlightPlanLegIcaoPropPair(partial, 'originIcaoStruct', 'originIcao');
    FlightPlan.reconcileFlightPlanLegIcaoPropPair(partial, 'arcCenterFixIcaoStruct', 'arcCenterFixIcao');

    return {
      type: partial.type ?? LegType.Unknown,
      fixIcao: partial.fixIcao ?? ICAO.EMPTY_V1,
      fixIcaoStruct: partial.fixIcaoStruct ?? ICAO.emptyValue(),
      arcCenterFixIcao: partial.arcCenterFixIcao ?? ICAO.EMPTY_V1,
      arcCenterFixIcaoStruct: partial.arcCenterFixIcaoStruct ?? ICAO.emptyValue(),
      originIcao: partial.originIcao ?? ICAO.EMPTY_V1,
      originIcaoStruct: partial.originIcaoStruct ?? ICAO.emptyValue(),
      flyOver: partial.flyOver ?? false,
      turnDirection: partial.turnDirection ?? LegTurnDirection.None,
      trueDegrees: partial.trueDegrees ?? false,
      theta: partial.theta ?? 0,
      rho: partial.rho ?? 0,
      distance: partial.distance ?? 0,
      distanceMinutes: partial.distanceMinutes ?? false,
      speedRestriction: partial.speedRestriction ?? 0,
      speedRestrictionDesc: partial.speedRestrictionDesc ?? SpeedRestrictionType.Unused,
      altDesc: partial.altDesc ?? AltitudeRestrictionType.Unused,
      altitude1: partial.altitude1 ?? 0,
      altitude2: partial.altitude2 ?? 0,
      course: partial.course ?? 0,
      fixTypeFlags: partial.fixTypeFlags ?? 0,
      verticalAngle: partial.verticalAngle ?? 0,
      rnp: partial.rnp ?? 0,
      lat: partial.lat,
      lon: partial.lon,
    };
  }

  /**
   * Reconciles a pair of associated ICAO properties in a partial `FlightPlanLeg` object. If one of the pair is defined
   * but the other is not, then the undefined property will be added to the object with a value derived from its
   * defined partner. If both of the pair are defined but have incompatible values, then the string (V1) property will
   * be redefined to be compatible with the struct property. Otherwise, the object will remain unchanged.
   * @param leg The object containing the properties to reconcile.
   * @param icaoStructProp The name of the ICAO struct property to reconcile.
   * @param icaoStringProp The name of the ICAO string (V1) property to reconcile.
   */
  private static reconcileFlightPlanLegIcaoPropPair(
    leg: Partial<FlightPlanLeg>,
    icaoStructProp: keyof Pick<FlightPlanLeg, 'fixIcaoStruct' | 'originIcaoStruct' | 'arcCenterFixIcaoStruct'>,
    icaoStringProp: keyof Pick<FlightPlanLeg, 'fixIcao' | 'originIcao' | 'arcCenterFixIcao'>,
  ): void {
    const isStructPropDefined = leg[icaoStructProp] !== undefined;
    const isStringPropDefined = leg[icaoStringProp] !== undefined;

    if (isStructPropDefined && !isStringPropDefined) {
      // Struct prop is defined but string prop is not -> need to set string prop from struct prop
      leg[icaoStringProp] = ICAO.tryValueToStringV1(leg[icaoStructProp]!);
    } else if (!isStructPropDefined && isStringPropDefined) {
      // String prop is defined but struct prop is not -> need to set struct prop from string prop
      leg[icaoStructProp] = ICAO.stringV1ToValue(leg[icaoStringProp]!);
    } else if (isStructPropDefined && isStringPropDefined) {
      const structString = ICAO.tryValueToStringV1(leg[icaoStructProp]!);
      if (structString !== leg[icaoStringProp]) {
        // Both struct and string props are defined but their values are incompatible -> need to set string prop from struct prop
        leg[icaoStringProp] = structString;
      }
    }
  }

  /**
   * Creates an empty procedure details object.
   * @returns An empty procedure details object.
   */
  public static createProcedureDetails(): ProcedureDetails {
    return {
      originRunway: undefined,
      departureFacilityIcaoStruct: undefined,
      departureFacilityIcao: undefined,
      departureIndex: -1,
      departureTransitionIndex: -1,
      departureRunwayIndex: -1,
      arrivalFacilityIcaoStruct: undefined,
      arrivalFacilityIcao: undefined,
      arrivalIndex: -1,
      arrivalTransitionIndex: -1,
      arrivalRunwayTransitionIndex: -1,
      arrivalRunway: undefined,
      approachFacilityIcaoStruct: undefined,
      approachFacilityIcao: undefined,
      approachIndex: -1,
      approachTransitionIndex: -1,
      destinationRunway: undefined,
    };
  }
}
