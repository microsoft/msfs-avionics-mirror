"use strict";(self.webpackChunkdocs_api=self.webpackChunkdocs_api||[]).push([["746632"],{177521:function(e,n,t){t.r(n),t.d(n,{metadata:()=>o,contentTitle:()=>d,default:()=>h,assets:()=>c,toc:()=>l,frontMatter:()=>i});var o=JSON.parse('{"id":"getting-started/refs-and-component-lifecycle","title":"Refs and the Component Lifecycle","description":"Calling Components and Elements Directly","source":"@site/docs/getting-started/refs-and-component-lifecycle.md","sourceDirName":"getting-started","slug":"/getting-started/refs-and-component-lifecycle","permalink":"/msfs-avionics-mirror/2024/docs/getting-started/refs-and-component-lifecycle","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":7,"frontMatter":{"sidebar_position":7},"sidebar":"sidebar","previous":{"title":"Using the Event Bus","permalink":"/msfs-avionics-mirror/2024/docs/getting-started/using-the-event-bus"},"next":{"title":"SimVars","permalink":"/msfs-avionics-mirror/2024/docs/interacting-with-msfs/simvars"}}'),r=t("785893"),s=t("250065");let i={sidebar_position:7},d="Refs and the Component Lifecycle",c={},l=[{value:"Calling Components and Elements Directly",id:"calling-components-and-elements-directly",level:2},{value:"Lifecycle Methods Available on DisplayComponent",id:"lifecycle-methods-available-on-displaycomponent",level:2},{value:"<code>constructor()</code>",id:"constructor",level:3},{value:"<code>onBeforeRender()</code>",id:"onbeforerender",level:3},{value:"<code>onAfterRender()</code>",id:"onafterrender",level:3},{value:"Adding Dynamic Styling to a Component With Ref and Lifecyle Methods",id:"adding-dynamic-styling-to-a-component-with-ref-and-lifecyle-methods",level:2}];function a(e){let n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",strong:"strong",...(0,s.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"refs-and-the-component-lifecycle",children:"Refs and the Component Lifecycle"})}),"\n",(0,r.jsx)(n.h2,{id:"calling-components-and-elements-directly",children:"Calling Components and Elements Directly"}),"\n",(0,r.jsxs)(n.p,{children:["Many times, one needs to directly call the methods of a component or HTML element. This can be accomplished by using the special ",(0,r.jsx)(n.code,{children:"ref"})," prop which exists on all components and elements, and works in much the same way as React refs do."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"const elementRef = FSComponent.createRef<HTMLDivElement>();\r\nconst element = <div ref={elementRef}>Texty Goodness</div>;\r\n\r\nFSComponent.render(element, document.getElementById('TextyContainer'));\r\nelementRef.instance.classList.add('blink-red');\n"})}),"\n",(0,r.jsxs)(n.p,{children:["By using the special ",(0,r.jsx)(n.code,{children:"ref"})," prop, the element or component will be assigned to the ",(0,r.jsx)(n.code,{children:"instance"})," property of that passed-in ref after (",(0,r.jsx)(n.strong,{children:"and only after"}),") the element is rendered."]}),"\n",(0,r.jsx)(n.admonition,{type:"warning",children:(0,r.jsxs)(n.p,{children:["A component or element's ",(0,r.jsx)(n.code,{children:"ref"})," will ",(0,r.jsx)(n.strong,{children:"not"})," be assigned until the element is rendered. If the ",(0,r.jsx)(n.code,{children:"instance"})," property is accessed before it has been assigned, an error will be thrown. You can instead use ",(0,r.jsx)(n.code,{children:"getOrDefault()"})," if you would like to get either the instance or ",(0,r.jsx)(n.code,{children:"undefined"}),". This method will not throw an error, and is therefore a good choice in areas where you don't know if rendering will yet be complete and would like to check on your own."]})}),"\n",(0,r.jsx)(n.h2,{id:"lifecycle-methods-available-on-displaycomponent",children:"Lifecycle Methods Available on DisplayComponent"}),"\n",(0,r.jsx)(n.p,{children:"Also like React, FSComponent components have a few lifecycle methods which can be used to run code at specific times in the rendering cycle of a component."}),"\n",(0,r.jsx)(n.h3,{id:"constructor",children:(0,r.jsx)(n.code,{children:"constructor()"})}),"\n",(0,r.jsx)(n.p,{children:"In FSComponent, component constructors are called as soon as the JSX elements are created, prior to starting the render cycle. Components are created from the bottom of the tree up."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"constructor(props: TextyComponentProps) {\r\n  super(props);\r\n\r\n  console.log('Getting constructed...');\r\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"onbeforerender",children:(0,r.jsx)(n.code,{children:"onBeforeRender()"})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"onBeforeRender()"})," method is called on a component immediately before the component's ",(0,r.jsx)(n.code,{children:"render()"})," method is called. This can be good for code that doesn't really fit into a normal constructor but needs to run before the component's rendering starts."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"public onBeforeRender(): void {\r\n  super.onBeforeRender();\r\n\r\n  console.log('Just before rendering.');\r\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"onafterrender",children:(0,r.jsx)(n.code,{children:"onAfterRender()"})}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"onAfterRender()"})," method is called on a component when the entire tree underneath it and its own ",(0,r.jsx)(n.code,{children:"render()"})," method have finished. Any code called from here, and after, is guaranteed to have access to any component or element refs, since they will all have been rendered. This method also has access to the virtual DOM node that resulted from its rendering, which is useful for a number of virtual DOM inspection purposes."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"public onAfterRender(node: VNode): void {\r\n  super.onAfterRender(node);\r\n\r\n  console.log(`I have ${node.children.length} children.`);\r\n}\n"})}),"\n",(0,r.jsx)(n.admonition,{type:"info",children:(0,r.jsxs)(n.p,{children:["It is good practice to call ",(0,r.jsx)(n.code,{children:"super"})," within the two lifecycle methods, just as one would for a constructor."]})}),"\n",(0,r.jsx)(n.h2,{id:"adding-dynamic-styling-to-a-component-with-ref-and-lifecyle-methods",children:"Adding Dynamic Styling to a Component With Ref and Lifecyle Methods"}),"\n",(0,r.jsx)(n.p,{children:"One of the most common ways of using both of these concepts in the framework is to change the styling of an element in a component dynamically due to changes in incoming data."}),"\n",(0,r.jsxs)(n.p,{children:["In ",(0,r.jsx)(n.code,{children:"MyComponent"}),", add a field for a ref to the display div to the top of the class:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"private readonly elementRef = FSComponent.createRef<HTMLDivElement>();\n"})}),"\n",(0,r.jsxs)(n.p,{children:["And hook it up to the display div by adding the ref prop to that element in the ",(0,r.jsx)(n.code,{children:"render()"})," method:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"<div ref={this.elementRef} class='my-component'>{this.indicatedAirspeed} IAS</div>\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Then, subscribe to the ",(0,r.jsx)(n.code,{children:"indicatedAirspeed"})," value and use the following code to toggle a class on or off by adding the following to the lifecycle method ",(0,r.jsx)(n.code,{children:"onAfterRender()"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"public onAfterRender(node: VNode): void {\r\n  super.onAfterRender(node);\r\n\r\n  this.indicatedAirspeed.sub(airspeed => {\r\n    if (airspeed > 40) {\r\n      this.elementRef.instance.classList.add('alert');\r\n    } else {\r\n      this.elementRef.instance.classList.remove('alert');\r\n    }\r\n  });\r\n}\n"})}),"\n",(0,r.jsx)(n.admonition,{type:"info",children:(0,r.jsxs)(n.p,{children:["We use the lifecycle method ",(0,r.jsx)(n.code,{children:"onAfterRender()"})," here because we are accessing a ref instance, which is guaranteed to be available when and after ",(0,r.jsx)(n.code,{children:"onAfterRender()"})," is called."]})}),"\n",(0,r.jsxs)(n.p,{children:["Finally, we can add some styling to this ",(0,r.jsx)(n.code,{children:"alert"})," class in our ",(0,r.jsx)(n.code,{children:"MyComponent.css"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-css",children:".alert {\r\n  color: white;\r\n  background-color: red;\r\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Upon rebuild/resync, we should now see the styling of our airspeed value change when it is above 40 knots."})]})}function h(e={}){let{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(a,{...e})}):a(e)}},250065:function(e,n,t){t.d(n,{Z:function(){return d},a:function(){return i}});var o=t(667294);let r={},s=o.createContext(r);function i(e){let n=o.useContext(s);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),o.createElement(s.Provider,{value:n},e.children)}}}]);