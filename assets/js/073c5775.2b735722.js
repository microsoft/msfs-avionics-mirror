"use strict";(self.webpackChunkdocs_api=self.webpackChunkdocs_api||[]).push([[42184],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>m});var a=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),p=c(n),h=i,m=p["".concat(l,".").concat(h)]||p[h]||d[h]||r;return n?a.createElement(m,o(o({ref:t},u),{},{components:n})):a.createElement(m,o({ref:t},u))}));function m(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[p]="string"==typeof e?e:i,o[1]=s;for(var c=2;c<r;c++)o[c]=n[c];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},49915:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>r,metadata:()=>s,toc:()=>c});var a=n(87462),i=(n(67294),n(3905));const r={sidebar_position:6},o="Using the Event Bus",s={unversionedId:"getting-started/using-the-event-bus",id:"getting-started/using-the-event-bus",title:"Using the Event Bus",description:"What is the Event Bus?",source:"@site/docs/getting-started/using-the-event-bus.md",sourceDirName:"getting-started",slug:"/getting-started/using-the-event-bus",permalink:"/msfs-avionics-mirror/docs/getting-started/using-the-event-bus",draft:!1,tags:[],version:"current",sidebarPosition:6,frontMatter:{sidebar_position:6},sidebar:"sidebar",previous:{title:"Dealing With Dynamic Data",permalink:"/msfs-avionics-mirror/docs/getting-started/dealing-with-dynamic-data"},next:{title:"Refs and the Component Lifecycle",permalink:"/msfs-avionics-mirror/docs/getting-started/refs-and-component-lifecycle"}},l={},c=[{value:"What is the Event Bus?",id:"what-is-the-event-bus",level:2},{value:"EventBus Subscriber Filters",id:"eventbus-subscriber-filters",level:2},{value:"whenChanged()",id:"whenchanged",level:3},{value:"whenChangedBy()",id:"whenchangedby",level:3},{value:"onlyAfter()",id:"onlyafter",level:3},{value:"atFrequency()",id:"atfrequency",level:3},{value:"withPrecision()",id:"withprecision",level:3},{value:"Publishing SimVar Data Via the Event Bus",id:"publishing-simvar-data-via-the-event-bus",level:2},{value:"Wiring the EventBus Consumer to the Component",id:"wiring-the-eventbus-consumer-to-the-component",level:3},{value:"Setting Up the Event Bus in the Instrument",id:"setting-up-the-event-bus-in-the-instrument",level:3},{value:"Sometimes Too Much Precision is Too Much",id:"sometimes-too-much-precision-is-too-much",level:3}],u={toc:c},p="wrapper";function d(e){let{components:t,...n}=e;return(0,i.kt)(p,(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"using-the-event-bus"},"Using the Event Bus"),(0,i.kt)("h2",{id:"what-is-the-event-bus"},"What is the Event Bus?"),(0,i.kt)("p",null,"Subscribable values are an excellent way to get data from parent components down to child components, but what about data that may be more instrument-wide or cut across components in your instrument? For that, there's ",(0,i.kt)("inlineCode",{parentName:"p"},"EventBus"),"."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"EventBus")," allows you to define typesafe publishers and consumers that broadcast events with corresponding data on given topics. Each topic is a string key that consumers can subscribe to, and will have their subscribed callbacks called when a publisher publishes data on the topic key. Simply define an interface, and the fields of that interface become the keys, and the value types the data types."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"interface HelloWorldEvents {\n  new_text: string;\n}\n\nconst bus = new EventBus();\nconst publisher = bus.getPublisher<HelloWorldEvents>();\nconst subscriber = bus.getSubscriber<HelloWorldEvents>();\n\nsubscriber.on('new_text').handle(text => console.log(text));\npublisher.pub('new_text', 'Hello, EventBus!'); //Logs 'Hello, EventBus!'\n")),(0,i.kt)("h2",{id:"eventbus-subscriber-filters"},"EventBus Subscriber Filters"),(0,i.kt)("p",null,"The avionics framework helpfully provides a number of built-in filtering options to help reduce the frequency of subscriptions being called on topic data updates."),(0,i.kt)("h3",{id:"whenchanged"},"whenChanged()"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"//Only call the consumer when the value is different than prior, not on every topic publish\nsubscriber.on('distance_to_go')\n  .whenChanged()\n  .handle(distance => console.log(`Distance to go: ${distance} NM`));\n")),(0,i.kt)("h3",{id:"whenchangedby"},"whenChangedBy()"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"//Only call the consumer when the value is different than prior by at least the specified amount\nsubscriber.on('distance_to_go')\n  .whenChangedBy(0.1)\n  .handle(distance => console.log(`Distance to go: ${distance} NM`));\n")),(0,i.kt)("h3",{id:"onlyafter"},"onlyAfter()"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"//Supress consuming events until a minimum time in milliseconds has elapsed since the previous event\nsubscriber.on('distance_to_go')\n  .onlyAfter(1000)\n  .handle(distance => console.log(`Distance to go: ${distance} NM`));\n")),(0,i.kt)("h3",{id:"atfrequency"},"atFrequency()"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"//Only consume events at a specified frequency in Hz\nsubscriber.on('distance_to_go')\n  .atFrequency(4)\n  .handle(distance => console.log(`Distance to go: ${distance} NM`));\n")),(0,i.kt)("h3",{id:"withprecision"},"withPrecision()"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"//Only consume events when the numeric value rounded to the number of provided decimal places\n//has changed since the previous rounded value. Accepts negative values for 10, 100s, etc.\nsubscriber.on('distance_to_go')\n  .withPrecision(1)\n  .handle(distance => console.log(`Distance to go: ${distance} NM`));\n")),(0,i.kt)("h2",{id:"publishing-simvar-data-via-the-event-bus"},"Publishing SimVar Data Via the Event Bus"),(0,i.kt)("p",null,"Publishing SimVar data across ",(0,i.kt)("inlineCode",{parentName:"p"},"EventBus")," is an ideal application, as getting SimVar data requires a call into the Coherent GT framework and a serialization round trip from the sim, which is a (relatively) slow operation. Instead of peppering code with a number of local SimVar calls, we can use ",(0,i.kt)("inlineCode",{parentName:"p"},"EventBus")," to get a SimVar just once and then push that data to all consumers who are subscribed, keeping performance at a maximum."),(0,i.kt)("h3",{id:"wiring-the-eventbus-consumer-to-the-component"},"Wiring the EventBus Consumer to the Component"),(0,i.kt)("p",null,"Let's make a few modifications to our ",(0,i.kt)("inlineCode",{parentName:"p"},"MyComponent")," component. First, let's change the props interface and also add an interface for our events:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"interface MyComponentProps extends ComponentProps {\n  bus: EventBus;\n}\n\nexport interface SpeedEvents {\n  indicated_airspeed: number;\n}\n")),(0,i.kt)("p",null,"Then, we can use some tools at our disposal to subscribe to the bus and create a subscribable value from the consumer. First, add a private field to the class:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"private readonly indicatedAirspeed: Subscribable<number>;\n")),(0,i.kt)("p",null,"Then, we can create a constructor to subscribe to the bus and pipe to a subscribable value:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"constructor(props: MyComponentProps) {\n  super(props);\n\n  const subscriber = props.bus.getSubscriber<SpeedEvents>();\n  const consumer = subscriber.on('indicated_airspeed');\n\n  this.indicatedAirspeed = ConsumerSubject.create(consumer, 0);\n}\n")),(0,i.kt)("admonition",{type:"caution"},(0,i.kt)("p",{parentName:"admonition"},"Just as in React, constructors must call ",(0,i.kt)("inlineCode",{parentName:"p"},"super(props)"),", and should do so as the first line in the constructor.")),(0,i.kt)("p",null,"Finally, we can reference our new subscribable value in our render method:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"public render(): VNode {\n  return (\n    <div class='my-component'>{this.indicatedAirspeed} IAS</div>\n  );\n}\n")),(0,i.kt)("h3",{id:"setting-up-the-event-bus-in-the-instrument"},"Setting Up the Event Bus in the Instrument"),(0,i.kt)("p",null,"In ",(0,i.kt)("inlineCode",{parentName:"p"},"MyInstrument"),", we now need to create an instance of ",(0,i.kt)("inlineCode",{parentName:"p"},"EventBus")," so we can pass it as a prop to ",(0,i.kt)("inlineCode",{parentName:"p"},"MyComponent"),". Create the following field in the class:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"private readonly eventBus = new EventBus();\n")),(0,i.kt)("p",null,"Then we can pass it as a prop to our component:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"public connectedCallback(): void {\n  super.connectedCallback();\n\n  FSComponent.render(<MyComponent bus={this.eventBus} />, document.getElementById('InstrumentContent'));\n}\n")),(0,i.kt)("admonition",{type:"caution"},(0,i.kt)("p",{parentName:"admonition"},"You should generally only instantiate a ",(0,i.kt)("strong",{parentName:"p"},"single instance")," of ",(0,i.kt)("inlineCode",{parentName:"p"},"EventBus")," within your instrument, and pass it to components as necessary. Different instances of the event bus will not automatically share topic publications, and any topics published to on one bus will not be published to on another.")),(0,i.kt)("p",null,"In order to publish this SimVar data to the bus, we are going to want to get that data each simulation frame. Thankfully, the VCockpit system gives us a hook to do just that. Simply make a method on your instrument called ",(0,i.kt)("inlineCode",{parentName:"p"},"Update()"),", and give it the following code to read our indicated airspeed and publish it on the bus:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"public Update(): void {\n  const indicatedAirspeed = SimVar.GetSimVarValue('AIRSPEED INDICATED', 'knots');\n  this.eventBus.getPublisher<SpeedEvents>().pub('indicated_airspeed', indicatedAirspeed);\n}\n")),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},(0,i.kt)("inlineCode",{parentName:"p"},"SimVar")," is another item that comes from the underlying MSFS SDK.  You will need to pull in a reference from ",(0,i.kt)("inlineCode",{parentName:"p"},"msfs-types")," for the compiler to know where to find it.  Add the following line to the top of your file to accomplish this:"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre"},'/// <reference types="@microsoft/msfs-types/JS/SimVar" />\n'))),(0,i.kt)("p",null,'After you rebuild/resync, you will note that now your "Hello World" text has been replaced by an indicated airspeed value that updates every frame.'),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"Manually writing code to publish data from multiple SimVars to the bus can get tedious. ",(0,i.kt)("a",{parentName:"p",href:"/msfs-avionics-mirror/docs/interacting-with-msfs/simvars#bridging-simvars-to-the-event-bus"},"This section")," of the documentation will walk you through how to leverage framework-provided classes to abstract away much of the boilerplate.")),(0,i.kt)("h3",{id:"sometimes-too-much-precision-is-too-much"},"Sometimes Too Much Precision is Too Much"),(0,i.kt)("p",null,"After reloading, you may notice that the precision of your airspeed value is quite high. In fact, probably too high to be of any use in a display. Additionally, each time this value is re-rendered, it alters the DOM slightly and causes a repaint of the affected area, which is something we would like to avoid."),(0,i.kt)("p",null,"However, this can easily be addressed by simply adding a filter to the bus event consumer in ",(0,i.kt)("inlineCode",{parentName:"p"},"MyComponent"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"const consumer = subscriber.on('indicated_airspeed').withPrecision(0);\n")),(0,i.kt)("p",null,"Now you will find that your airspeed values will be nice, round, whole numbers, and will only re-render and repaint when that whole number value changes."))}d.isMDXComponent=!0}}]);