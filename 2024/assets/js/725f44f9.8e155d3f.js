"use strict";(self.webpackChunkdocs_api=self.webpackChunkdocs_api||[]).push([["650972"],{888178:function(e,n,r){r.r(n),r.d(n,{metadata:()=>i,contentTitle:()=>c,default:()=>h,assets:()=>d,toc:()=>o,frontMatter:()=>a});var i=JSON.parse('{"id":"api/framework/classes/DmsFormatter2","title":"Class: DmsFormatter2","description":"A utility class for creating degree-minute-second formatters for angle values.","source":"@site/docs/api/framework/classes/DmsFormatter2.md","sourceDirName":"api/framework/classes","slug":"/api/framework/classes/DmsFormatter2","permalink":"/msfs-avionics-mirror/2024/docs/api/framework/classes/DmsFormatter2","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"sidebar","previous":{"title":"DmsFormatter","permalink":"/msfs-avionics-mirror/2024/docs/api/framework/classes/DmsFormatter"},"next":{"title":"DurationDisplay","permalink":"/msfs-avionics-mirror/2024/docs/api/framework/classes/DurationDisplay"}}'),s=r("785893"),t=r("250065");let a={},c="Class: DmsFormatter2",d={},o=[{value:"Examples",id:"examples",level:2},{value:"Constructors",id:"constructors",level:2},{value:"new DmsFormatter2()",id:"new-dmsformatter2",level:3},{value:"Returns",id:"returns",level:4},{value:"Properties",id:"properties",level:2},{value:"DEFAULT_OPTIONS",id:"default_options",level:3},{value:"Defined in",id:"defined-in",level:4},{value:"Methods",id:"methods",level:2},{value:"create()",id:"create",level:3},{value:"create(format, unit, precision, nanString)",id:"createformat-unit-precision-nanstring",level:4},{value:"Parameters",id:"parameters",level:5},{value:"Returns",id:"returns-1",level:5},{value:"Parameters",id:"parameters-1",level:6},{value:"Returns",id:"returns-2",level:6},{value:"Defined in",id:"defined-in-1",level:5},{value:"create(format, unit, precision, options)",id:"createformat-unit-precision-options",level:4},{value:"Parameters",id:"parameters-2",level:5},{value:"Returns",id:"returns-3",level:5},{value:"Parameters",id:"parameters-3",level:6},{value:"Returns",id:"returns-4",level:6},{value:"Defined in",id:"defined-in-2",level:5},{value:"createForNumberUnit()",id:"createfornumberunit",level:3},{value:"createForNumberUnit(format, precision, nanString)",id:"createfornumberunitformat-precision-nanstring",level:4},{value:"Parameters",id:"parameters-4",level:5},{value:"Returns",id:"returns-5",level:5},{value:"Parameters",id:"parameters-5",level:6},{value:"Returns",id:"returns-6",level:6},{value:"Defined in",id:"defined-in-3",level:5},{value:"createForNumberUnit(format, precision, options)",id:"createfornumberunitformat-precision-options",level:4},{value:"Parameters",id:"parameters-6",level:5},{value:"Returns",id:"returns-7",level:5},{value:"Parameters",id:"parameters-7",level:6},{value:"Returns",id:"returns-8",level:6},{value:"Defined in",id:"defined-in-4",level:5}];function l(e){let n={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",h5:"h5",h6:"h6",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"class-dmsformatter2",children:"Class: DmsFormatter2"})}),"\n",(0,s.jsx)(n.p,{children:"A utility class for creating degree-minute-second formatters for angle values."}),"\n",(0,s.jsx)(n.p,{children:"Each DMS formatter is a function which generates output strings from input angle values. The formatting behavior\nof a formatter is defined by its format template."}),"\n",(0,s.jsxs)(n.p,{children:["Format templates are strings which contain zero or more fragments enclosed by curly braces (",(0,s.jsx)(n.code,{children:"{}"}),"); For a given\nformat template, an output string is generated from an input duration by replacing each fragment in the template\nwith a string generated from the input. The parts of the template string that are not contained in any fragment are\npassed to the output unchanged. Each fragment defines how its replacement string is generated. There are two types\nof fragments:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["Sign fragment. In EBNF notation, these take the form ",(0,s.jsx)(n.code,{children:"['+', ['[', x, ']']], ('-' , ['[', y, ']'])"}),", where\n",(0,s.jsx)(n.code,{children:"x"})," and ",(0,s.jsx)(n.code,{children:"y"})," are arbitrary strings. Each sign fragment is replaced with a string representing the sign of the input.\nThe negative sign string is defined by ",(0,s.jsx)(n.code,{children:"y"}),". If ",(0,s.jsx)(n.code,{children:"y"})," is not defined, the negative sign string defaults to ",(0,s.jsx)(n.code,{children:"'-'"}),"\n(dash). The positive sign string is defined by ",(0,s.jsx)(n.code,{children:"x"}),". If the positive sign token does not appear in the fragment\ndefinition, the positive sign string defaults to ",(0,s.jsx)(n.code,{children:"''"})," (the empty string), otherwise it defaults to ",(0,s.jsx)(n.code,{children:"'+'"}),"."]}),"\n",(0,s.jsxs)(n.li,{children:["Numeric fragment. In EBNF notation, these take the form ",(0,s.jsx)(n.code,{children:"{x}, ['?'], ['.', [{x}], ['(', {x}, ')']]"}),",\nwhere ",(0,s.jsx)(n.code,{children:"x = 'D' | 'M' | 'S' | 'd' | 'm' | 's'"}),". Each numeric fragment is replaced with the numeric value of the\nduration in degrees, minutes, or seconds, depending on which character is used for ",(0,s.jsx)(n.code,{children:"x"}),". With uppercase letters, the\nentire portion of the input value is used. With lowercase letters, only the portion of the input value that does not\ndivide evenly into the next smallest unit is used (for hours, which is the largest unit, there is no difference\nbetween using ",(0,s.jsx)(n.code,{children:"'H'"})," and ",(0,s.jsx)(n.code,{children:"'h'"}),").\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["The number of ",(0,s.jsx)(n.code,{children:"x"})," characters to the left of the decimal point (including all characters if no decimal point is\npresent) in the definition controls the number of leading zeroes with which the output will be padded."]}),"\n",(0,s.jsxs)(n.li,{children:["If the optional ",(0,s.jsx)(n.code,{children:"'?'"})," character is present, the output will drop all digits to the left of the decimal point if\nall such digits are equal to 0."]}),"\n",(0,s.jsxs)(n.li,{children:["The total number of ",(0,s.jsx)(n.code,{children:"x"})," characters to the right of the decimal point in the definition controls the decimal\nprecision of the output. Trailing zeroes to the right of the decimal point will be added to the output to a number\nof decimal places equal to the number of non-parenthetical ",(0,s.jsx)(n.code,{children:"x"})," characters to the right of the decimal point in the\ndefinition. If there are no ",(0,s.jsx)(n.code,{children:"x"})," characters to the right of the decimal point in the definition, then the output will\nhave infinite decimal precision with no extraneous trailing zeroes."]}),"\n",(0,s.jsx)(n.li,{children:"Rounding behavior is always round down."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"examples",children:"Examples"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const formatter = DmsFormatter2.create('{d}\xb0{mm}\\'{ss}\"', UnitType.DEGREE);\nformatter(10);         // 10\xb000'00\"\nformatter(10.51);      // 10\xb030'36\"\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const formatter = DmsFormatter2.create('{d}\xb0{mm}\\'{ss.s(s)}\"', UnitType.DEGREE);\nformatter(10);         // 10\xb000'00.0\"\nformatter(10.09169);   // 10\xb005'30.08\"\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const formatter = DmsFormatter2.create('{d}\xb0{mm.mm}\\'', UnitType.DEGREE);\nformatter(10.09169);   // 10\xb005.50'\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"const formatter = DmsFormatter2.create('{-}{d}\xb0{mm}\\'', UnitType.DEGREE);\nformatter(10);                   // 10\xb000'\nformatter(-10);                  // -10\xb000'\n\nconst formatterWithPositiveSign = DmsFormatter2.create('{+-}{d}\xb0{mm}\\'', UnitType.DEGREE);\nformatterWithPositiveSign(10);   // +10\xb000'\n\nconst formatterWithRealMinusSign = DmsFormatter2.create('{-[\u2013]}{d}\xb0{mm}\\'', UnitType.DEGREE);\nformatterWithRealMinusSign(10);  // \u201310\xb000'\n"})}),"\n",(0,s.jsx)(n.h2,{id:"constructors",children:"Constructors"}),"\n",(0,s.jsx)(n.h3,{id:"new-dmsformatter2",children:"new DmsFormatter2()"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"new DmsFormatter2"}),"(): ",(0,s.jsx)(n.a,{href:"/msfs-avionics-mirror/2024/docs/api/framework/classes/DmsFormatter2",children:(0,s.jsx)(n.code,{children:"DmsFormatter2"})})]}),"\n"]}),"\n",(0,s.jsx)(n.h4,{id:"returns",children:"Returns"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"/msfs-avionics-mirror/2024/docs/api/framework/classes/DmsFormatter2",children:(0,s.jsx)(n.code,{children:"DmsFormatter2"})})}),"\n",(0,s.jsx)(n.h2,{id:"properties",children:"Properties"}),"\n",(0,s.jsx)(n.h3,{id:"default_options",children:"DEFAULT_OPTIONS"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"readonly"})," ",(0,s.jsx)(n.code,{children:"static"})," ",(0,s.jsx)(n.strong,{children:"DEFAULT_OPTIONS"}),": ",(0,s.jsx)(n.code,{children:"Readonly"}),"<",(0,s.jsx)(n.a,{href:"/msfs-avionics-mirror/2024/docs/api/framework/type-aliases/DmsFormatter2Options",children:(0,s.jsx)(n.code,{children:"DmsFormatter2Options"})}),">"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"The default options for degree-minute-second formatters."}),"\n",(0,s.jsx)(n.h4,{id:"defined-in",children:"Defined in"}),"\n",(0,s.jsx)(n.p,{children:"src/sdk/graphics/text/DmsFormatter2.ts:89"}),"\n",(0,s.jsx)(n.h2,{id:"methods",children:"Methods"}),"\n",(0,s.jsx)(n.h3,{id:"create",children:"create()"}),"\n",(0,s.jsx)(n.h4,{id:"createformat-unit-precision-nanstring",children:"create(format, unit, precision, nanString)"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"static"})," ",(0,s.jsx)(n.strong,{children:"create"}),"(",(0,s.jsx)(n.code,{children:"format"}),", ",(0,s.jsx)(n.code,{children:"unit"}),", ",(0,s.jsx)(n.code,{children:"precision"}),", ",(0,s.jsx)(n.code,{children:"nanString"}),"?): (",(0,s.jsx)(n.code,{children:"angle"}),") => ",(0,s.jsx)(n.code,{children:"string"})]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Creates a function which formats angles, expressed as numeric values, to strings. The formatting behavior of\nthe function is defined by a specified format template. For more information on format templates and their syntax,\nplease refer to the ",(0,s.jsx)(n.a,{href:"/msfs-avionics-mirror/2024/docs/api/framework/classes/DmsFormatter2",children:"DmsFormatter2"})," class documentation. All formatter options except ",(0,s.jsx)(n.code,{children:"nanString"}),", if\nspecified, will use their default values."]}),"\n",(0,s.jsx)(n.h5,{id:"parameters",children:"Parameters"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Parameter"}),(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"format"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"string"})}),(0,s.jsx)(n.td,{children:"A template defining how the function formats angles."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"unit"})}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.a,{href:"/msfs-avionics-mirror/2024/docs/api/framework/interfaces/Unit",children:(0,s.jsx)(n.code,{children:"Unit"})}),"<",(0,s.jsx)(n.a,{href:"/msfs-avionics-mirror/2024/docs/api/framework/enumerations/UnitFamily#angle",children:(0,s.jsx)(n.code,{children:"Angle"})}),">"]}),(0,s.jsx)(n.td,{children:"The unit type in which the input angle values are expressed."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"precision"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"number"})}),(0,s.jsxs)(n.td,{children:["The precision of the formatter, in the unit type defined by the ",(0,s.jsx)(n.code,{children:"unit"})," argument. Input values will be rounded to the nearest multiple of this quantity. Precision values less than or equal to zero will be taken to mean infinite precision (i.e. no rounding will take place)."]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"nanString"}),"?"]}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"string"})}),(0,s.jsxs)(n.td,{children:["The string to output when the input angle is ",(0,s.jsx)(n.code,{children:"NaN"}),". Defaults to ",(0,s.jsx)(n.code,{children:"'NaN'"}),"."]})]})]})]}),"\n",(0,s.jsx)(n.h5,{id:"returns-1",children:"Returns"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"Function"})}),"\n",(0,s.jsx)(n.p,{children:"A function which formats angles, expressed as numeric values, to strings."}),"\n",(0,s.jsx)(n.h6,{id:"parameters-1",children:"Parameters"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Parameter"}),(0,s.jsx)(n.th,{children:"Type"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"angle"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"number"})})]})})]}),"\n",(0,s.jsx)(n.h6,{id:"returns-2",children:"Returns"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"string"})}),"\n",(0,s.jsx)(n.h5,{id:"defined-in-1",children:"Defined in"}),"\n",(0,s.jsx)(n.p,{children:"src/sdk/graphics/text/DmsFormatter2.ts:107"}),"\n",(0,s.jsx)(n.h4,{id:"createformat-unit-precision-options",children:"create(format, unit, precision, options)"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"static"})," ",(0,s.jsx)(n.strong,{children:"create"}),"(",(0,s.jsx)(n.code,{children:"format"}),", ",(0,s.jsx)(n.code,{children:"unit"}),", ",(0,s.jsx)(n.code,{children:"precision"}),", ",(0,s.jsx)(n.code,{children:"options"}),"?): (",(0,s.jsx)(n.code,{children:"angle"}),") => ",(0,s.jsx)(n.code,{children:"string"})]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Creates a function which formats angles, expressed as numeric values, to strings. The formatting behavior of\nthe function is defined by a specified format template. For more information on format templates and their syntax,\nplease refer to the ",(0,s.jsx)(n.a,{href:"/msfs-avionics-mirror/2024/docs/api/framework/classes/DmsFormatter2",children:"DmsFormatter2"})," class documentation."]}),"\n",(0,s.jsx)(n.h5,{id:"parameters-2",children:"Parameters"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Parameter"}),(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"format"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"string"})}),(0,s.jsx)(n.td,{children:"A template defining how the function formats angles."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"unit"})}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.a,{href:"/msfs-avionics-mirror/2024/docs/api/framework/interfaces/Unit",children:(0,s.jsx)(n.code,{children:"Unit"})}),"<",(0,s.jsx)(n.a,{href:"/msfs-avionics-mirror/2024/docs/api/framework/enumerations/UnitFamily#angle",children:(0,s.jsx)(n.code,{children:"Angle"})}),">"]}),(0,s.jsx)(n.td,{children:"The unit type in which the input angle values are expressed."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"precision"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"number"})}),(0,s.jsxs)(n.td,{children:["The precision of the formatter, in the unit type defined by the ",(0,s.jsx)(n.code,{children:"unit"})," argument. Input values will be rounded to the nearest multiple of this quantity. Precision values less than or equal to zero will be taken to mean infinite precision (i.e. no rounding will take place)."]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"options"}),"?"]}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"Readonly"}),"<",(0,s.jsx)(n.code,{children:"Partial"}),"<",(0,s.jsx)(n.a,{href:"/msfs-avionics-mirror/2024/docs/api/framework/type-aliases/DmsFormatter2Options",children:(0,s.jsx)(n.code,{children:"DmsFormatter2Options"})}),">>"]}),(0,s.jsxs)(n.td,{children:["Options to configure the formatter. Options not explicitly defined will be set to the following default values: * ",(0,s.jsx)(n.code,{children:"nanString = 'NaN'"})," * ",(0,s.jsx)(n.code,{children:"cache = false"})]})]})]})]}),"\n",(0,s.jsx)(n.h5,{id:"returns-3",children:"Returns"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"Function"})}),"\n",(0,s.jsx)(n.p,{children:"A function which formats angles, expressed as numeric values, to strings."}),"\n",(0,s.jsx)(n.h6,{id:"parameters-3",children:"Parameters"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Parameter"}),(0,s.jsx)(n.th,{children:"Type"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"angle"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"number"})})]})})]}),"\n",(0,s.jsx)(n.h6,{id:"returns-4",children:"Returns"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"string"})}),"\n",(0,s.jsx)(n.h5,{id:"defined-in-2",children:"Defined in"}),"\n",(0,s.jsx)(n.p,{children:"src/sdk/graphics/text/DmsFormatter2.ts:128"}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h3,{id:"createfornumberunit",children:"createForNumberUnit()"}),"\n",(0,s.jsx)(n.h4,{id:"createfornumberunitformat-precision-nanstring",children:"createForNumberUnit(format, precision, nanString)"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"static"})," ",(0,s.jsx)(n.strong,{children:"createForNumberUnit"}),"(",(0,s.jsx)(n.code,{children:"format"}),", ",(0,s.jsx)(n.code,{children:"precision"}),", ",(0,s.jsx)(n.code,{children:"nanString"}),"?): (",(0,s.jsx)(n.code,{children:"angle"}),") => ",(0,s.jsx)(n.code,{children:"string"})]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Creates a function which formats angles, expressed as ",(0,s.jsx)(n.a,{href:"/msfs-avionics-mirror/2024/docs/api/framework/interfaces/NumberUnitInterface",children:"NumberUnitInterface"})," objects, to strings. The\nformatting behavior of the function is defined by a specified format template. For more information on format\ntemplates and their syntax, please refer to the ",(0,s.jsx)(n.a,{href:"/msfs-avionics-mirror/2024/docs/api/framework/classes/DmsFormatter2",children:"DmsFormatter2"})," class documentation. All formatter options\nexcept ",(0,s.jsx)(n.code,{children:"nanString"}),", if specified, will use their default values."]}),"\n",(0,s.jsx)(n.h5,{id:"parameters-4",children:"Parameters"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Parameter"}),(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"format"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"string"})}),(0,s.jsx)(n.td,{children:"A template defining how the function formats angles."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"precision"})}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.a,{href:"/msfs-avionics-mirror/2024/docs/api/framework/interfaces/NumberUnitInterface",children:(0,s.jsx)(n.code,{children:"NumberUnitInterface"})}),"<",(0,s.jsx)(n.a,{href:"/msfs-avionics-mirror/2024/docs/api/framework/enumerations/UnitFamily#angle",children:(0,s.jsx)(n.code,{children:"Angle"})}),", ",(0,s.jsx)(n.a,{href:"/msfs-avionics-mirror/2024/docs/api/framework/interfaces/Unit",children:(0,s.jsx)(n.code,{children:"Unit"})}),"<",(0,s.jsx)(n.a,{href:"/msfs-avionics-mirror/2024/docs/api/framework/enumerations/UnitFamily#angle",children:(0,s.jsx)(n.code,{children:"Angle"})}),">>"]}),(0,s.jsx)(n.td,{children:"The precision of the formatter. Input values will be rounded to the nearest multiple of this quantity. Precision values less than or equal to zero will be taken to mean infinite precision (i.e. no rounding will take place)."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"nanString"}),"?"]}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"string"})}),(0,s.jsxs)(n.td,{children:["The string to output when the input angle is ",(0,s.jsx)(n.code,{children:"NaN"}),". Defaults to ",(0,s.jsx)(n.code,{children:"'NaN'"}),"."]})]})]})]}),"\n",(0,s.jsx)(n.h5,{id:"returns-5",children:"Returns"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"Function"})}),"\n",(0,s.jsxs)(n.p,{children:["A function which formats angles, expressed as ",(0,s.jsx)(n.a,{href:"/msfs-avionics-mirror/2024/docs/api/framework/interfaces/NumberUnitInterface",children:"NumberUnitInterface"})," objects, to strings."]}),"\n",(0,s.jsx)(n.h6,{id:"parameters-5",children:"Parameters"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Parameter"}),(0,s.jsx)(n.th,{children:"Type"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"angle"})}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.a,{href:"/msfs-avionics-mirror/2024/docs/api/framework/interfaces/NumberUnitInterface",children:(0,s.jsx)(n.code,{children:"NumberUnitInterface"})}),"<",(0,s.jsx)(n.a,{href:"/msfs-avionics-mirror/2024/docs/api/framework/enumerations/UnitFamily#angle",children:(0,s.jsx)(n.code,{children:"Angle"})}),", ",(0,s.jsx)(n.a,{href:"/msfs-avionics-mirror/2024/docs/api/framework/interfaces/Unit",children:(0,s.jsx)(n.code,{children:"Unit"})}),"<",(0,s.jsx)(n.a,{href:"/msfs-avionics-mirror/2024/docs/api/framework/enumerations/UnitFamily#angle",children:(0,s.jsx)(n.code,{children:"Angle"})}),">>"]})]})})]}),"\n",(0,s.jsx)(n.h6,{id:"returns-6",children:"Returns"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"string"})}),"\n",(0,s.jsx)(n.h5,{id:"defined-in-3",children:"Defined in"}),"\n",(0,s.jsx)(n.p,{children:"src/sdk/graphics/text/DmsFormatter2.ts:196"}),"\n",(0,s.jsx)(n.h4,{id:"createfornumberunitformat-precision-options",children:"createForNumberUnit(format, precision, options)"}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"static"})," ",(0,s.jsx)(n.strong,{children:"createForNumberUnit"}),"(",(0,s.jsx)(n.code,{children:"format"}),", ",(0,s.jsx)(n.code,{children:"precision"}),", ",(0,s.jsx)(n.code,{children:"options"}),"?): (",(0,s.jsx)(n.code,{children:"angle"}),") => ",(0,s.jsx)(n.code,{children:"string"})]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["Creates a function which formats angles, expressed as ",(0,s.jsx)(n.a,{href:"/msfs-avionics-mirror/2024/docs/api/framework/interfaces/NumberUnitInterface",children:"NumberUnitInterface"})," objects, to strings. The\nformatting behavior of the function is defined by a specified format template. For more information on format\ntemplates and their syntax, please refer to the ",(0,s.jsx)(n.a,{href:"/msfs-avionics-mirror/2024/docs/api/framework/classes/DmsFormatter2",children:"DmsFormatter2"})," class documentation."]}),"\n",(0,s.jsx)(n.h5,{id:"parameters-6",children:"Parameters"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Parameter"}),(0,s.jsx)(n.th,{children:"Type"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"format"})}),(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"string"})}),(0,s.jsx)(n.td,{children:"A template defining how the function formats angles."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"precision"})}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.a,{href:"/msfs-avionics-mirror/2024/docs/api/framework/interfaces/NumberUnitInterface",children:(0,s.jsx)(n.code,{children:"NumberUnitInterface"})}),"<",(0,s.jsx)(n.a,{href:"/msfs-avionics-mirror/2024/docs/api/framework/enumerations/UnitFamily#angle",children:(0,s.jsx)(n.code,{children:"Angle"})}),", ",(0,s.jsx)(n.a,{href:"/msfs-avionics-mirror/2024/docs/api/framework/interfaces/Unit",children:(0,s.jsx)(n.code,{children:"Unit"})}),"<",(0,s.jsx)(n.a,{href:"/msfs-avionics-mirror/2024/docs/api/framework/enumerations/UnitFamily#angle",children:(0,s.jsx)(n.code,{children:"Angle"})}),">>"]}),(0,s.jsx)(n.td,{children:"The precision of the formatter. Input values will be rounded to the nearest multiple of this quantity. Precision values less than or equal to zero will be taken to mean infinite precision (i.e. no rounding will take place)."})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"options"}),"?"]}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"Readonly"}),"<",(0,s.jsx)(n.code,{children:"Partial"}),"<",(0,s.jsx)(n.a,{href:"/msfs-avionics-mirror/2024/docs/api/framework/type-aliases/DmsFormatter2Options",children:(0,s.jsx)(n.code,{children:"DmsFormatter2Options"})}),">>"]}),(0,s.jsxs)(n.td,{children:["Options to configure the formatter. Options not explicitly defined will be set to the following default values: * ",(0,s.jsx)(n.code,{children:"nanString = 'NaN'"})," * ",(0,s.jsx)(n.code,{children:"cache = false"})]})]})]})]}),"\n",(0,s.jsx)(n.h5,{id:"returns-7",children:"Returns"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"Function"})}),"\n",(0,s.jsxs)(n.p,{children:["A function which formats angles, expressed as ",(0,s.jsx)(n.a,{href:"/msfs-avionics-mirror/2024/docs/api/framework/interfaces/NumberUnitInterface",children:"NumberUnitInterface"})," objects, to strings."]}),"\n",(0,s.jsx)(n.h6,{id:"parameters-7",children:"Parameters"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Parameter"}),(0,s.jsx)(n.th,{children:"Type"})]})}),(0,s.jsx)(n.tbody,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"angle"})}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.a,{href:"/msfs-avionics-mirror/2024/docs/api/framework/interfaces/NumberUnitInterface",children:(0,s.jsx)(n.code,{children:"NumberUnitInterface"})}),"<",(0,s.jsx)(n.a,{href:"/msfs-avionics-mirror/2024/docs/api/framework/enumerations/UnitFamily#angle",children:(0,s.jsx)(n.code,{children:"Angle"})}),", ",(0,s.jsx)(n.a,{href:"/msfs-avionics-mirror/2024/docs/api/framework/interfaces/Unit",children:(0,s.jsx)(n.code,{children:"Unit"})}),"<",(0,s.jsx)(n.a,{href:"/msfs-avionics-mirror/2024/docs/api/framework/enumerations/UnitFamily#angle",children:(0,s.jsx)(n.code,{children:"Angle"})}),">>"]})]})})]}),"\n",(0,s.jsx)(n.h6,{id:"returns-8",children:"Returns"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.code,{children:"string"})}),"\n",(0,s.jsx)(n.h5,{id:"defined-in-4",children:"Defined in"}),"\n",(0,s.jsx)(n.p,{children:"src/sdk/graphics/text/DmsFormatter2.ts:215"})]})}function h(e={}){let{wrapper:n}={...(0,t.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},250065:function(e,n,r){r.d(n,{Z:function(){return c},a:function(){return a}});var i=r(667294);let s={},t=i.createContext(s);function a(e){let n=i.useContext(t);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);