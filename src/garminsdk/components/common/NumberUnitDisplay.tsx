import {
  AbstractNumberUnitDisplay, AbstractNumberUnitDisplayProps, FSComponent, NumberUnitInterface, Subject, SubscribableSet,
  ToggleableClassNameRecord, Unit, VNode
} from '@microsoft/msfs-sdk';

import { UnitFormatter } from '../../graphics/text/UnitFormatter';

/**
 * Component props for NumberUnitDisplay.
 */
export interface NumberUnitDisplayProps<F extends string> extends AbstractNumberUnitDisplayProps<F> {
  /** A function which formats numbers. */
  formatter: (number: number) => string;

  /**
   * A function which formats units. The formatted unit text should be written to the 2-tuple passed to the `out`
   * parameter, as `[bigText, smallText]`. `bigText` and `smallText` will be rendered into separate `<span>` elements
   * representing the big and small components of the rendered unit text, respectively. If not defined, then units
   * will be formatted based on the text generated by the {@link UnitFormatter} class.
   */
  unitFormatter?: (out: [string, string], unit: Unit<F>, number: number) => void;

  /** Whether to hide the unit text when the displayed value is equal to `NaN`. Defaults to `false`. */
  hideUnitWhenNaN?: boolean;

  /** CSS class(es) to add to the root of the icon component. */
  class?: string | SubscribableSet<string> | ToggleableClassNameRecord;
}

/**
 * A component which displays a number with units.
 */
export class NumberUnitDisplay<F extends string> extends AbstractNumberUnitDisplay<F, NumberUnitDisplayProps<F>> {

  // We create our own map instead of using UnitFormatter.create() so that we don't have to generate new big and small
  // text substrings with every call to the default unit formatter function.
  private static readonly DEFAULT_UNIT_TEXT_MAP = NumberUnitDisplay.createDefaultUnitTextMap();

  /**
   * A function which formats units to default text for NumberUnitDisplay.
   * @param out The 2-tuple to which to write the formatted text, as `[bigText, smallText]`.
   * @param unit The unit to format.
   */
  public static readonly DEFAULT_UNIT_FORMATTER = (out: [string, string], unit: Unit<any>): void => {
    const text = NumberUnitDisplay.DEFAULT_UNIT_TEXT_MAP[unit.family]?.[unit.name];

    if (text) {
      out[0] = text[0];
      out[1] = text[1];
    }
  };

  private static readonly unitTextCache: [string, string] = ['', ''];

  private readonly unitFormatter = this.props.unitFormatter ?? NumberUnitDisplay.DEFAULT_UNIT_FORMATTER;

  private readonly unitTextBigDisplay = Subject.create('');
  private readonly unitTextSmallDisplay = Subject.create('');

  private readonly numberText = Subject.create('');
  private readonly unitTextBig = Subject.create('');
  private readonly unitTextSmall = Subject.create('');

  /** @inheritdoc */
  protected onValueChanged(value: NumberUnitInterface<F>): void {
    this.updateDisplay(value, this.displayUnit.get());
  }

  /** @inheritdoc */
  protected onDisplayUnitChanged(displayUnit: Unit<F> | null): void {
    this.updateDisplay(this.value.get(), displayUnit);
  }

  /**
   * Updates this component's displayed number and unit text.
   * @param value The value to display.
   * @param displayUnit The unit type in which to display the value, or `null` if the value should be displayed in its
   * native unit type.
   */
  private updateDisplay(value: NumberUnitInterface<F>, displayUnit: Unit<F> | null): void {
    if (!displayUnit || !value.unit.canConvert(displayUnit)) {
      displayUnit = value.unit;
    }

    const numberValue = value.asUnit(displayUnit);

    const numberText = this.props.formatter(numberValue);
    this.numberText.set(numberText);

    NumberUnitDisplay.unitTextCache[0] = '';
    NumberUnitDisplay.unitTextCache[1] = '';

    this.unitFormatter(NumberUnitDisplay.unitTextCache, displayUnit, numberValue);
    this.unitTextBig.set(NumberUnitDisplay.unitTextCache[0]);
    this.unitTextSmall.set(NumberUnitDisplay.unitTextCache[1]);

    this.updateUnitTextVisibility(numberValue, NumberUnitDisplay.unitTextCache[0], NumberUnitDisplay.unitTextCache[1]);
  }

  /**
   * Updates whether this component's unit text spans are visible.
   * @param numberValue The numeric value displayed by this component.
   * @param unitTextBig The text to display in the big text span.
   * @param unitTextSmall The text to display in the small text span.
   */
  private updateUnitTextVisibility(numberValue: number, unitTextBig: string, unitTextSmall: string): void {
    if (this.props.hideUnitWhenNaN === true && isNaN(numberValue)) {
      this.unitTextBigDisplay.set('none');
      this.unitTextSmallDisplay.set('none');
      return;
    }

    // We have to hide the unit text when empty because an empty string will get rendered as a space.
    this.unitTextBigDisplay.set(unitTextBig === '' ? 'none' : '');
    this.unitTextSmallDisplay.set(unitTextSmall === '' ? 'none' : '');
  }

  /** @inheritdoc */
  public render(): VNode {
    return (
      <div class={this.props.class ?? ''} style='white-space: nowrap;'>
        <span class='numberunit-num'>{this.numberText}</span>
        <span class='numberunit-unit-big' style={{ 'display': this.unitTextBigDisplay }}>{this.unitTextBig}</span>
        <span class='numberunit-unit-small' style={{ 'display': this.unitTextSmallDisplay }}>{this.unitTextSmall}</span>
      </div>
    );
  }

  /**
   * Creates the default mapping from unit to displayed text.
   * @returns The default mapping from unit to displayed text.
   */
  private static createDefaultUnitTextMap(): Partial<Record<string, Partial<Record<string, [string, string]>>>> {
    const originalMap = UnitFormatter.getUnitTextMap();

    const map = {} as Record<string, Record<string, [string, string]>>;
    for (const family in originalMap) {
      const nameMap = map[family] = {} as Record<string, [string, string]>;

      const originalNameMap = originalMap[family] as Readonly<Partial<Record<string, string>>>;
      for (const name in originalNameMap) {
        const text = nameMap[name] = ['', ''];

        const originalText = originalNameMap[name] as string;

        if (originalText[0] === '°') {
          text[0] = '°';
          text[1] = originalText.substring(1);
        } else {
          text[1] = originalText;
        }
      }
    }

    return map;
  }
}