"use strict";(self.webpackChunkdocs_api=self.webpackChunkdocs_api||[]).push([["723118"],{222547:function(e,n,t){t.r(n),t.d(n,{metadata:()=>a,contentTitle:()=>o,default:()=>h,assets:()=>l,toc:()=>c,frontMatter:()=>s});var a=JSON.parse('{"id":"avionics/g3xtouch/external-navigators","title":"G3X Touch External Navigators","description":"Introduction","source":"@site/docs/avionics/g3xtouch/external-navigators.md","sourceDirName":"avionics/g3xtouch","slug":"/avionics/g3xtouch/external-navigators","permalink":"/msfs-avionics-mirror/2024/docs/avionics/g3xtouch/external-navigators","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":11,"frontMatter":{"sidebar_label":"External Navigators","sidebar_position":11},"sidebar":"sidebar","previous":{"title":"CAS","permalink":"/msfs-avionics-mirror/2024/docs/avionics/g3xtouch/cas"},"next":{"title":"H Event List","permalink":"/msfs-avionics-mirror/2024/docs/avionics/g3xtouch/h-event-list"}}'),r=t("785893"),i=t("250065");let s={sidebar_label:"External Navigators",sidebar_position:11},o="G3X Touch External Navigators",l={},c=[{value:"Introduction",id:"introduction",level:2},{value:"Configuring the G3X Touch to work with External Navigators",id:"configuring-the-g3x-touch-to-work-with-external-navigators",level:2},{value:"NAV Radio Configuration",id:"nav-radio-configuration",level:3},{value:"FMS Configuration",id:"fms-configuration",level:3},{value:"External Flight Plan Source Configuration",id:"external-flight-plan-source-configuration",level:3},{value:"Example",id:"example",level:3},{value:"Configuring External Navigators to work with the G3X Touch",id:"configuring-external-navigators-to-work-with-the-g3x-touch",level:2},{value:"CDI Source",id:"cdi-source",level:3},{value:"Flight Planning",id:"flight-planning",level:3},{value:"LNAV",id:"lnav",level:3},{value:"VNAV",id:"vnav",level:3},{value:"Glidepath",id:"glidepath",level:3},{value:"FMS",id:"fms",level:3},{value:"Autopilot Guidance",id:"autopilot-guidance",level:3},{value:"CDI Auto-Switch Guidance",id:"cdi-auto-switch-guidance",level:3},{value:"Availability",id:"availability",level:3}];function d(e){let n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"g3x-touch-external-navigators",children:"G3X Touch External Navigators"})}),"\n",(0,r.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,r.jsxs)(n.p,{children:["The G3X Touch can interface with other navigation sources, or ",(0,r.jsx)(n.em,{children:"external navigators"}),', in the same aircraft. The G3X Touch allows the user to view and interact with the information provided by external navigators through the G3X interface and can also route external navigation guidance to an autopilot. This allows the G3X Touch to function as a central "hub" that presents all pertinent navigation information to the user and allows control of key navigation and autopilot functions through a convenient large-screen touch interface.']}),"\n",(0,r.jsx)(n.p,{children:"External navigators can provide one or both of the following types of data to the G3X Touch:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"NAV radio data"}),"\n",(0,r.jsx)(n.li,{children:"GPS navigation data (includes flight planning, LNAV, VNAV, and glidepath data)"}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Up to two external navigators can be configured for the G3X Touch. If no external navigators are configured, then the G3X Touch is limited to navigating using its internal VFR-only GPS navigation source."}),"\n",(0,r.jsxs)(n.p,{children:["Each external navigator is assigned an index (1 or 2). When only one external navigator is configured, it can be assigned index 1 ",(0,r.jsx)(n.em,{children:"or"})," 2 (i.e. it is okay for external navigator 2 to be the only configured navigator)."]}),"\n",(0,r.jsx)(n.admonition,{type:"info",children:(0,r.jsx)(n.p,{children:"The G3X Touch can only interface with NAV radios through external navigators. The G3X Touch's NAV1 radio is the NAV radio from external navigator 1 and NAV2 is the NAV radio from external navigator 2. Because of this, even standalone NAV radio units without a GPS component (e.g. GNC-series radios) connected to the G3X Touch take up an external navigator slot."})}),"\n",(0,r.jsx)(n.h2,{id:"configuring-the-g3x-touch-to-work-with-external-navigators",children:"Configuring the G3X Touch to work with External Navigators"}),"\n",(0,r.jsxs)(n.p,{children:["The G3X Touch must be explicitly configured to accept data from external navigators. All configuration is done through ",(0,r.jsx)(n.a,{href:"/msfs-avionics-mirror/2024/docs/avionics/g3xtouch/panel-xml-basics",children:(0,r.jsx)(n.code,{children:"panel.xml"})}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.a,{href:"#nav-radio-configuration",children:"Nav Radio Configuration"})," section applies when configuring external navigators that provide NAV radio data, and the ",(0,r.jsx)(n.a,{href:"#fms-configuration",children:"FMS Configuration"})," and ",(0,r.jsx)(n.a,{href:"#external-flight-plan-source-configuration",children:"External Flight Plan Source Configuration"})," sections apply when configuring external navigators that provide GPS navigation data."]}),"\n",(0,r.jsx)(n.h3,{id:"nav-radio-configuration",children:"NAV Radio Configuration"}),"\n",(0,r.jsxs)(n.p,{children:["NAV radio sources from external navigators are configured through the ",(0,r.jsx)(n.a,{href:"/msfs-avionics-mirror/2024/docs/avionics/g3xtouch/panel-xml-tag-documentation#radios",children:(0,r.jsx)(n.code,{children:"<Radios>"})})," tag. One child ",(0,r.jsx)(n.a,{href:"/msfs-avionics-mirror/2024/docs/avionics/g3xtouch/panel-xml-tag-documentation#nav-radios",children:(0,r.jsx)(n.code,{children:"<Nav>"})})," tag should be added to ",(0,r.jsx)(n.code,{children:"<Radios>"})," for each external navigator that provides NAV radio data. The ",(0,r.jsx)(n.code,{children:"index"})," attribute of each ",(0,r.jsx)(n.code,{children:"<Nav>"})," tag should match the index of its corresponding external navigator. If an external navigator does not provide NAV radio data, then the corresponding ",(0,r.jsx)(n.code,{children:"<Nav>"})," tag should be omitted."]}),"\n",(0,r.jsx)(n.admonition,{type:"info",children:(0,r.jsx)(n.p,{children:"External navigator 1 is assumed to use the sim's NAV1 radio and external navigator 2 is assumed to use the sim's NAV2 radio. Therefore, if an external navigator uses NAV1 then it should be configured as external navigator 1, and if it uses NAV2 then it should be configured as external navigator 2."})}),"\n",(0,r.jsx)(n.h3,{id:"fms-configuration",children:"FMS Configuration"}),"\n",(0,r.jsx)(n.p,{children:"The presence of external navigators that provide GPS navigation data necessarily means that independent instances of certain flight planning and navigation code are running simultaneously in the same aircraft. One set will be running on the G3X Touch, and one set on each GPS-capable external navigator. Care must be taken to ensure these instances do not conflict with one another."}),"\n",(0,r.jsxs)(n.p,{children:["To that end, the following options should be explicitly configured in the ",(0,r.jsx)(n.a,{href:"/msfs-avionics-mirror/2024/docs/avionics/g3xtouch/panel-xml-tag-documentation#fms",children:(0,r.jsx)(n.code,{children:"<Fms>"})})," tag:"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"LNAV Index"}),": The index of the LNAV instance used by the G3X Touch internally. Must be distinct from any external navigators."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use Sim OBS State"}),": Whether the G3X Touch should use the sim's native OBS state for its internal LNAV instance. This should be disabled if any external navigators are using the sim's native OBS state."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"VNAV Index"}),": The index of the VNAV instance used by the G3X Touch internally. Must be distinct from any external navigators."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Sync to Sim"}),": Whether the G3X Touch should sync its internal flight plan back to the sim's native flight planning system. This should be disabled if any external navigators are syncing their flight plans to the sim."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"external-flight-plan-source-configuration",children:"External Flight Plan Source Configuration"}),"\n",(0,r.jsxs)(n.p,{children:["External navigators that provide GPS navigation data are considered external flight plan sources. These are declared using the ",(0,r.jsx)(n.a,{href:"/msfs-avionics-mirror/2024/docs/avionics/g3xtouch/panel-xml-tag-documentation#externalsources",children:(0,r.jsx)(n.code,{children:"<ExternalSources>"})})," tag. One ",(0,r.jsx)(n.a,{href:"/msfs-avionics-mirror/2024/docs/avionics/g3xtouch/panel-xml-tag-documentation#source-externalsources",children:(0,r.jsx)(n.code,{children:"<Source>"})})," tag should be created as a child of ",(0,r.jsx)(n.code,{children:"<ExternalSources>"})," for each external flight plan source."]}),"\n",(0,r.jsx)(n.p,{children:"The following options must be defined for each external flight plan source:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Index"}),": The external navigator index of the source."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Flight Planner ID"}),": The ID of the flight planner used by the source."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Flight Path Calculator ID"}),": The ID of the flight path calculator used by the source."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"LNAV Index"}),": The index of the LNAV instance used by the source."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Use Sim OBS State"}),": Whether the source uses the sim's native OBS state for its internal LNAV instance."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"VNAV Index"}),": The index of the VNAV instance used by the source."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Autopilot Guidance Index"}),": The index of the ",(0,r.jsx)(n.a,{href:"#autopilot-guidance",children:"autopilot guidance"})," published by the source."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"CDI ID"}),": The ID of the CDI used by the source."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"example",children:"Example"}),"\n",(0,r.jsxs)(n.p,{children:["The following is an example excerpt from a ",(0,r.jsx)(n.code,{children:"panel.xml"})," file that configures a G3X Touch with two external navigators. External navigator 1 provides both NAV radio and GPS navigation data, while external navigator 2 provides only NAV radio data."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-xml",children:'<Radios>\r\n  <Nav index="1" />\r\n  <Nav index="2" />\r\n</Radios>\r\n\r\n<Fms\r\n  lnav-index="0"\r\n  use-sim-obs="false"\r\n  vnav-index="0"\r\n  sync-to-sim="false"\r\n>\r\n  <ExternalSources>\r\n    <Source\r\n      index="1"\r\n      fpl-id="gns-1"\r\n      flight-path-calc-id="gns-1"\r\n      lnav-index="1"\r\n      use-sim-obs="true"\r\n      vnav-index="1"\r\n      ap-guidance-index="1"\r\n      cdi-id="gns1"\r\n    />\r\n  </ExternalSources>\r\n</Fms>\n'})}),"\n",(0,r.jsx)(n.h2,{id:"configuring-external-navigators-to-work-with-the-g3x-touch",children:"Configuring External Navigators to work with the G3X Touch"}),"\n",(0,r.jsx)(n.p,{children:"External navigators must be configured to correctly send data to the G3X Touch."}),"\n",(0,r.jsxs)(n.p,{children:["If an external navigator only provides NAV radio data, then the only configuration required is to set up a sim NAV radio with the same index as the external navigator's index. Sim radios are configured using the airplane's ",(0,r.jsxs)(n.a,{href:"https://docs.flightsimulator.com/msfs2024/html/5_Content_Configuration/CFG_Files/systems_cfg.htm",children:[(0,r.jsx)(n.code,{children:"systems.cfg"})," file"]}),"."]}),"\n",(0,r.jsx)(n.p,{children:"If an external navigator provides GPS navigation data, then it must be configured to send CDI source, flight planning, LNAV, and optionally VNAV and glidepath data to the G3X Touch. Please refer to the following sections for more details."}),"\n",(0,r.jsxs)(n.admonition,{type:"warning",children:[(0,r.jsxs)(n.p,{children:["The following sections will describe the use of code from the ",(0,r.jsx)(n.code,{children:"msfs-sdk"})," and ",(0,r.jsx)(n.code,{children:"msfs-garminsdk"})," libraries. When using these libraries to implement external navigators, you must use the following versions:"]}),(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"msfs-sdk"}),": ",(0,r.jsx)(n.strong,{children:"2.0.5 or newer"})]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"msfs-garminsdk"}),": ",(0,r.jsx)(n.strong,{children:"2.0.5 or newer"})]}),"\n"]})]}),"\n",(0,r.jsx)(n.h3,{id:"cdi-source",children:"CDI Source"}),"\n",(0,r.jsx)(n.p,{children:"External navigators that provide GPS navigation data must inform the G3X Touch of their current CDI source. CDI source can either be NAV or GPS. Even if an external navigator only provides GPS navigation data and not NAV radio data, it still must send CDI source data (in this case the source would always be GPS)."}),"\n",(0,r.jsxs)(n.p,{children:["CDI source state should be sent to the G3X Touch using the CDI source API defined in the MSFS SDK. To use this API, an ID for the external navigator's CDI must be chosen. The ID can be any string, including the empty string, that is not equal to ",(0,r.jsx)(n.code,{children:"'g3x'"})," (which is the ID used by the G3X's CDI)."]}),"\n",(0,r.jsx)(n.admonition,{type:"info",children:(0,r.jsx)(n.p,{children:"CDI IDs should be unique for each independent CDI."})}),"\n",(0,r.jsxs)(n.p,{children:["Once a CDI ID is chosen, the next step is to publish the CDI source to the event bus topic ",(0,r.jsx)(n.code,{children:"cdi_select[suffix]"})," (defined by the ",(0,r.jsx)(n.a,{href:"/msfs-avionics-mirror/2024/docs/api/framework/interfaces/CdiEvents",children:(0,r.jsx)(n.code,{children:"CdiEvents"})})," interface), where ",(0,r.jsx)(n.code,{children:"[suffix]"})," is determined by the CDI ID: the empty string when the ID is also the empty string, and ",(0,r.jsx)(n.code,{children:"_[ID]"})," otherwise, where ",(0,r.jsx)(n.code,{children:"[ID]"})," is the ID string. When publishing the source to the event bus, it should be synced across instruments and cached:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"import {\r\n  CdiEvents, CdiUtils, EventBus, NavSourceId, NavSourceType\r\n} from '@microsoft/msfs-sdk';\r\n\r\nconst bus = new EventBus();\r\nconst publisher = bus.getPublisher<CdiEvents>();\r\n\r\nconst cdiId = 'gns1'; // Must be different from the G3X Touch's CDI ID (g3x).\r\nconst topic = `cdi_select${CdiUtils.getEventBusTopicSuffix(cdiId)}` as const;\r\n\r\n// Publish CDI source as NAV. The index is not relevant for the G3X Touch.\r\npublisher.pub(topic, { type: NavSourceType.Nav, index: 1 }, true, true);\r\n\r\n// Publish CDI source as GPS. The index is not relevant for the G3X Touch.\r\npublisher.pub(topic, { type: NavSourceType.Gps, index: 1 }, true, true);\n"})}),"\n",(0,r.jsxs)(n.p,{children:["If you wish to allow the G3X Touch to control the external navigator's CDI source (only applicable for certain configurations of ",(0,r.jsx)(n.a,{href:"#cdi-auto-switch-guidance",children:"CDI auto-switch"}),"), then the external navigator must also be configured to respond to the ",(0,r.jsx)(n.code,{children:"cdi_src_set[suffix]"})," event bus topic (defined by the ",(0,r.jsx)(n.a,{href:"/msfs-avionics-mirror/2024/docs/api/framework/interfaces/CdiControlEvents",children:(0,r.jsx)(n.code,{children:"CdiControlEvents"})})," interface)."]}),"\n",(0,r.jsx)(n.admonition,{type:"warning",children:(0,r.jsxs)(n.p,{children:["When the G3X Touch is configured with an internal autopilot, it intercepts the ",(0,r.jsx)(n.code,{children:"AP_NAV_SELECT_SET"})," and ",(0,r.jsx)(n.code,{children:"TOGGLE_GPS_DRIVES_NAV1"})," key events to change its CDI source. Therefore, under these circumstances external navigators should not use the same key events to control their own CDI source state."]})}),"\n",(0,r.jsx)(n.h3,{id:"flight-planning",children:"Flight Planning"}),"\n",(0,r.jsxs)(n.p,{children:["In order to send valid flight plan data to the G3X Touch, the external navigator must use the flight planning system provided by the MSFS SDK. An instance of ",(0,r.jsx)(n.a,{href:"/msfs-avionics-mirror/2024/docs/api/framework/classes/FlightPlanner",children:(0,r.jsx)(n.code,{children:"FlightPlanner"})})," should be created with an ID string that is ",(0,r.jsx)(n.strong,{children:"not"})," ",(0,r.jsx)(n.code,{children:"'g3x'"}),". The flight planner should use a ",(0,r.jsx)(n.a,{href:"/msfs-avionics-mirror/2024/docs/api/framework/classes/FlightPathCalculator",children:(0,r.jsx)(n.code,{children:"FlightPathCalculator"})})," instance that is created with ID string that is also ",(0,r.jsx)(n.strong,{children:"not"})," ",(0,r.jsx)(n.code,{children:"'g3x'"}),". The calculator should have an initialization sync role of ",(0,r.jsx)(n.code,{children:"primary"})," (see the example below). If the external navigator shares its flight path calculator ID with another instrument, then only one instance among all the calculators of that ID need to have a sync role of ",(0,r.jsx)(n.code,{children:"primary"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["Here is some example code that creates a ",(0,r.jsx)(n.code,{children:"FlightPlanner"})," instance compatible with the G3X Touch:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"import {\r\n  EventBus, FacilityLoader, FacilityRepository, FlightPathCalculator, FlightPlanner\r\n} from '@microsoft/msfs-sdk';\r\n\r\nconst bus = new EventBus();\r\nconst facLoader = new FacilityLoader(FacilityRepository.getRepository(bus));\r\n\r\nconst flightPathCalculator = new FlightPathCalculator(\r\n  facLoader,\r\n  {\r\n    id: 'gns',\r\n    initSyncRole: 'primary',\r\n    // Other options as desired.\r\n  },\r\n  bus\r\n);\r\n\r\nconst flightPlanner = FlightPlanner.getPlanner('gns', bus, { calculator: flightPathCalculator });\n"})}),"\n",(0,r.jsx)(n.h3,{id:"lnav",children:"LNAV"}),"\n",(0,r.jsxs)(n.p,{children:["The simplest way for the external navigator to generate LNAV data compatible with the G3X Touch is to create an instance of ",(0,r.jsx)(n.a,{href:"/msfs-avionics-mirror/2024/docs/api/framework/classes/LNavObsManager",children:(0,r.jsx)(n.code,{children:"LNavObsManager"})}),", an instance of ",(0,r.jsx)(n.a,{href:"/msfs-avionics-mirror/2024/docs/api/framework/classes/LNavComputer",children:(0,r.jsx)(n.code,{children:"LNavComputer"})})," with the ",(0,r.jsx)(n.a,{href:"/msfs-avionics-mirror/2024/docs/api/garminsdk/classes/GarminObsLNavModule",children:(0,r.jsx)(n.code,{children:"GarminObsLNavModule"})}),", and an instance of ",(0,r.jsx)(n.a,{href:"/msfs-avionics-mirror/2024/docs/api/garminsdk/classes/NavdataComputer",children:(0,r.jsx)(n.code,{children:"NavdataComputer"})}),". Certain event bus publishers also need to be created for these classes to work correctly (see the example code)."]}),"\n",(0,r.jsx)(n.p,{children:"Here is some example code that creates a set of LNAV classes compatible with the G3X Touch:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"import {\r\n  GNSSPublisher, InstrumentBackplane, LNavComputer, LNavObsManager, LNavObsSimVarPublisher, LNavSimVarPublisher,\r\n  NavComSimVarPublisher\r\n} from '@microsoft/msfs-sdk';\r\nimport {\r\n  GarminAPUtils, GarminObsLNavModule, NavdataComputer, NavEventsPublisher\r\n} from '@microsoft/msfs-garminsdk';\r\n\r\n// These instruments/publishers must be used to publish topics to the event bus in order for the LNAV classes to\r\n// function properly.\r\nconst backplane = new InstrumentBackplane();\r\nconst clock = new Clock(bus);\r\nconst gnssPublisher = new GNSSPublisher(bus);\r\nconst navComPublisher = new NavComSimVarPublisher(bus); // Only required if useSimObsState === true\r\nconst navEventsPublisher = new NavEventsPublisher(bus); // Only required if useSimObsState === true\r\nconst lNavObsPublisher = new LNavObsSimVarPublisher(bus);\r\n// The names of the instruments/publishers used to add them to the backplane must be unique, but are otherwise\r\n// arbitrary. Only one instance of each publisher should be added to the backplane.\r\nbackplane.addInstrument('clock', clock);\r\nbackplane.addPublisher('gnss', gnssPublisher);\r\nbackplane.addPublisher('navCom', navComPublisher);\r\nbackplane.addPublisher('navEvents', navEventsPublisher);\r\nbackplane.addPublisher('lnavObs', lNavObsPublisher);\r\n\r\nconst lnavIndex = 0; // Must be different from the G3X Touch's internal LNAV index.\r\nconst useSimObsState = true; // As desired.\r\nconst maxBankAngle = 25; // Should be the same value as the autopilot's configured maximum bank angle for FMS/GPS mode (not a strict requirement).\r\nconst intercept = GarminAPUtils.lnavIntercept; // As desired.\r\n\r\nconst lnavObsManager = new LNavObsManager(bus, lnavIndex, useSimObsState);\r\nlnavObsManager.init();\r\n\r\nconst lnavComputer = new LNavComputer(\r\n  lnavIndex,\r\n  bus,\r\n  flightPlanner,\r\n  new GarminObsLNavModule(lnavIndex, bus, flightPlanner, {\r\n    maxBankAngle,\r\n    intercept,\r\n    useSimObsState\r\n  }),\r\n  {\r\n    maxBankAngle,\r\n    intercept,\r\n    isPositionDataValid: true, // As desired.\r\n    hasVectorAnticipation: true\r\n  }\r\n);\r\n\r\nconst navdataComputer = new NavdataComputer(bus, flightPlanner, facLoader, {\r\n  lnavIndex,\r\n  useSimObsState,\r\n  vnavIndex: 0,\r\n  useVfrCdiScaling: false // As desired.\r\n});\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Once created, ",(0,r.jsx)(n.code,{children:"LNavComputer"})," must be updated periodically by calling its ",(0,r.jsx)(n.code,{children:"update()"})," method. It is recommended to update ",(0,r.jsx)(n.code,{children:"LNavComputer"})," every frame using a ",(0,r.jsx)(n.code,{children:"setInterval()"})," loop or subscribing to the event bus's ",(0,r.jsx)(n.code,{children:"simTimeHiFreq"}),' topic. These strategies bypass throttling of the Javascript rendering loop that occurs under certain situations (e.g. with a "Low" cockpit refresh rate setting or when the user is in External View) that might lead to unacceptably long intervals between updates. ',(0,r.jsx)(n.code,{children:"NavdataComputer"})," does not need to be explicitly updated and will automatically perform its functions after creation. Finally, the ",(0,r.jsx)(n.code,{children:"InstrumentBackplane"})," (or the individual event bus publishers if not using ",(0,r.jsx)(n.code,{children:"InstrumentBackplane"}),") must also be initialized and updated in a loop; it is recommended to use ",(0,r.jsx)(n.code,{children:"BaseInstrument"}),"'s ",(0,r.jsx)(n.code,{children:"Update()"})," method for this."]}),"\n",(0,r.jsx)(n.p,{children:"Here is some example code showing how to update LNAV and supporting classes:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"import { ClockEvents } from '@microsoft/msfs-sdk';\r\n\r\nclass MyInstrument extends BaseInstrument {\r\n  // ...\r\n\r\n  public connectedCallback(): void {\r\n    super.connectedCallback();\r\n\r\n    // Assuming all LNAV classes and publishers have been created by now.\r\n\r\n    this.backplane.init();\r\n\r\n    this.bus.getSubscriber<ClockEvents>().on('simTimeHiFreq').handle(() => {\r\n      this.lnavComputer.update();\r\n    });\r\n  }\r\n\r\n  public Update(): void {\r\n    super.Update();\r\n\r\n    this.backplane.onUpdate();\r\n  }\r\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["You may also choose to use your own code to generate LNAV data from the external navigator. Any custom implementation must conform to the LNAV API defined in the MSFS SDK and Garmin SDK. Namely, values must be published to ",(0,r.jsx)(n.strong,{children:"all"})," of the event bus topics (with the correct LNAV index) defined by the following:"]}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.strong,{children:"Event Bus Topics"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/msfs-avionics-mirror/2024/docs/api/framework/interfaces/LNavEvents",children:(0,r.jsx)(n.code,{children:"LNavEvents"})})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/msfs-avionics-mirror/2024/docs/api/garminsdk/interfaces/LNavDataEvents",children:(0,r.jsx)(n.code,{children:"LNavDataEvents"})})}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"vnav",children:"VNAV"}),"\n",(0,r.jsxs)(n.p,{children:["If the external navigator supports VNAV, then it must generate VNAV data. First, a vertical path calculator should be created as an instance of ",(0,r.jsx)(n.a,{href:"/msfs-avionics-mirror/2024/docs/api/framework/classes/SmoothingPathCalculator",children:(0,r.jsx)(n.code,{children:"SmoothingPathCalculator"})}),". The calculator must be created using a specific set of configuration options (see the example below)."]}),"\n",(0,r.jsx)(n.p,{children:"Here is some example code that creates a vertical path calculator compatible with the G3X Touch:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"import { SmoothingPathCalculator } from '@microsoft/msfs-sdk';\r\nimport {\r\n  FmsUtils, GarminVNavUtils\r\n} from '@microsoft/msfs-garminsdk';\r\n\r\nconst vnavIndex = 0; // Must be different from the G3X Touch's internal VNAV index.\r\n\r\nconst verticalPathCalc = new SmoothingPathCalculator(bus, flightPlanner, FmsUtils.PRIMARY_PLAN_INDEX, {\r\n  index: vnavIndex,\r\n  defaultFpa: 3,\r\n  maxFpa: 6,\r\n  isLegEligible: GarminVNavUtils.isLegVNavEligible,\r\n  shouldUseConstraint: GarminVNavUtils.shouldUseConstraint,\r\n  invalidateClimbConstraint: GarminVNavUtils.invalidateClimbConstraint,\r\n  invalidateDescentConstraint: GarminVNavUtils.invalidateDescentConstraint\r\n});\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Once a vertical path calculator is created, VNAV data can be generated by using the ",(0,r.jsx)(n.a,{href:"/msfs-avionics-mirror/2024/docs/api/garminsdk/classes/GarminVNavComputer",children:(0,r.jsx)(n.code,{children:"GarminVNavComputer"})})," class."]}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"GarminVNavComputer"})," requires feedback from the autopilot to function correctly. Specifically, it needs access to the autopilot's selected altitude, selected vertical speed, active lateral mode, active vertical mode, and armed vertical mode. It also needs to respond to when the autopilot attempts to activate and deactivate VNAV. If the aircraft is configured to use the G3X Touch's internal autopilot, then these autopilot data can all be retrieved from the event bus (see the example below). If the aircraft is configured with an autopilot that is not managed by the G3X Touch, then you will need to ensure the appropriate data is sent to and captured by the external navigator."]}),"\n",(0,r.jsx)(n.admonition,{type:"info",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"GarminVNavComputer"})," requires ",(0,r.jsx)(n.a,{href:"#lnav",children:"LNAV data"})," and an instance of ",(0,r.jsx)(n.a,{href:"#fms",children:(0,r.jsx)(n.code,{children:"Fms"})})," to function properly."]})}),"\n",(0,r.jsxs)(n.p,{children:["Here is some example code showing how to create a ",(0,r.jsx)(n.code,{children:"GarminVNavComputer"})," that receives feedback from an autopilot managed by the G3X Touch:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"import {\r\n  AdcPublisher, APLateralModes, APVerticalModes, AutopilotInstrument, Clock, ConsumerValue, GNSSPublisher,\r\n  InstrumentBackplane, MappedValue, VNavSimVarPublisher\r\n} from '@microsoft/msfs-sdk';\r\nimport {\r\n  FmaDataEvents, FmsUtils, GarminVNavComputer, GarminVNavComputerAPValues, GarminVNavManagerEvents\r\n} from '@microsoft/msfs-garminsdk';\r\n\r\n// These instruments/publishers must be used to publish topics to the event bus in order for the VNAV computer to\r\n// function properly.\r\nconst backplane = new InstrumentBackplane();\r\nconst clock = new Clock(bus);\r\nconst adcPublisher = new AdcPublisher(bus);\r\nconst gnssPublisher = new GNSSPublisher(bus);\r\nconst apInstrument = new AutopilotInstrument(bus);\r\nconst vnavPublisher = new VNavSimVarPublisher(bus);\r\n// The names of the instruments/publishers used to add them to the backplane must be unique, but are otherwise\r\n// arbitrary. Only one instance of each publisher should be added to the backplane.\r\nbackplane.addInstrument('clock', clock);\r\nbackplane.addPublisher('adc', adcPublisher);\r\nbackplane.addPublisher('gnss', gnssPublisher);\r\nbackplane.addInstrument('ap', apInstrument);\r\nbackplane.addPublisher('vnav', vnavPublisher);\r\n\r\nconst lnavIndex = 0; // The LNAV index chosen for the external navigator.\r\nconst vnavIndex = 0; // Must be different from the G3X Touch's internal VNAV index.\r\n\r\nconst fmaData = ConsumerValue.create<Readonly<FmaData> | undefined>(\r\n  bus.getSubscriber<FmaDataEvents>().on('fma_data'), undefined\r\n);\r\n\r\n// Retrieve autopilot data from the event bus.\r\nconst apValues: GarminVNavComputerAPValues = {\r\n  selectedAltitude: ConsumerValue.create(bus.getSubscriber<APEvents>().on('ap_altitude_selected'), 0),\r\n  selectedVerticalSpeed: ConsumerValue.create(bus.getSubscriber<APEvents>().on('ap_vs_selected'), 0),\r\n  lateralActive: MappedValue.create(([fmaData]) => fmaData?.lateralActive ?? APLateralModes.NONE, fmaData),\r\n  verticalActive: MappedValue.create(([fmaData]) => fmaData?.verticalActive ?? APVerticalModes.NONE, fmaData),\r\n  verticalArmed: MappedValue.create(([fmaData]) => fmaData?.verticalArmed ?? APVerticalModes.NONE, fmaData)\r\n};\r\n\r\nconst vnavComputer = new GarminVNavComputer(\r\n  vnavIndex,\r\n  bus,\r\n  flightPlanner,\r\n  verticalPathCalc,\r\n  apValues,\r\n  {\r\n    primaryPlanIndex: FmsUtils.PRIMARY_PLAN_INDEX,\r\n    lnavIndex,\r\n    // Other options as desired.\r\n  }\r\n);\r\n\r\n// Respond to attempts by the autopilot to activate/deactivate VNAV.\r\nbus.getSubscriber<GarminVNavManagerEvents>()\r\n  .on('vnav_manager_activated').handle(() => { vnavComputer.tryActivate(); });\r\nbus.getSubscriber<GarminVNavManagerEvents>()\r\n  .on('vnav_manager_deactivated').handle(() => { vnavComputer.tryDeactivate(); });\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Once created, ",(0,r.jsx)(n.code,{children:"GarminVNavComputer"})," must be updated periodically by calling its ",(0,r.jsx)(n.code,{children:"update()"})," method. Like with the LNAV computer, it is recommended to update ",(0,r.jsx)(n.code,{children:"GarminVNavComputer"})," every frame using a ",(0,r.jsx)(n.code,{children:"setInterval()"})," loop or subscribing to the event bus's ",(0,r.jsx)(n.code,{children:"simTimeHiFreq"})," topic. And as always, the ",(0,r.jsx)(n.code,{children:"InstrumentBackplane"})," (or the individual event bus publishers if not using ",(0,r.jsx)(n.code,{children:"InstrumentBackplane"}),") must also be initialized and updated in a loop; it is recommended to use ",(0,r.jsx)(n.code,{children:"BaseInstrument"}),"'s ",(0,r.jsx)(n.code,{children:"Update()"})," method for this."]}),"\n",(0,r.jsx)(n.p,{children:"Here is some example code showing how to update VNAV and supporting classes:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"import { ClockEvents } from '@microsoft/msfs-sdk';\r\n\r\nclass MyInstrument extends BaseInstrument {\r\n  // ...\r\n\r\n  public connectedCallback(): void {\r\n    super.connectedCallback();\r\n\r\n    // Assuming all VNAV classes and publishers have been created by now.\r\n\r\n    this.backplane.init();\r\n\r\n    this.bus.getSubscriber<ClockEvents>().on('simTimeHiFreq').handle(() => {\r\n      this.vnavComputer.update();\r\n    });\r\n  }\r\n\r\n  public Update(): void {\r\n    super.Update();\r\n\r\n    this.backplane.onUpdate();\r\n  }\r\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"glidepath",children:"Glidepath"}),"\n",(0,r.jsxs)(n.p,{children:["If the external navigator supports RNAV approaches, then it must generate glidepath data. Glidepath data can be generated using an instance of ",(0,r.jsx)(n.a,{href:"/msfs-avionics-mirror/2024/docs/api/garminsdk/classes/GarminGlidepathComputer",children:(0,r.jsx)(n.code,{children:"GarminGlidepathComputer"})}),"."]}),"\n",(0,r.jsx)(n.admonition,{type:"info",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"GarminGlidepathComputer"})," requires ",(0,r.jsx)(n.a,{href:"#lnav",children:"LNAV data"})," and an instance of ",(0,r.jsx)(n.a,{href:"#fms",children:(0,r.jsx)(n.code,{children:"Fms"})})," to function properly."]})}),"\n",(0,r.jsx)(n.p,{children:"Here is some example code that creates a glidepath computer compatible with the G3X Touch:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"import {\r\n  AdcPublisher, GNSSPublisher, InstrumentBackplane, VNavSimVarPublisher\r\n} from '@microsoft/msfs-sdk';\r\nimport { FmsUtils, GarminGlidepathComputer } from '@microsoft/msfs-garminsdk';\r\n\r\n// These instruments/publishers must be used to publish topics to the event bus in order for the glidepath computer to\r\n// function properly.\r\nconst backplane = new InstrumentBackplane();\r\nconst adcPublisher = new AdcPublisher(bus);\r\nconst gnssPublisher = new GNSSPublisher(bus);\r\nconst vnavPublisher = new VNavSimVarPublisher(bus);\r\n// The names of the instruments/publishers used to add them to the backplane must be unique, but are otherwise\r\n// arbitrary. Only one instance of each publisher should be added to the backplane.\r\nbackplane.addPublisher('adc', adcPublisher);\r\nbackplane.addPublisher('gnss', gnssPublisher);\r\nbackplane.addPublisher('vnav', vnavPublisher);\r\n\r\nconst lnavIndex = 0; // The LNAV index chosen for the external navigator.\r\nconst vnavIndex = 0; // Must be different from the G3X Touch's internal VNAV index.\r\n\r\nconst glidepathComputer = new GarminGlidepathComputer(\r\n  vnavIndex,\r\n  bus,\r\n  flightPlanner,\r\n  {\r\n    primaryPlanIndex: FmsUtils.PRIMARY_PLAN_INDEX,\r\n    lnavIndex,\r\n    // Other options as desired.\r\n  }\r\n);\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Once created, ",(0,r.jsx)(n.code,{children:"GarminGlidepathComputer"})," must be updated periodically by calling its ",(0,r.jsx)(n.code,{children:"update()"})," method. Like with the LNAV computer, it is recommended to update ",(0,r.jsx)(n.code,{children:"GarminGlidepathComputer"})," every frame using a ",(0,r.jsx)(n.code,{children:"setInterval()"})," loop or subscribing to the event bus's ",(0,r.jsx)(n.code,{children:"simTimeHiFreq"})," topic. And as always, the ",(0,r.jsx)(n.code,{children:"InstrumentBackplane"})," (or the individual event bus publishers if not using ",(0,r.jsx)(n.code,{children:"InstrumentBackplane"}),") must also be initialized and updated in a loop; it is recommended to use ",(0,r.jsx)(n.code,{children:"BaseInstrument"}),"'s ",(0,r.jsx)(n.code,{children:"Update()"})," method for this."]}),"\n",(0,r.jsx)(n.p,{children:"Here is some example code showing how to update the glidepath computer and supporting classes:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"import { ClockEvents } from '@microsoft/msfs-sdk';\r\n\r\nclass MyInstrument extends BaseInstrument {\r\n  // ...\r\n\r\n  public connectedCallback(): void {\r\n    super.connectedCallback();\r\n\r\n    // Assuming all glidepath classes and publishers have been created by now.\r\n\r\n    this.backplane.init();\r\n\r\n    this.bus.getSubscriber<ClockEvents>().on('simTimeHiFreq').handle(() => {\r\n      this.glidepathComputer.update();\r\n    });\r\n  }\r\n\r\n  public Update(): void {\r\n    super.Update();\r\n\r\n    this.backplane.onUpdate();\r\n  }\r\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"fms",children:"FMS"}),"\n",(0,r.jsxs)(n.p,{children:["The external navigator should use an instance of ",(0,r.jsx)(n.a,{href:"/msfs-avionics-mirror/2024/docs/api/garminsdk/classes/Fms",children:(0,r.jsx)(n.code,{children:"Fms"})})," to manipulate flight plans. ",(0,r.jsx)(n.code,{children:"Fms"})," ensures that the internal structure of flight plans are formatted correctly, appropriate metadata is created and maintained for flight plans, and important data is published to the event bus."]}),"\n",(0,r.jsx)(n.p,{children:"Here is some example code that creates an FMS compatible with the G3X Touch:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"import {\r\n  AdcPublisher, GNSSPublisher, InstrumentBackplane, LNavObsSimVarPublisher, NavComSimVarPublisher\r\n} from '@microsoft/msfs-sdk';\r\nimport { Fms, NavEventsPublisher } from '@microsoft/msfs-garminsdk';\r\n\r\n// These instruments/publishers must be used to publish topics to the event bus in order for the LNAV classes to\r\n// function properly.\r\nconst backplane = new InstrumentBackplane();\r\nconst adcPublisher = new AdcPublisher(bus);\r\nconst gnssPublisher = new GNSSPublisher(bus);\r\nconst navComPublisher = new NavComSimVarPublisher(bus);\r\nconst navEventsPublisher = new NavEventsPublisher(bus); // Only required if useSimObsState === true\r\nconst lNavObsPublisher = new LNavObsSimVarPublisher(bus);\r\n// The names of the instruments/publishers used to add them to the backplane must be unique, but are otherwise\r\n// arbitrary. Only one instance of each publisher should be added to the backplane.\r\nbackplane.addPublisher('adc', adcPublisher);\r\nbackplane.addPublisher('gnss', gnssPublisher);\r\nbackplane.addPublisher('navCom', navComPublisher);\r\nbackplane.addPublisher('navEvents', navEventsPublisher);\r\nbackplane.addPublisher('lnavObs', lNavObsPublisher);\r\n\r\nconst isPrimary = true; // There must be exactly one primary Fms instance per unique flight planner ID.\r\nconst lnavIndex = 0; // The LNAV index chosen for the external navigator.\r\nconst useSimObsState = true; // As desired.\r\nconst vnavIndex = 0; // The VNAV index chosen for the external navigator.\r\n\r\nconst fms = new Fms(\r\n  isPrimary,\r\n  bus,\r\n  flightPlanner,\r\n  verticalPathCalculator, // Optional; only required if the external navigator supports VNAV.\r\n  {\r\n    lnavIndex,\r\n    useSimObsState,\r\n    vnavIndex,\r\n    // Other options as desired.\r\n  }\r\n);\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Once created, ",(0,r.jsx)(n.code,{children:"Fms"})," should be used to carry out ",(0,r.jsx)(n.strong,{children:"all"})," modifications to the external navigator's flight plan. Direct manipulation of flight plans using ",(0,r.jsx)(n.code,{children:"FlightPlanner"})," or ",(0,r.jsx)(n.code,{children:"FlightPlan"})," is highly discouraged and may lead to undesired behavior."]}),"\n",(0,r.jsx)(n.h3,{id:"autopilot-guidance",children:"Autopilot Guidance"}),"\n",(0,r.jsx)(n.p,{children:"The external navigator should provide LNAV, VNAV, and glidepath guidance to the G3X Touch's managed autopilot if the G3X Touch is configured with one. These guidance data should be written to the SimVars listed in the following enums:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["LNAV: ",(0,r.jsx)(n.a,{href:"/msfs-avionics-mirror/2024/docs/api/garminsdk/enumerations/APExternalGpsSteerCommandSimVars",children:(0,r.jsx)(n.code,{children:"APExternalGpsSteerCommandSimVars"})})]}),"\n",(0,r.jsxs)(n.li,{children:["VNAV: ",(0,r.jsx)(n.a,{href:"/msfs-avionics-mirror/2024/docs/api/garminsdk/enumerations/APExternalVNavGuidanceSimVars",children:(0,r.jsx)(n.code,{children:"APExternalVNavGuidanceSimVars"})})," and ",(0,r.jsx)(n.a,{href:"/msfs-avionics-mirror/2024/docs/api/garminsdk/enumerations/APExternalVerticalPathGuidanceSimVars",children:(0,r.jsx)(n.code,{children:"APExternalVerticalPathGuidanceSimVars"})})]}),"\n",(0,r.jsxs)(n.li,{children:["Glidepath: ",(0,r.jsx)(n.a,{href:"/msfs-avionics-mirror/2024/docs/api/garminsdk/enumerations/APExternalGlidepathGuidanceSimVars",children:(0,r.jsx)(n.code,{children:"APExternalGlidepathGuidanceSimVars"})})]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["The SimVars should be indexed (using the suffix ",(0,r.jsx)(n.code,{children:"_[index]"}),") with a chosen autopilot guidance index. The index can be any non-negative integer, but it must be unique for each external navigator providing independent guidance and it must match the index provided to the G3X Touch when declaring the external navigator as an ",(0,r.jsx)(n.a,{href:"#external-flight-plan-source-configuration",children:"external flight plan source"})," in ",(0,r.jsx)(n.code,{children:"panel.xml"}),"."]}),"\n",(0,r.jsxs)(n.p,{children:["If you used the ",(0,r.jsx)(n.a,{href:"#lnav",children:"LNAV"}),", ",(0,r.jsx)(n.a,{href:"#vnav",children:"VNAV"}),", and/or ",(0,r.jsx)(n.a,{href:"#glidepath",children:"glidepath"})," classes suggested above, then guidance data can be retrieved directly from those classes:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"const lnavComputer = new LNavComputer(/* ... */);\r\nconst vnavComputer = new GarminVNavComputer(/* ... */);\r\nconst glidepathComputer = new GarminGlidepathComputer(/* ... */);\r\n\r\nconst gpsSteerCommand = lnavComputer.steerCommand.get();\r\nconst vnavGuidance = vnavComputer.guidance.get();\r\nconst vnavPathGuidance = vnavComputer.pathGuidance.get();\r\nconst glidepathGuidance = glidepathComputer.glidepathGuidance.get();\n"})}),"\n",(0,r.jsx)(n.admonition,{type:"info",children:(0,r.jsx)(n.p,{children:"If the G3X Touch is not configured with an autopilot, then the external navigator can skip sending autopilot guidance in the form of the above SimVars. However, LNAV, VNAV, and glidepath data (the latter two only if supported) must still be generated even without an autopilot. This is because the G3X Touch uses those data to drive various indications that are not dependent on an autopilot, such as the CDI and VDI."})}),"\n",(0,r.jsx)(n.h3,{id:"cdi-auto-switch-guidance",children:"CDI Auto-Switch Guidance"}),"\n",(0,r.jsx)(n.p,{children:"If the external navigator provides both GPS navigation and NAV radio data and supports automatically switching CDI source from GPS to NAV during the final approach segment of certain approaches (e.g. ILS/LOC approaches) and the G3X Touch is configured with an autopilot, then the external navigator must provide the appropriate guidance to the G3X Touch. If this guidance is not provided and the automatic switch happens when the G3X's flight director is in GPS mode, then the flight director will revert to ROL mode due to the change in CDI source."}),"\n",(0,r.jsxs)(n.p,{children:["CDI auto-switch guidance should be provided to the G3X Touch by publishing the appropriate data to the following event bus topics. Note that all topics should be suffixed with the external navigator's index (e.g. ",(0,r.jsx)(n.code,{children:"g3x_external_nav_to_nav_armable_nav_radio_index_1"})," or ",(0,r.jsx)(n.code,{children:"g3x_external_nav_to_nav_armable_nav_radio_index_2"}),"). Published data should be synced to other instruments and cached."]}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Topic"}),(0,r.jsx)(n.th,{children:"Description"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"g3x_external_nav_to_nav_armable_nav_radio_index"})}),(0,r.jsxs)(n.td,{children:["The index of the NAV radio that can be armed for an automatic CDI source switch. When CDI auto-switch can be armed, this should be equal to the external navigator's NAV radio index. When CDI auto-switch cannot be armed, this should be equal to ",(0,r.jsx)(n.code,{children:"-1"}),"."]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"g3x_external_nav_to_nav_armable_lateral_mode"})}),(0,r.jsxs)(n.td,{children:["The autopilot lateral mode that can be armed while automatic CDI source switch can be armed (usually ",(0,r.jsx)(n.code,{children:"APLateralModes.LOC"}),"). When CDI auto-switch cannot be armed, this should be equal to ",(0,r.jsx)(n.code,{children:"APLateralModes.NONE"}),"."]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"g3x_external_nav_to_nav_armable_vertical_mode"})}),(0,r.jsxs)(n.td,{children:["The autopilot vertical mode that can be armed while automatic CDI source switch can be armed (usually ",(0,r.jsx)(n.code,{children:"APVerticalModes.GS"}),"). When CDI auto-switch cannot be armed, this should be equal to ",(0,r.jsx)(n.code,{children:"APVerticalModes.NONE"}),"."]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"g3x_external_nav_to_nav_can_switch"})}),(0,r.jsxs)(n.td,{children:["Whether the G3X Touch's autopilot is allowed to initiate an automatic CDI source switch at the current point in time. If the external navigator initiates its own automatic CDI source switches, then this should always be set to ",(0,r.jsx)(n.code,{children:"false"}),". If set to ",(0,r.jsx)(n.code,{children:"true"}),", the G3X Touch's autopilot will attempt to initiate a CDI source switch as soon as the armable NAV radio index is valid, the flight director's LOC mode is armed, and the autopilot's LOC director can capture the localizer course."]})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"g3x_external_nav_to_nav_external_switch_in_progress"})}),(0,r.jsxs)(n.td,{children:["Whether an automatic CDI source switch initiated by the external navigator is currently in progress. This should be set to ",(0,r.jsx)(n.code,{children:"true"})," immediately before the automatic CDI source switch occurs, and set to ",(0,r.jsx)(n.code,{children:"false"})," immediately after the switch is complete."]})]})]})]}),"\n",(0,r.jsxs)(n.p,{children:["External navigators have the option (but are not required) to generate CDI auto-switch guidance using ",(0,r.jsx)(n.a,{href:"/msfs-avionics-mirror/2024/docs/api/garminsdk/classes/GarminNavToNavComputer",children:(0,r.jsx)(n.code,{children:"GarminNavToNavComputer"})}),". ",(0,r.jsx)(n.code,{children:"GarminNavToNavComputer"})," will generate guidance based on logic that is common to all Garmin avionics units."]}),"\n",(0,r.jsx)(n.admonition,{type:"info",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"GarminNavToNavComputer"})," requires ",(0,r.jsx)(n.a,{href:"#lnav",children:"LNAV data"})," and an instance of ",(0,r.jsx)(n.a,{href:"#fms",children:(0,r.jsx)(n.code,{children:"Fms"})})," to function properly."]})}),"\n",(0,r.jsxs)(n.p,{children:["Here is some example code that uses ",(0,r.jsx)(n.code,{children:"GarminNavToNavComputer"})," to generate CDI auto-switch guidance and publishes the guidance for the G3X Touch:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"import {\r\n  Clock, GNSSPublisher, InstrumentBackplane, NavComSimVarPublisher\r\n} from '@microsoft/msfs-sdk';\r\nimport { GarminNavToNavComputer } from '@microsoft/msfs-garminsdk';\r\n\r\n// These instruments/publishers must be used to publish topics to the event bus in order for the nav-to-nav computer to\r\n// function properly.\r\nconst backplane = new InstrumentBackplane();\r\nconst clock = new Clock(bus);\r\nconst gnssPublisher = new GNSSPublisher(bus);\r\nconst navComPublisher = new NavComSimVarPublisher(bus);\r\n// The names of the instruments/publishers used to add them to the backplane must be unique, but are otherwise\r\n// arbitrary. Only one instance of each publisher should be added to the backplane.\r\nbackplane.addInstrument('clock', clock);\r\nbackplane.addPublisher('gnss', gnssPublisher);\r\nbackplane.addPublisher('navCom', navComPublisher);\r\n\r\nconst cdiId = 'gns1'; // The external navigator's CDI ID.\r\nconst navRadioIndexes = [1]; // An iterable of the indexes of the NAV radios to which the external navigator's CDI can\r\n                             // be automatically switched. This should contain a single index: that of the external\r\n                             // navigator's NAV radio.\r\n\r\nconst computer = new GarminNavToNavComputer(\r\n  bus,\r\n  fms, // An instance of Fms\r\n  {\r\n    cdiId,\r\n    navRadioIndexes\r\n    // Other options as desired\r\n  }\r\n);\r\n\r\n// Once the computer is created, it will automatically generate guidance. There is no need to explicitly update it.\r\n\r\ncomputer.armableNavRadioIndex.sub(index => {\r\n  publisher.pub('g3x_external_nav_to_nav_armable_nav_radio_index_1', index, true, true);\r\n}, true);\r\n\r\ncomputer.armableLateralMode.sub(mode => {\r\n  publisher.pub('g3x_external_nav_to_nav_armable_lateral_mode_1', mode, true, true);\r\n}, true);\r\n\r\n// Etc.\n"})}),"\n",(0,r.jsx)(n.admonition,{type:"info",children:(0,r.jsx)(n.p,{children:"If the G3X Touch is not configured with an autopilot, then the external navigator can skip sending CDI auto-switch guidance."})}),"\n",(0,r.jsx)(n.h3,{id:"availability",children:"Availability"}),"\n",(0,r.jsx)(n.p,{children:"The G3X Touch needs to know when external navigators are available and when they are not so that it can revert to the backup external navigator or to its internal navigation source when necessary. Generally speaking, an external navigator should be considered available when it is powered and initialized and not available otherwise. However, external navigators are free to choose their own logic as long as they provide the G3X Touch with coherent data while they are considered to be available."}),"\n",(0,r.jsxs)(n.p,{children:["External navigators should communicate their availability to the G3X Touch in two ways. The first is to write the availability state as a boolean (",(0,r.jsx)(n.code,{children:"0"}),"/",(0,r.jsx)(n.code,{children:"1"}),") to an LVar: ",(0,r.jsx)(n.code,{children:"L:WT_G3X_Fpl_Source_External_Available:[index]"}),", where ",(0,r.jsx)(n.code,{children:"[index]"})," is the external navigator's assigned index (i.e. ",(0,r.jsx)(n.code,{children:"1"})," for external navigator 1 and ",(0,r.jsx)(n.code,{children:"2"})," for external navigator 2). The second is to publish the availability state as a boolean value to the event bus topic ",(0,r.jsx)(n.code,{children:"g3x_fpl_source_external_available_[index]"}),", where ",(0,r.jsx)(n.code,{children:"[index]"})," again is the external navigator's assigned index. When publishing this event bus topic, ensure that the published data is synced to other instruments (so that it reaches the G3X Touch) and is cached:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-ts",children:"bus.pub(\r\n  'g3x_fpl_source_external_available_1',\r\n  true,\r\n  true, // sync to other instruments\r\n  true // cache data\r\n);\n"})})]})}function h(e={}){let{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},250065:function(e,n,t){t.d(n,{Z:function(){return o},a:function(){return s}});var a=t(667294);let r={},i=a.createContext(r);function s(e){let n=a.useContext(i);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),a.createElement(i.Provider,{value:n},e.children)}}}]);