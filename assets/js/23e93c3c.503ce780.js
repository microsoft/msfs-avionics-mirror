"use strict";(self.webpackChunkdocs_api=self.webpackChunkdocs_api||[]).push([[95843],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>u});var a=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},d=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},p="mdxType",h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),p=c(n),m=i,u=p["".concat(l,".").concat(m)]||p[m]||h[m]||o;return n?a.createElement(u,r(r({ref:t},d),{},{components:n})):a.createElement(u,r({ref:t},d))}));function u(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,r=new Array(o);r[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[p]="string"==typeof e?e:i,r[1]=s;for(var c=2;c<o;c++)r[c]=n[c];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},92039:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var a=n(87462),i=(n(67294),n(3905));const o={sidebar_label:"GTC Framework",sidebar_position:10},r="G3000 GTC Framework",s={unversionedId:"g3000/gtc-framework",id:"g3000/gtc-framework",title:"G3000 GTC Framework",description:"GTC Views and the View Stack",source:"@site/docs/g3000/gtc-framework.md",sourceDirName:"g3000",slug:"/g3000/gtc-framework",permalink:"/msfs-avionics-mirror/docs/g3000/gtc-framework",draft:!1,tags:[],version:"current",sidebarPosition:10,frontMatter:{sidebar_label:"GTC Framework",sidebar_position:10},sidebar:"sidebar",previous:{title:"Display Panes",permalink:"/msfs-avionics-mirror/docs/g3000/display-panes"},next:{title:"CAS",permalink:"/msfs-avionics-mirror/docs/g3000/cas"}},l={},c=[{value:"GTC Views and the View Stack",id:"gtc-views-and-the-view-stack",level:2},{value:"Control Modes",id:"control-modes",level:2},{value:"View Lifecycle",id:"view-lifecycle",level:2},{value:"The GTC Service",id:"the-gtc-service",level:2},{value:"Registering Views",id:"registering-views",level:2},{value:"The Button Bar and Label Bar",id:"the-button-bar-and-label-bar",level:2},{value:"Interaction Events",id:"interaction-events",level:2},{value:"Knobs and Control State",id:"knobs-and-control-state",level:2}],d={toc:c},p="wrapper";function h(e){let{components:t,...n}=e;return(0,i.kt)(p,(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"g3000-gtc-framework"},"G3000 GTC Framework"),(0,i.kt)("h2",{id:"gtc-views-and-the-view-stack"},"GTC Views and the View Stack"),(0,i.kt)("p",null,"The G3000's GTC framework is centered around the concept of ",(0,i.kt)("em",{parentName:"p"},"views")," and the ",(0,i.kt)("em",{parentName:"p"},"view stack"),"."),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Views")," render content to be displayed on the GTC and handle user interactions with the touchscreen, knobs, and softkeys. All views are FS components that extend the abstract class ",(0,i.kt)("inlineCode",{parentName:"p"},"GtcView"),". There are two types of views: ",(0,i.kt)("em",{parentName:"p"},"pages")," and ",(0,i.kt)("em",{parentName:"p"},"popups"),". Only one page can be open at a time. Meanwhile, multiple popups can be open simultaneously."),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"Views on horizontal GTCs (580 model) are 990px in width and 768px in height. Views on vertical GTCs (570/575 model) are 480px in width and 413 px in height. These dimensions include the area used to display the view title.")),(0,i.kt)("p",null,"Open views are stored on the ",(0,i.kt)("em",{parentName:"p"},"view stack"),". The open page is located at the bottom of the stack, and popups are pushed onto the stack in the order in which they were opened. The view at the top of the stack is considered the ",(0,i.kt)("em",{parentName:"p"},"active view"),". Typically, all user interactions are routed to the active view, though there are some exceptions."),(0,i.kt)("p",null,"The view stack also maintains a history. Each time a view is pushed to the view stack, a new history snapshot of the view stack state is created and pushed onto the history stack. This allows previous view stack states to be restored via a 'Back' operation."),(0,i.kt)("h2",{id:"control-modes"},"Control Modes"),(0,i.kt)("p",null,"GTCs operate in one of three control modes:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"PFD"),(0,i.kt)("li",{parentName:"ul"},"MFD"),(0,i.kt)("li",{parentName:"ul"},"NAV/COM")),(0,i.kt)("p",null,"A particular GTC does not necessarily have access to all three control modes. Horizontal GTCs (580 model) can be configured to support all three modes or only the PFD and NAV/COM modes. Vertical GTCs (570/575 model) can only support either the PFD or MFD modes, and cannot freely switch between them."),(0,i.kt)("p",null,"Each control mode maintains its own view stack. Switching between control modes switches the active view stack and therefore which view(s) are visible. The view stacks of non-active control modes are retained, ready to be resumed when the user switches back to those modes."),(0,i.kt)("p",null,"The MFD control mode is unique in that it maintains not just one view stack but one view stack for each controllable display pane. When the MFD control mode is active, the user can select any non-hidden controllable display pane to control, and that pane's view stack becomes the active view stack. Like with other view stacks, non-active display pane view stacks are retained and ready to be resumed when the user selects their associated pane again."),(0,i.kt)("h2",{id:"view-lifecycle"},"View Lifecycle"),(0,i.kt)("p",null,"GTC views have a complicated lifecycle, since they can move between many different states. Each view stack has its own instance of any particular view. Therefore, views of the same type in different stacks do not implicitly share state."),(0,i.kt)("p",null,"A view is considered ",(0,i.kt)("em",{parentName:"p"},"in-use")," when it appears in any historical version of its view stack (including the current version) and ",(0,i.kt)("em",{parentName:"p"},"out-of-use")," otherwise."),(0,i.kt)("p",null,"A view is considered ",(0,i.kt)("em",{parentName:"p"},"open")," when it appears in the current (most recent) version of its view stack and ",(0,i.kt)("em",{parentName:"p"},"closed")," otherwise. The ",(0,i.kt)("inlineCode",{parentName:"p"},"onOpen()")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"onClose()")," lifecycle methods are called when a view switches between these two states."),(0,i.kt)("p",null,"A view is considered ",(0,i.kt)("em",{parentName:"p"},"awake")," when it appears in the current (most recent) version of the active view stack, and ",(0,i.kt)("em",{parentName:"p"},"asleep")," otherwise."),(0,i.kt)("p",null,"Finally, a view is considered ",(0,i.kt)("em",{parentName:"p"},"active")," or ",(0,i.kt)("em",{parentName:"p"},"resumed")," when it appears at the top of the current (most recent) version of the active view stack, and ",(0,i.kt)("em",{parentName:"p"},"inactive")," or ",(0,i.kt)("em",{parentName:"p"},"paused")," otherwise. The ",(0,i.kt)("inlineCode",{parentName:"p"},"onResume()")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"onPause()")," lifecycle methods are called when a view switches between these two states. Each GTC only has one active view at a time, and it is with this view that the user primarily interacts."),(0,i.kt)("p",null,"Views are always created initially in an ",(0,i.kt)("em",{parentName:"p"},"out of use")," state. Views can also have different lifespans, determined by their ",(0,i.kt)("em",{parentName:"p"},"lifecycle policy"),". The different possible lifecycle policies are included as members of the ",(0,i.kt)("inlineCode",{parentName:"p"},"GtcViewLifecyclePolicy")," enum:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Static: The view is created immediately when it is registered (see below) and is never destroyed. Should only be used by views that have persistent state and need to be created when the GTC instrument is first initialized."),(0,i.kt)("li",{parentName:"ul"},"Persistent: The view is created immediately before the first time it transitions to an in-use state and is never destroyed. Should be used by views that have persistent state."),(0,i.kt)("li",{parentName:"ul"},"Transient: The view is created immediately before the first time it transitions to an in-use state and is destroyed when it transitions back to an out-of-use state. Should be used by views that do not have persistent state.")),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"Views have a non-negligible memory footprint when created. Therefore, it is recommended that the transient lifecycle policy be used whenever possible to reduce memory load and increase stability in memory-limited scenarios oftentimes seen in low-spec PCs and the XBox consoles.")),(0,i.kt)("admonition",{type:"caution"},(0,i.kt)("p",{parentName:"admonition"},"Ensure that transient views properly release all resources they use when they are destroyed to avoid memory leaks. Cleanup code should be included in the view's ",(0,i.kt)("inlineCode",{parentName:"p"},"destroy()")," method."),(0,i.kt)("p",{parentName:"admonition"},"It is also good practice to ensure ",(0,i.kt)("em",{parentName:"p"},"all")," views contain cleanup code, regardless of their lifecycle policy. This is because a mod or plugin can theoretically replace any registered view with another one (see ",(0,i.kt)("a",{parentName:"p",href:"#registering-views"},"Registering Views"),").")),(0,i.kt)("h2",{id:"the-gtc-service"},"The GTC Service"),(0,i.kt)("p",null,"Each GTC instrument contains one instance of ",(0,i.kt)("inlineCode",{parentName:"p"},"GtcService"),", which is the class that controls all view-related state and logic. Switching control modes, selecting controllable display panes, opening and closing views - all of these actions and more are handled by ",(0,i.kt)("inlineCode",{parentName:"p"},"GtcService"),". All views are passed a reference to their parent ",(0,i.kt)("inlineCode",{parentName:"p"},"GtcService")," instance as a prop."),(0,i.kt)("h2",{id:"registering-views"},"Registering Views"),(0,i.kt)("p",null,"Views must be registered with ",(0,i.kt)("inlineCode",{parentName:"p"},"GtcService")," before they can be used. Each view is registered under a unique string key, which is then used to open and retrieve the view from ",(0,i.kt)("inlineCode",{parentName:"p"},"GtcService"),". Views are registered on a per-control mode basis; different views may be registered under the same key to different control modes. Finally, views are registered as factories - functions that create and return the registered view as a ",(0,i.kt)("inlineCode",{parentName:"p"},"VNode")," - instead of directly as instances of the view. This is to allow ",(0,i.kt)("inlineCode",{parentName:"p"},"GtcService")," to handle the process of creating views with various lifecycle policies, and in the case of MFD control mode views, to allow the creation of one instance of the registered view for each controllable display pane view stack."),(0,i.kt)("p",null,"If a view is registered to a control mode under a key that is already registered to that control mode, the new view will replace the existing view registered under that key. If an instance of the existing view has already been created, it will be destroyed when it is replaced."),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"The ",(0,i.kt)("inlineCode",{parentName:"p"},"GtcViewKeys")," enum contains all GTC view keys defined and used by the base G3000.")),(0,i.kt)("h2",{id:"the-button-bar-and-label-bar"},"The Button Bar and Label Bar"),(0,i.kt)("p",null,"In addition to content rendered by views, the GTC also displays a ",(0,i.kt)("em",{parentName:"p"},"button bar")," and ",(0,i.kt)("em",{parentName:"p"},"label bar")," on the edge of the screen (the right edge on horizontal GTCs and the bottom edge on vertical GTCs). Collectively, these are known as the ",(0,i.kt)("em",{parentName:"p"},"sidebar"),", and they contain context-dependent buttons and labels."),(0,i.kt)("p",null,"Views can control what appears in the sidebar using the ",(0,i.kt)("inlineCode",{parentName:"p"},"_sidebarState")," property defined by ",(0,i.kt)("inlineCode",{parentName:"p"},"GtcView"),". The state defined by ",(0,i.kt)("inlineCode",{parentName:"p"},"_sidebarState")," is automatically applied to the sidebar when the view becomes the active view. Correspondingly, when a view is no longer the active view, it automatically passes control of the sidebar state to the new active view."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"GtcSidebar")," class contains utility methods for working with the sidebar."),(0,i.kt)("h2",{id:"interaction-events"},"Interaction Events"),(0,i.kt)("p",null,'The user interacts with the GTC in two ways: (1) through "touch" (mouse) events, and (2) through manipulating the GTC\'s "physical" knobs, joysticks, and bezel keys. Touch events are handled by various components rendered on the GTC screen that simulate touchscreen buttons, sliders, touchpads, etc. Meanwhile, the "physical" events, along with certain touch events that are not specific to any GTC view, are handled using the ',(0,i.kt)("inlineCode",{parentName:"p"},"GtcInteractionEvent")," API."),(0,i.kt)("p",null,"When a user manipulates a GTC knob, joystick, or bezel key, or presses a button on the button bar, the interaction generates a ",(0,i.kt)("inlineCode",{parentName:"p"},"GtcInteractionEvent"),". The event is then routed to a series of handlers implementing the ",(0,i.kt)("inlineCode",{parentName:"p"},"GtcInteractionHandler")," interface. As each handler is notified of the event, it can either choose to handle the event or do nothing. If the event is handled, then no further handlers will be notified of the event. If the event is not handled, then the next handler is notified and the process repeats."),(0,i.kt)("p",null,"Event routing always follows the same path:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"The active GTC view."),(0,i.kt)("li",{parentName:"ol"},"All registered GTC plugins, in the reverse order in which they were loaded."),(0,i.kt)("li",{parentName:"ol"},"The default interaction handler defined in the GTC service.")),(0,i.kt)("p",null,"A common pattern encountered when an event is routed to a GTC view is that the responsibility for handling it falls to a single component in the view. To facilitate implementing this pattern, the base ",(0,i.kt)("inlineCode",{parentName:"p"},"GtcView")," class defines a property called ",(0,i.kt)("inlineCode",{parentName:"p"},"_activeComponent"),", which is a ",(0,i.kt)("inlineCode",{parentName:"p"},"Subject")," that takes either a ",(0,i.kt)("inlineCode",{parentName:"p"},"GtcInteractionHandler")," value or ",(0,i.kt)("inlineCode",{parentName:"p"},"null"),". When the value of ",(0,i.kt)("inlineCode",{parentName:"p"},"_activeComponent")," is not ",(0,i.kt)("inlineCode",{parentName:"p"},"null"),", all interaction events routed to the view will automatically be passed to the handler that is the value of ",(0,i.kt)("inlineCode",{parentName:"p"},"_activeComponent"),". When the value of ",(0,i.kt)("inlineCode",{parentName:"p"},"_activeComponent")," is ",(0,i.kt)("inlineCode",{parentName:"p"},"null"),", all interaction events routed to the view will be ignored. Subclasses of ",(0,i.kt)("inlineCode",{parentName:"p"},"GtcView")," can change this default behavior by overriding the ",(0,i.kt)("inlineCode",{parentName:"p"},"onGtcInteractionEvent()")," method."),(0,i.kt)("h2",{id:"knobs-and-control-state"},"Knobs and Control State"),(0,i.kt)("p",null,'Each GTC has a set of "physical" hardware knobs which the user can manipulate to perform context-dependent actions. Horizontal GTCs have two knobs: the upper dual concentric knob and the lower "map" knob. Vertical GTCs have three knobs: the left "map" knob (actually a joystick, but we refer to it as a knob for consistency with the others), the center knob, and the right dual concentric knob. The label bar has a section for each knob which is used to display text that describes the current function of its corresponding knob.'),(0,i.kt)("p",null,"Each knob has an associated ",(0,i.kt)("em",{parentName:"p"},"control state")," which helps to define the knob's current function and what appears in the label bar for the knob. Control states can be any ",(0,i.kt)("inlineCode",{parentName:"p"},"string")," value. The control states of all knobs can be accessed via the ",(0,i.kt)("inlineCode",{parentName:"p"},"gtcKnobStates")," property of ",(0,i.kt)("inlineCode",{parentName:"p"},"GtcService"),". The base G3000 package automatically computes a control state for each knob, chosen from a set of pre-defined states (members of the ",(0,i.kt)("inlineCode",{parentName:"p"},"GtcDualKnobState"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"GtcCenterKnobState"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"GtcMapKnobState")," enums), depending on the current context. The default ",(0,i.kt)("a",{parentName:"p",href:"#interaction-events"},"interaction handler")," uses these states to determine how to handle knob interaction events, and the label bar uses them to determine what to display. For example, when the map knob state is equal to ",(0,i.kt)("inlineCode",{parentName:"p"},"GtcMapKnobState.MapNoPointer"),', the map knob can be used to change the range of the selected map and the label bar will display "-Range+" for the map knob.'),(0,i.kt)("p",null,"The default interaction handling and label bar rendering behavior defined by control states can be overridden in several different ways."),(0,i.kt)("p",null,"GTC views can choose to handle knob interaction events through the use of ",(0,i.kt)("a",{parentName:"p",href:"#interaction-events"},(0,i.kt)("inlineCode",{parentName:"a"},"_activeComponent")," or ",(0,i.kt)("inlineCode",{parentName:"a"},"onGtcInteractionEvent()"))," instead of deferring to the default interaction handler. Views can also override what appears in the label bar through ",(0,i.kt)("a",{parentName:"p",href:"#the-button-bar-and-label-bar"},(0,i.kt)("inlineCode",{parentName:"a"},"_sidebarState")),"."),(0,i.kt)("p",null,"To implement custom behavior that is not view-specific, ",(0,i.kt)("a",{parentName:"p",href:"/msfs-avionics-mirror/docs/g3000/gtc-plugins"},"GTC plugins")," can use the ",(0,i.kt)("inlineCode",{parentName:"p"},"getKnobStateOverrides()"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"getLabelBarHandlers()"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"onGtcInteractionEvent()")," methods. The ",(0,i.kt)("inlineCode",{parentName:"p"},"getKnobStateOverrides()")," method allows a plugin to inject control states for any knob that will replace the control state generated by the base G3000 package. Plugins can even inject control states that are not pre-defined by the base G3000 package. The ",(0,i.kt)("inlineCode",{parentName:"p"},"getLabelBarHandlers()")," method allows a plugin to override what appears on the label bar for any given knob control state. Finally, ",(0,i.kt)("inlineCode",{parentName:"p"},"onGtcInteractionEvent()")," can be used to handle any knob interaction event before it is routed to the default interaction handler."),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"Plugin knob state overrides, label bar handlers, and interaction event handling are all superceded by GTC view-level overrides. In other words, the active GTC view always gets first priority to decide how to handle interaction events and what appears on the label bar.")),(0,i.kt)("admonition",{type:"caution"},(0,i.kt)("p",{parentName:"admonition"},"Plugins that inject custom knob control states that are not defined in the base G3000 package ",(0,i.kt)("em",{parentName:"p"},"must")," also define label bar handlers that generate appropriate labels for those states. If the label bar cannot find a label to render for a control state, it will throw a runtime error.")))}h.isMDXComponent=!0}}]);