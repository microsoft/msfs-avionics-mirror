"use strict";(self.webpackChunkdocs_api=self.webpackChunkdocs_api||[]).push([["766732"],{388393:function(e,i,n){n.r(i),n.d(i,{metadata:()=>t,contentTitle:()=>o,default:()=>l,assets:()=>h,toc:()=>c,frontMatter:()=>r});var t=JSON.parse('{"id":"avionics/g3xtouch/ui-framework","title":"G3X Touch UI Framework","description":"UI Views and the View Stack","source":"@site/docs/avionics/g3xtouch/ui-framework.md","sourceDirName":"avionics/g3xtouch","slug":"/avionics/g3xtouch/ui-framework","permalink":"/msfs-avionics-mirror/2024/docs/avionics/g3xtouch/ui-framework","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":7,"frontMatter":{"sidebar_label":"UI Framework","sidebar_position":7},"sidebar":"sidebar","previous":{"title":"Plugins","permalink":"/msfs-avionics-mirror/2024/docs/avionics/g3xtouch/plugins"},"next":{"title":"Engine Display","permalink":"/msfs-avionics-mirror/2024/docs/avionics/g3xtouch/engine-display"}}'),s=n("785893"),a=n("250065");let r={sidebar_label:"UI Framework",sidebar_position:7},o="G3X Touch UI Framework",h={},c=[{value:"UI Views and the View Stack",id:"ui-views-and-the-view-stack",level:2},{value:"View Lifecycle",id:"view-lifecycle",level:2},{value:"Panes",id:"panes",level:2},{value:"The UI Service",id:"the-ui-service",level:2},{value:"Registering Views",id:"registering-views",level:2},{value:"Interaction Events",id:"interaction-events",level:2},{value:"Bezel Rotary Knob Labels",id:"bezel-rotary-knob-labels",level:2},{value:"MFD Main Pages",id:"mfd-main-pages",level:2},{value:"PFD Pages",id:"pfd-pages",level:2}];function d(e){let i={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",img:"img",li:"li",ol:"ol",p:"p",ul:"ul",...(0,a.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(i.header,{children:(0,s.jsx)(i.h1,{id:"g3x-touch-ui-framework",children:"G3X Touch UI Framework"})}),"\n",(0,s.jsx)(i.h2,{id:"ui-views-and-the-view-stack",children:"UI Views and the View Stack"}),"\n",(0,s.jsxs)(i.p,{children:["The G3X Touch's UI framework is centered around the concept of ",(0,s.jsx)(i.em,{children:"views"})," and the ",(0,s.jsx)(i.em,{children:"view stack"}),"."]}),"\n",(0,s.jsxs)(i.p,{children:[(0,s.jsx)(i.em,{children:"Views"})," render content to be displayed on the screen and handle user interactions with the touchscreen and bezel controls (knobs and buttons). All views are FS components that implement the interface ",(0,s.jsx)(i.a,{href:"/msfs-avionics-mirror/2024/docs/api/g3xtouchcommon/interfaces/UiView",children:(0,s.jsx)(i.code,{children:"UiView"})}),". There are two types of views: ",(0,s.jsx)(i.em,{children:"pages"})," and ",(0,s.jsx)(i.em,{children:"popups"}),". Only one page can be open at a time. Meanwhile, multiple popups can be open simultaneously."]}),"\n",(0,s.jsxs)(i.p,{children:["Open views are stored on the ",(0,s.jsx)(i.em,{children:"view stack"}),". The open page is located at the bottom of the stack, and popups are pushed onto the stack in the order in which they were opened. The view at the top of the stack is considered the ",(0,s.jsx)(i.em,{children:"active view"}),". Typically, all user interactions are routed to the active view."]}),"\n",(0,s.jsxs)(i.p,{children:["Each view stack has two layers: the ",(0,s.jsx)(i.em,{children:"main layer"})," and the ",(0,s.jsx)(i.em,{children:"overlay layer"}),". As the name implies, views rendered in the overlay layer always appear on top of any views in the main layer. The main layer contains the open page and may also contain popups. The overlay layer only contains popups."]}),"\n",(0,s.jsxs)(i.p,{children:["The view stack also maintains a history. Each time a view is pushed to the view stack, a new snapshot of the view stack state - a ",(0,s.jsx)(i.em,{children:"history state"})," - is created and pushed onto the ",(0,s.jsx)(i.em,{children:"history stack"}),". This allows previous history states to be restored via a 'Back' operation. The current state of the view stack is the ",(0,s.jsx)(i.em,{children:"active history state"}),"."]}),"\n",(0,s.jsxs)(i.p,{children:['Every view stack maintains the same "original" history state: the open page is a special view called the ',(0,s.jsx)(i.em,{children:"empty"})," view with no open popups. This history state, also referred to as the ",(0,s.jsx)(i.em,{children:"empty page state"}),", is always maintained by the view stack and cannot be discarded; attempting to execute a Back operation while the empty page state is active has no effect."]}),"\n",(0,s.jsx)(i.h2,{id:"view-lifecycle",children:"View Lifecycle"}),"\n",(0,s.jsx)(i.p,{children:"UI views have a complicated lifecycle, since they can move between many different states. Each view stack has its own instance of any particular view. Therefore, views of the same type in different stacks do not implicitly share state."}),"\n",(0,s.jsxs)(i.p,{children:["A view is considered ",(0,s.jsx)(i.em,{children:"in-use"})," when it appears in any history state that is currently in the history stack (including the active history state) and ",(0,s.jsx)(i.em,{children:"out-of-use"})," otherwise."]}),"\n",(0,s.jsxs)(i.p,{children:["A view is considered ",(0,s.jsx)(i.em,{children:"open"})," when it appears in the active history state and ",(0,s.jsx)(i.em,{children:"closed"})," otherwise. The ",(0,s.jsx)(i.code,{children:"onOpen()"})," and ",(0,s.jsx)(i.code,{children:"onClose()"})," lifecycle methods are called when a view switches between these two states."]}),"\n",(0,s.jsxs)(i.p,{children:["Finally, a view is considered ",(0,s.jsx)(i.em,{children:"active"})," or ",(0,s.jsx)(i.em,{children:"resumed"})," when it appears at the top of the active history state, and ",(0,s.jsx)(i.em,{children:"inactive"})," or ",(0,s.jsx)(i.em,{children:"paused"})," otherwise. The ",(0,s.jsx)(i.code,{children:"onResume()"})," and ",(0,s.jsx)(i.code,{children:"onPause()"})," lifecycle methods are called when a view switches between these two states. Each view stack only has one active view at a time, and it is with this view that the user primarily interacts."]}),"\n",(0,s.jsxs)(i.p,{children:["Views are always created initially in an ",(0,s.jsx)(i.em,{children:"out of use"})," state. Views can also have different lifespans, determined by their ",(0,s.jsx)(i.em,{children:"lifecycle policy"}),". The different possible lifecycle policies are included as members of the ",(0,s.jsx)(i.code,{children:"UiViewLifecyclePolicy"})," enum:"]}),"\n",(0,s.jsxs)(i.ul,{children:["\n",(0,s.jsx)(i.li,{children:"Static: The view is created immediately when it is registered (see below) and is never destroyed. Should only be used by views that have persistent state and need to be created when the G3X Touch instrument is first initialized."}),"\n",(0,s.jsx)(i.li,{children:"Persistent: The view is created immediately before the first time it transitions to an in-use state and is never destroyed. Should be used by views that have persistent state."}),"\n",(0,s.jsx)(i.li,{children:"Transient: The view is created immediately before the first time it transitions to an in-use state and is destroyed when it transitions back to an out-of-use state. Should be used by views that do not have persistent state."}),"\n"]}),"\n",(0,s.jsx)(i.admonition,{type:"tip",children:(0,s.jsx)(i.p,{children:"Views have a non-negligible memory footprint when created. Therefore, it is recommended that the transient lifecycle policy be used whenever possible to reduce memory load and increase stability in memory-limited scenarios oftentimes seen in low-spec PCs and the XBox consoles."})}),"\n",(0,s.jsxs)(i.admonition,{type:"warning",children:[(0,s.jsxs)(i.p,{children:["Ensure that transient views properly release all resources they use when they are destroyed to avoid memory leaks. Cleanup code should be included in the view's ",(0,s.jsx)(i.code,{children:"destroy()"})," method."]}),(0,s.jsxs)(i.p,{children:["It is also good practice to ensure ",(0,s.jsx)(i.em,{children:"all"})," views contain cleanup code, regardless of their lifecycle policy. This is because a mod or plugin can theoretically replace any registered view with another one (see ",(0,s.jsx)(i.a,{href:"#registering-views",children:"Registering Views"}),")."]})]}),"\n",(0,s.jsx)(i.h2,{id:"panes",children:"Panes"}),"\n",(0,s.jsxs)(i.p,{children:["Each GDU has two panes: the PFD pane and the MFD pane. Each pane maintains its own independent view stack. One of these panes is always visible, while the other can be either visible or hidden depending on whether the GDU is in Fullscreen or Splitscreen mode. The always-visible pane is called the ",(0,s.jsx)(i.em,{children:"main pane"})," while the other is called the ",(0,s.jsx)(i.em,{children:"splitscreen pane"}),". For PFD GDUs, the PFD pane is the main pane. For MFD GDUs, the MFD pane is the main pane."]}),"\n",(0,s.jsx)(i.p,{children:"When a pane is hidden, its view stack reverts to the empty page state."}),"\n",(0,s.jsx)(i.h2,{id:"the-ui-service",children:"The UI Service"}),"\n",(0,s.jsxs)(i.p,{children:["Each GDU contains one instance of ",(0,s.jsx)(i.a,{href:"/msfs-avionics-mirror/2024/docs/api/g3xtouchcommon/classes/UiService",children:(0,s.jsx)(i.code,{children:"UiService"})}),", which is the class that controls all view-related state and logic. Switching between Fullscreen and Splitscreen modes, opening and closing views - all of these actions and more are handled by ",(0,s.jsx)(i.code,{children:"UiService"}),". All views are passed a reference to their parent ",(0,s.jsx)(i.code,{children:"UiService"})," instance as a prop."]}),"\n",(0,s.jsx)(i.h2,{id:"registering-views",children:"Registering Views"}),"\n",(0,s.jsxs)(i.p,{children:["Views must be registered with ",(0,s.jsx)(i.code,{children:"UiService"})," before they can be used. Each view is registered under a unique string key, which is then used to open and retrieve the view from ",(0,s.jsx)(i.code,{children:"UiService"}),". Views are registered on a per-view stack layer basis; different views may be registered under the same key to different view stacks and even to different layers within the same view stack. Finally, views are registered as factories - functions that create and return the registered view as a ",(0,s.jsx)(i.code,{children:"VNode"})," - instead of directly as instances of the view. This is to allow ",(0,s.jsx)(i.code,{children:"UiService"})," to handle the process of creating views in accordance with their lifecycle policies."]}),"\n",(0,s.jsx)(i.p,{children:"If a view is registered to a view stack layer under a key that is already registered to that layer, then the new view will replace the existing view registered under that key. If an instance of the existing view has already been created, it will be destroyed when it is replaced."}),"\n",(0,s.jsx)(i.admonition,{type:"info",children:(0,s.jsxs)(i.p,{children:["The ",(0,s.jsx)(i.a,{href:"/msfs-avionics-mirror/2024/docs/api/g3xtouchcommon/enumerations/UiViewKeys",children:(0,s.jsx)(i.code,{children:"UiViewKeys"})})," enum contains all UI view keys defined and used by the base G3X Touch."]})}),"\n",(0,s.jsxs)(i.p,{children:["UI views can be registered by plugins using the ",(0,s.jsx)(i.a,{href:"/msfs-avionics-mirror/2024/docs/avionics/g3xtouch/plugins#ui-views",children:(0,s.jsx)(i.code,{children:"registerUiViews()"})})," method."]}),"\n",(0,s.jsx)(i.h2,{id:"interaction-events",children:"Interaction Events"}),"\n",(0,s.jsxs)(i.p,{children:['The user interacts with the GDU in two ways: (1) through "touch" (mouse) events, and (2) through manipulating the GDU\'s "physical" knobs and buttons. Touch events are handled by various components rendered on the GDU screen that simulate touchscreen buttons, sliders, touchpads, etc. Meanwhile, the "physical" events are handled using the ',(0,s.jsx)(i.code,{children:"UiInteractionEvent"})," API."]}),"\n",(0,s.jsxs)(i.p,{children:["When a user manipulates a physical knob or button, the interaction generates a ",(0,s.jsx)(i.code,{children:"UiInteractionEvent"}),". The event is then routed to a series of handlers implementing the ",(0,s.jsx)(i.code,{children:"UiInteractionHandler"})," interface. As each handler is notified of the event, it can either choose to handle the event or do nothing. If the event is handled, then no further handlers will be notified of the event. If the event is not handled, then the next handler is notified and the process repeats."]}),"\n",(0,s.jsx)(i.p,{children:"The event routing path depends on whether the event originated from a knob or a button. For buttons, the path is always the same:"}),"\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsx)(i.li,{children:"The active UI view in the MFD pane."}),"\n",(0,s.jsx)(i.li,{children:"The active UI view in the PFD pane."}),"\n",(0,s.jsx)(i.li,{children:"The default interaction handler defined in the UI service."}),"\n"]}),"\n",(0,s.jsxs)(i.p,{children:["For knobs, the path depends on which knob was manipulated. If the ",(0,s.jsx)(i.em,{children:"single"})," knob was manipulated (only found on GDU 470 units, which are not currently supported), then the path is the same as that for buttons (above). If the ",(0,s.jsx)(i.em,{children:"left"})," or ",(0,s.jsx)(i.em,{children:"right"})," knob was manipulated (only found on GDU 460 units), then the path is as follows:"]}),"\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsxs)(i.li,{children:["The active UI view in the pane displayed on the same side as the manipulated knob (this can be ",(0,s.jsx)(i.em,{children:"either"})," the PFD or MFD pane for either knob depending on how the user has configured the GDU). If the GDU is in Fullscreen mode, then the visible pane receives events from both left and right knobs."]}),"\n",(0,s.jsx)(i.li,{children:"The default interaction handler defined in the UI service."}),"\n"]}),"\n",(0,s.jsx)(i.p,{children:'Because left and right knob events are only routed to the pane that is "supposed to" handle them, views and other interaction handlers invoked by views need not concern themselves with whether they are in the left or right pane when receiving a left/right knob event. They can simply handle (or not) each knob event "as-is" when it is received.'}),"\n",(0,s.jsxs)(i.p,{children:["The ",(0,s.jsx)(i.a,{href:"/msfs-avionics-mirror/2024/docs/api/g3xtouchcommon/classes/UiInteractionUtils",children:(0,s.jsx)(i.code,{children:"UiInteractionUtils"})})," and ",(0,s.jsx)(i.a,{href:"/msfs-avionics-mirror/2024/docs/api/g3xtouchcommon/classes/UiKnobUtils",children:(0,s.jsx)(i.code,{children:"UiKnobUtils"})})," classes contain utility methods for working with the interaction events."]}),"\n",(0,s.jsx)(i.h2,{id:"bezel-rotary-knob-labels",children:"Bezel Rotary Knob Labels"}),"\n",(0,s.jsx)(i.p,{children:"Each GDU displays a contextual label for each bezel rotary knob in the status bar on the bottom of the screen. These labels are meant to describe the current functionality of the knobs."}),"\n",(0,s.jsx)(i.p,{children:(0,s.jsx)(i.img,{alt:"Knob Labels",src:n(9029).Z+"",width:"274",height:"111"})}),"\n",(0,s.jsxs)(i.p,{children:["Views can control what appears for each label using the ",(0,s.jsx)(i.code,{children:"knobLabelState"})," property defined by ",(0,s.jsx)(i.code,{children:"UiView"}),". Each knob has three actions that can each have its own label text: outer rotate, inner rotate, and inner push. The ",(0,s.jsx)(i.code,{children:"knobLabelState"})," property is a map of knob actions to label text requested by the view. Knob actions are represented by members of the ",(0,s.jsx)(i.a,{href:"/msfs-avionics-mirror/2024/docs/api/g3xtouchcommon/enumerations/UiKnobId",children:(0,s.jsx)(i.code,{children:"UiKnobId"})})," enum. Each status bar knob label is automatically formatted based on the requested label text for each of the knob's actions."]}),"\n",(0,s.jsx)(i.p,{children:"The requested label state defined by a view is automatically applied to the appropriate label when the view becomes the active view of its view stack. Therefore, just as with handling knob interaction events, views need not worry about whether they are the active view or are in the left or right pane when requesting a specific knob label state. They can request label state as if they have control of all knobs at all times, and the UI service will ensure the requested label states are routed only to the appropriate labels."}),"\n",(0,s.jsx)(i.h2,{id:"mfd-main-pages",children:"MFD Main Pages"}),"\n",(0,s.jsxs)(i.p,{children:["The MFD pane has a special UI view called the ",(0,s.jsx)(i.em,{children:"main view"}),". This view is opened as a page in the MFD view stack and displays the ",(0,s.jsx)(i.em,{children:"MFD main pages"}),". MFD main pages are components that implement the interface ",(0,s.jsx)(i.a,{href:"/msfs-avionics-mirror/2024/docs/api/g3xtouchcommon/interfaces/MfdPage",children:(0,s.jsx)(i.code,{children:"MfdPage"})}),". While the main view is open and active, the user can select one of several MFD main pages to be displayed, such as the Map page or the Active Flight Plan page."]}),"\n",(0,s.jsx)(i.p,{children:"Here is an example of the main view with the Map page selected and displayed."}),"\n",(0,s.jsx)(i.p,{children:(0,s.jsx)(i.img,{alt:"MFD Main View",src:n(872327).Z+"",width:"330",height:"417"})}),"\n",(0,s.jsxs)(i.p,{children:["MFD main pages have a lifecycle logic that is similar to that of UI views. A main page is ",(0,s.jsx)(i.em,{children:"staged"})," when it is selected by a user and ",(0,s.jsx)(i.em,{children:"unstaged"})," otherwise. After a page becomes staged and its parent main view is open, there is a short delay before the page is displayed. The page is ",(0,s.jsx)(i.em,{children:"open"})," when it is displayed, and ",(0,s.jsx)(i.em,{children:"closed"})," when it is not displayed. A main page can only be open when its parent main view is open. Finally, the open main page is ",(0,s.jsx)(i.em,{children:"resumed"})," when its parent main view is resumed and ",(0,s.jsx)(i.em,{children:"paused"})," when its parent main view is paused. Like with UI views, lifecycle methods are called when a main page transitions between any of these lifecycle states."]}),"\n",(0,s.jsx)(i.p,{children:"MFD main pages also handle UI interaction events and can request knob label states. While the main view is the active view, it will route all interaction events to the open and resumed main page before attempting to handle the events itself. The main view also passes  the requested label state of its open main page through to the UI service. If the main view and its open main page both request a label for the same knob action, the label requested by the main page takes priority."}),"\n",(0,s.jsxs)(i.p,{children:["MFD main pages must be registered before they can be selected and displayed. Registration is handled through a registrar (",(0,s.jsx)(i.a,{href:"/msfs-avionics-mirror/2024/docs/api/g3xtouchcommon/classes/MfdMainPageRegistrar",children:(0,s.jsx)(i.code,{children:"MfdMainPageRegistrar"})}),"). Like with views, main pages are registered using factories. Unlike views, however, main pages all use one lifecycle policy: main pages are created immediately before the first time they are staged and are never destroyed."]}),"\n",(0,s.jsx)(i.p,{children:"If an MFD main page is registered under a key that is already registered, then the new page will replace the existing page registered under that key."}),"\n",(0,s.jsx)(i.admonition,{type:"info",children:(0,s.jsxs)(i.p,{children:["The ",(0,s.jsx)(i.a,{href:"/msfs-avionics-mirror/2024/docs/api/g3xtouchcommon/enumerations/MfdMainPageKeys",children:(0,s.jsx)(i.code,{children:"MfdMainPageKeys"})})," enum contains all MFD main page keys defined and used by the base G3X Touch."]})}),"\n",(0,s.jsxs)(i.p,{children:["MFD main pages can be registered by plugins using the ",(0,s.jsx)(i.a,{href:"/msfs-avionics-mirror/2024/docs/avionics/g3xtouch/plugins#mfd-main-pages",children:(0,s.jsx)(i.code,{children:"registerMfdMainPages()"})})," method."]}),"\n",(0,s.jsx)(i.h2,{id:"pfd-pages",children:"PFD Pages"}),"\n",(0,s.jsxs)(i.p,{children:["The default page on the PFD pane is the PFD instruments page, whose key is ",(0,s.jsx)(i.code,{children:"UiViewKeys.PfdInstruments"}),". On an MFD GDU, the user can configure the PFD pane to display other pages. These pages implement the ",(0,s.jsx)(i.code,{children:"UiView"})," interface. However, instead of being directly registered with ",(0,s.jsx)(i.code,{children:"UiService"}),", PFD pages are registered through a registrar (",(0,s.jsx)(i.a,{href:"/msfs-avionics-mirror/2024/docs/api/g3xtouchcommon/classes/PfdPageRegistrar",children:(0,s.jsx)(i.code,{children:"PfdPageRegistrar"})}),"). Once a PFD page is registered, users will be able to select the page via the Display Setup menu on MFD GDUs:"]}),"\n",(0,s.jsx)(i.p,{children:(0,s.jsx)(i.img,{alt:"PFD Page Select",src:n(666269).Z+"",width:"466",height:"294"})}),"\n",(0,s.jsx)(i.p,{children:"If a PFD page is registered under a key that is already registered, then the new page will replace the existing page registered under that key. If an instance of the existing page has already been created, then it will be destroyed when it is replaced."}),"\n",(0,s.jsxs)(i.p,{children:["PFD pages can be registered by plugins using the ",(0,s.jsx)(i.a,{href:"/msfs-avionics-mirror/2024/docs/avionics/g3xtouch/plugins#pfd-pages",children:(0,s.jsx)(i.code,{children:"registerPfdPages()"})})," method."]})]})}function l(e={}){let{wrapper:i}={...(0,a.a)(),...e.components};return i?(0,s.jsx)(i,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},872327:function(e,i,n){n.d(i,{Z:function(){return t}});let t=n.p+"assets/images/mfd-main-view-cfc221dc8adb67774251c324e9618486.jpg"},666269:function(e,i,n){n.d(i,{Z:function(){return t}});let t=n.p+"assets/images/pfd-page-select-f9385e5102cd7136485666eef8af0ca1.jpg"},9029:function(e,i,n){n.d(i,{Z:function(){return t}});let t=n.p+"assets/images/status-bar-knob-label-031c67b5116f19f41f1b5f6ac8cdb9a8.jpg"},250065:function(e,i,n){n.d(i,{Z:function(){return o},a:function(){return r}});var t=n(667294);let s={},a=t.createContext(s);function r(e){let i=t.useContext(a);return t.useMemo(function(){return"function"==typeof e?e(i):{...i,...e}},[i,e])}function o(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),t.createElement(a.Provider,{value:i},e.children)}}}]);