"use strict";(self.webpackChunkdocs_api=self.webpackChunkdocs_api||[]).push([["141397"],{138956:function(e,n,r){r.r(n),r.d(n,{metadata:()=>i,contentTitle:()=>c,default:()=>a,assets:()=>l,toc:()=>o,frontMatter:()=>s});var i=JSON.parse('{"id":"api/framework/classes/JoinGreatCircleToPointVectorBuilder","title":"Class: JoinGreatCircleToPointVectorBuilder","description":"Builds vectors representing paths connecting initial great-circle paths to final great-circle paths terminating at","source":"@site/docs/api/framework/classes/JoinGreatCircleToPointVectorBuilder.md","sourceDirName":"api/framework/classes","slug":"/api/framework/classes/JoinGreatCircleToPointVectorBuilder","permalink":"/msfs-avionics-mirror/2024/docs/api/framework/classes/JoinGreatCircleToPointVectorBuilder","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"sidebar","previous":{"title":"JetFadec","permalink":"/msfs-avionics-mirror/2024/docs/api/framework/classes/JetFadec"},"next":{"title":"KdTree","permalink":"/msfs-avionics-mirror/2024/docs/api/framework/classes/KdTree"}}'),t=r("785893"),d=r("250065");let s={},c="Class: JoinGreatCircleToPointVectorBuilder",l={},o=[{value:"Constructors",id:"constructors",level:2},{value:"new JoinGreatCircleToPointVectorBuilder()",id:"new-joingreatcircletopointvectorbuilder",level:3},{value:"Returns",id:"returns",level:4},{value:"Methods",id:"methods",level:2},{value:"build()",id:"build",level:3},{value:"Parameters",id:"parameters",level:4},{value:"Returns",id:"returns-1",level:4},{value:"Throws",id:"throws",level:4},{value:"Defined in",id:"defined-in",level:4}];function h(e){let n={a:"a",blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,d.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"class-joingreatcircletopointvectorbuilder",children:"Class: JoinGreatCircleToPointVectorBuilder"})}),"\n",(0,t.jsx)(n.p,{children:"Builds vectors representing paths connecting initial great-circle paths to final great-circle paths terminating at\ndefined end points."}),"\n",(0,t.jsx)(n.h2,{id:"constructors",children:"Constructors"}),"\n",(0,t.jsx)(n.h3,{id:"new-joingreatcircletopointvectorbuilder",children:"new JoinGreatCircleToPointVectorBuilder()"}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"new JoinGreatCircleToPointVectorBuilder"}),"(): ",(0,t.jsx)(n.a,{href:"/msfs-avionics-mirror/2024/docs/api/framework/classes/JoinGreatCircleToPointVectorBuilder",children:(0,t.jsx)(n.code,{children:"JoinGreatCircleToPointVectorBuilder"})})]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"returns",children:"Returns"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.a,{href:"/msfs-avionics-mirror/2024/docs/api/framework/classes/JoinGreatCircleToPointVectorBuilder",children:(0,t.jsx)(n.code,{children:"JoinGreatCircleToPointVectorBuilder"})})}),"\n",(0,t.jsx)(n.h2,{id:"methods",children:"Methods"}),"\n",(0,t.jsx)(n.h3,{id:"build",children:"build()"}),"\n",(0,t.jsxs)(n.blockquote,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"build"}),"(",(0,t.jsx)(n.code,{children:"vectors"}),", ",(0,t.jsx)(n.code,{children:"index"}),", ",(0,t.jsx)(n.code,{children:"start"}),", ",(0,t.jsx)(n.code,{children:"startPath"}),", ",(0,t.jsx)(n.code,{children:"end"}),", ",(0,t.jsx)(n.code,{children:"endPath"}),", ",(0,t.jsx)(n.code,{children:"desiredTurnDirection"}),"?, ",(0,t.jsx)(n.code,{children:"minTurnRadius"}),"?, ",(0,t.jsx)(n.code,{children:"preferSingleTurn"}),"?, ",(0,t.jsx)(n.code,{children:"allowDirectFallback"}),"?, ",(0,t.jsx)(n.code,{children:"intersection"}),"?, ",(0,t.jsx)(n.code,{children:"flags"}),"?, ",(0,t.jsx)(n.code,{children:"includeTurnToCourseFlag"}),"?, ",(0,t.jsx)(n.code,{children:"includeDirectFlag"}),"?, ",(0,t.jsx)(n.code,{children:"includeInterceptFlag"}),"?, ",(0,t.jsx)(n.code,{children:"heading"}),"?, ",(0,t.jsx)(n.code,{children:"isHeadingTrue"}),"?): ",(0,t.jsx)(n.code,{children:"number"})]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Builds a sequence of vectors representing a path from a defined start point and initial course that turns and\njoins a great-circle path that terminates at a defined end point."}),"\n",(0,t.jsxs)(n.p,{children:["This method will first attempt to connect the starting point and final path with a single constant-radius turn\nof at least the minimum turn radius and in the desired direction that joins the final path before the end point.\nIf this is not possible, then what happens next depends on the ",(0,t.jsx)(n.code,{children:"preferSingleTurn"})," argument:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["If it is ",(0,t.jsx)(n.code,{children:"true"}),", then another path connecting the starting point and final path with a single constant-radius\nturn will be computed - this path will respect the minimum turn radius but not necessarily the desired turn\ndirection."]}),"\n",(0,t.jsxs)(n.li,{children:["If it is ",(0,t.jsx)(n.code,{children:"false"}),", then a path to intercept the final path at a 45-degree angle will be computed. If such a path\nis not possible or if the intercept point lies after the end point, and ",(0,t.jsx)(n.code,{children:"allowDirectFallback"})," is ",(0,t.jsx)(n.code,{children:"true"}),", then a\ndirect path to the end point will be computed. If ",(0,t.jsx)(n.code,{children:"allowDirectFallback"})," is ",(0,t.jsx)(n.code,{children:"false"})," and all attempts to compute a\npath have failed, then no vectors will be built."]}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"parameters",children:"Parameters"}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Parameter"}),(0,t.jsx)(n.th,{children:"Type"}),(0,t.jsx)(n.th,{children:"Default value"}),(0,t.jsx)(n.th,{children:"Description"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"vectors"})}),(0,t.jsxs)(n.td,{children:[(0,t.jsx)(n.a,{href:"/msfs-avionics-mirror/2024/docs/api/framework/interfaces/FlightPathVector",children:(0,t.jsx)(n.code,{children:"FlightPathVector"})}),"[]"]}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"undefined"})}),(0,t.jsx)(n.td,{children:"The flight path vector array to which to add the vectors."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"index"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"number"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"undefined"})}),(0,t.jsx)(n.td,{children:"The index in the array at which to add the vectors."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"start"})}),(0,t.jsxs)(n.td,{children:[(0,t.jsx)(n.code,{children:"Readonly"}),"<",(0,t.jsx)(n.code,{children:"Omit"}),"<",(0,t.jsx)(n.code,{children:"Float64Array"}),", ",(0,t.jsx)(n.code,{children:'"set"'})," | ",(0,t.jsx)(n.code,{children:'"sort"'})," | ",(0,t.jsx)(n.code,{children:'"copyWithin"'}),">> | ",(0,t.jsx)(n.a,{href:"/msfs-avionics-mirror/2024/docs/api/framework/interfaces/LatLonInterface",children:(0,t.jsx)(n.code,{children:"LatLonInterface"})})]}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"undefined"})}),(0,t.jsx)(n.td,{children:"The start point."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"startPath"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.a,{href:"/msfs-avionics-mirror/2024/docs/api/framework/classes/GeoCircle",children:(0,t.jsx)(n.code,{children:"GeoCircle"})})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"undefined"})}),(0,t.jsx)(n.td,{children:"A GeoCircle that defines the initial course. Must be a great circle and must include the start point."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"end"})}),(0,t.jsxs)(n.td,{children:[(0,t.jsx)(n.code,{children:"Readonly"}),"<",(0,t.jsx)(n.code,{children:"Omit"}),"<",(0,t.jsx)(n.code,{children:"Float64Array"}),", ",(0,t.jsx)(n.code,{children:'"set"'})," | ",(0,t.jsx)(n.code,{children:'"sort"'})," | ",(0,t.jsx)(n.code,{children:'"copyWithin"'}),">> | ",(0,t.jsx)(n.a,{href:"/msfs-avionics-mirror/2024/docs/api/framework/interfaces/LatLonInterface",children:(0,t.jsx)(n.code,{children:"LatLonInterface"})})]}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"undefined"})}),(0,t.jsx)(n.td,{children:"The end point."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"endPath"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.a,{href:"/msfs-avionics-mirror/2024/docs/api/framework/classes/GeoCircle",children:(0,t.jsx)(n.code,{children:"GeoCircle"})})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"undefined"})}),(0,t.jsx)(n.td,{children:"A GeoCircle that defines the final course. Must be a great circle and must include the end point."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsxs)(n.td,{children:[(0,t.jsx)(n.code,{children:"desiredTurnDirection"}),"?"]}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.a,{href:"/msfs-avionics-mirror/2024/docs/api/framework/type-aliases/VectorTurnDirection",children:(0,t.jsx)(n.code,{children:"VectorTurnDirection"})})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"undefined"})}),(0,t.jsx)(n.td,{children:"The desired initial turn direction. If not defined, then the most efficient turn direction that satisfies the constraints will be chosen."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsxs)(n.td,{children:[(0,t.jsx)(n.code,{children:"minTurnRadius"}),"?"]}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"number"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"undefined"})}),(0,t.jsx)(n.td,{children:"The minimum turn radius, in meters. Defaults to 0."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsxs)(n.td,{children:[(0,t.jsx)(n.code,{children:"preferSingleTurn"}),"?"]}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"boolean"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"false"})}),(0,t.jsxs)(n.td,{children:["Whether to prefer flight path solutions that consist of a single constant-radius turn from the initial to final course. Defaults to ",(0,t.jsx)(n.code,{children:"false"}),"."]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsxs)(n.td,{children:[(0,t.jsx)(n.code,{children:"allowDirectFallback"}),"?"]}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"boolean"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"true"})}),(0,t.jsxs)(n.td,{children:["Whether the computed path should fall back to a direct path to the end point if the final path cannot be joined before the end point. Defaults to ",(0,t.jsx)(n.code,{children:"true"}),"."]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsxs)(n.td,{children:[(0,t.jsx)(n.code,{children:"intersection"}),"?"]}),(0,t.jsxs)(n.td,{children:[(0,t.jsx)(n.code,{children:"Readonly"}),"<",(0,t.jsx)(n.code,{children:"Omit"}),"<",(0,t.jsx)(n.code,{children:"Float64Array"}),", ",(0,t.jsx)(n.code,{children:'"set"'})," | ",(0,t.jsx)(n.code,{children:'"sort"'})," | ",(0,t.jsx)(n.code,{children:'"copyWithin"'}),">>"]}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"undefined"})}),(0,t.jsx)(n.td,{children:"The point of intersection between the start and end paths that lies closest to the start point. If not defined, then it will be calculated by this method."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsxs)(n.td,{children:[(0,t.jsx)(n.code,{children:"flags"}),"?"]}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"number"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"0"})}),(0,t.jsx)(n.td,{children:"The flags to set on all built vectors. Defaults to none (0)."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsxs)(n.td,{children:[(0,t.jsx)(n.code,{children:"includeTurnToCourseFlag"}),"?"]}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"boolean"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"true"})}),(0,t.jsxs)(n.td,{children:["Whether to include the ",(0,t.jsx)(n.code,{children:"TurnToCourse"})," flag on the vectors that comprise turns. Defaults to ",(0,t.jsx)(n.code,{children:"true"}),"."]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsxs)(n.td,{children:[(0,t.jsx)(n.code,{children:"includeDirectFlag"}),"?"]}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"boolean"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"true"})}),(0,t.jsxs)(n.td,{children:["Whether to include the ",(0,t.jsx)(n.code,{children:"Direct"})," flag on all built vectors when falling back to a direct path. Defaults to ",(0,t.jsx)(n.code,{children:"true"}),"."]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsxs)(n.td,{children:[(0,t.jsx)(n.code,{children:"includeInterceptFlag"}),"?"]}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"boolean"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"true"})}),(0,t.jsxs)(n.td,{children:["Whether to include the ",(0,t.jsx)(n.code,{children:"InterceptCourse"})," flag on all built vectors when building an intercept path. Defaults to ",(0,t.jsx)(n.code,{children:"true"}),"."]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsxs)(n.td,{children:[(0,t.jsx)(n.code,{children:"heading"}),"?"]}),(0,t.jsxs)(n.td,{children:[(0,t.jsx)(n.code,{children:"null"})," | ",(0,t.jsx)(n.code,{children:"number"})]}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"null"})}),(0,t.jsxs)(n.td,{children:["The heading-to-fly to assign to all built vectors, in degrees, or ",(0,t.jsx)(n.code,{children:"null"})," if no heading is to be assigned. Defaults to ",(0,t.jsx)(n.code,{children:"null"}),"."]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsxs)(n.td,{children:[(0,t.jsx)(n.code,{children:"isHeadingTrue"}),"?"]}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"boolean"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"false"})}),(0,t.jsxs)(n.td,{children:["Whether the heading-to-fly assigned to built vectors is relative to true north instead of magnetic north. Defaults to ",(0,t.jsx)(n.code,{children:"false"}),"."]})]})]})]}),"\n",(0,t.jsx)(n.h4,{id:"returns-1",children:"Returns"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.code,{children:"number"})}),"\n",(0,t.jsx)(n.p,{children:"The number of vectors that were built and added to the array."}),"\n",(0,t.jsx)(n.h4,{id:"throws",children:"Throws"}),"\n",(0,t.jsxs)(n.p,{children:["Error if ",(0,t.jsx)(n.code,{children:"startPath"})," or ",(0,t.jsx)(n.code,{children:"endPath"})," is not a great circle."]}),"\n",(0,t.jsx)(n.h4,{id:"defined-in",children:"Defined in"}),"\n",(0,t.jsx)(n.p,{children:"src/sdk/flightplan/flightpath/vectorbuilders/JoinGreatCircleToPointVectorBuilder.ts:74"})]})}function a(e={}){let{wrapper:n}={...(0,d.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}},250065:function(e,n,r){r.d(n,{Z:function(){return c},a:function(){return s}});var i=r(667294);let t={},d=i.createContext(t);function s(e){let n=i.useContext(d);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:s(e.components),i.createElement(d.Provider,{value:n},e.children)}}}]);