import { MappedSubject, MutableSubscribable, Subject, Subscribable, SubscribableUtils, TextInputField, TextInputFieldOptions } from '@microsoft/msfs-sdk';

import { UnsFmcPage } from '../UnsFmcPage';
import { UnsFocusableField, UnsFocusableFieldOptions, UnsFocusableFieldUtils } from './UnsFocusableField';

/**
 * Wraps a `T` into a tuple also containing a field's highlight state
 */
export type UnsFieldState<T> = readonly [value: T, isHighlighted: boolean];

/**
 * Wraps a `T` into a tuple also containing a field's highlight state and typed text
 */
export type WritableUnsFieldState<T> = readonly [value: T, isHighlighted: boolean, typedText: string];

/**
 * Options for {@link UnsTextInputField}
 */
export interface UnsTextInputFieldOptions<U, W> extends TextInputFieldOptions<WritableUnsFieldState<U>, W>, UnsFocusableFieldOptions {
  /** The maximum amount of characters that can be entered in this input */
  maxInputCharacterCount: number | (() => number) | Subscribable<number>,

  /**
   * Whether the field accepts an empty string as input. If this is `true`, the field will be given input before `onEnterPressed` is called
   * when nothing is typed into the scratchpad. Defaults to `false`.
   */
  acceptEmptyInput?: boolean,

  /**
   * Sets a choice of character to be appended to the text typed in a field in lieu of the plus/minus functionality
   */
  interpretPlusMinusAs?: '.' | '/',

  /**
   * Handler for a TYPING key pressed when the cursor is on the component.
   * `newText` is the text generated by the event (typically a single character).
   * `oldText` is the text typed up until this point.
   *
   * Called before the `UnsFmcScreen`'s typing handler sets the `currentCursorPosition`'s `typedText` property,
   * and allows the typed text to be modified or ignored altogether (thereby avoiding a call to `format`).
   *
   * **Note:** For this callback to be fired, the cursor must already be on the component.
   *
   * If the return value is:
   * - `true`  -> the handler is considered to have handled the call, and no further handlers will be called.
   * - `false` -> the handler is not considered to have handled the call, and the next handlers will be called.
   * - `string` -> the handler is not considered to have handled the call, and the returned string will replace the typed character.
   */
  onTextTyped?: (newText: string, oldText: string) => boolean | Promise<boolean> | string | Promise<string>;
}

/**
 * A {@link TextInputField} specific to the UNS-1
 */
export class UnsTextInputField<U, W = U> extends TextInputField<WritableUnsFieldState<U>, W> implements UnsFocusableField<U> {
  public readonly isUnsFocusableField = true;

  public isHighlighted = Subject.create(false);

  public typedText = Subject.create('');

  /** @inheritDoc */
  constructor(readonly page: UnsFmcPage, readonly options: UnsTextInputFieldOptions<U, W>) {
    super(page, options);

    this.page.addBinding(this.isHighlighted.sub(() => this.invalidate()));
    this.page.addBinding(this.typedText.sub(() => this.invalidate()));
  }

  /**
   * Binds the input field to a subscribable (one-way) while wrapping it into a `Subscribable<UnsFieldState>`
   *
   * @param sub the `Subscribable<T>`
   *
   * @returns the instance of this {@link UnsTextInputField}
   */
  public bindWrappedData(sub: Subscribable<U> | MutableSubscribable<U, W>): this {
    const mappedSubject = MappedSubject.create(sub, this.isHighlighted, this.typedText);

    this.page.addBinding(mappedSubject);
    this.page.addBinding(mappedSubject.sub((value) => this.takeValue(value, true), true));

    if (SubscribableUtils.isMutableSubscribable(sub)) {
      this.page.addBinding(this.valueChanged.on((sender, data) => sub.set(data)));
    }

    return this;
  }

  /** @inheritDoc */
  public async handleEnter(): Promise<boolean> {
    if (this.options.onEnterPressed) {
      const handleByOptions = await this.options.onEnterPressed();

      if (UnsFocusableFieldUtils.isUnsFocusableField(handleByOptions)) {
        this.page.screen.tryFocusField(handleByOptions);
        return true;
      }

      if (handleByOptions === true) {
        this.page.screen.interruptCursorPath();
        return true;
      }
    }

    return this.onHandleEnter();
  }

  /**
   * Handles an ENTER key received by the component
   *
   * @returns whether the key was handled or not
   */
  protected onHandleEnter(): boolean {
    return false;
  }

  /** @inheritDoc */
  public async handlePlusMinus(): Promise<boolean> {
    let maxInputChars = 0;
    if (typeof this.options.maxInputCharacterCount === 'number') {
      maxInputChars = this.options.maxInputCharacterCount;
    } else if (typeof this.options.maxInputCharacterCount === 'function') {
      maxInputChars = this.options.maxInputCharacterCount();
    } else {
      maxInputChars = this.options.maxInputCharacterCount.get();
    }

    if (this.options.onPlusMinusPressed) {
      const handleByOptions = await this.options.onPlusMinusPressed(this.typedText.get());

      if (handleByOptions === true) {
        return true;
      } else if (typeof handleByOptions === 'string') {
        this.typedText.set(handleByOptions);
      }
    } else if (this.options.interpretPlusMinusAs !== undefined && this.typedText.get().length < maxInputChars) {
      this.typedText.set(this.typedText.get() + this.options.interpretPlusMinusAs);
    }

    return this.onHandlePlusMinus();
  }

  /**
   * Handles a +/- key received by the component
   *
   * @returns whether the key was handled or not
   */
  protected onHandlePlusMinus(): boolean {
    return false;
  }

  /** @inheritDoc */
  public async handleList(): Promise<boolean> {
    if (this.options.onListPressed) {
      const handleByOptions = await this.options.onListPressed();

      if (handleByOptions === true) {
        return true;
      }
    }

    return this.onHandleList();
  }

  /**
   * Handles a LIST key received by the component
   *
   * @returns whether the key was handled or not
   */
  protected onHandleList(): boolean {
    return false;
  }

  /**
   * Handles a TYPING key received by the component
   *
   * Do NOT override this method - override {@link onHandleTyping} instead
   *
   * @param newText The text generated by the event (typically a single character).
   * @param oldText The text typed up until this point.
   * @returns whether the key was handled or not
   */
  public async handleTyping(newText: string, oldText: string): Promise<boolean | string> {
    if (this.options.onTextTyped) {
      return this.options.onTextTyped(newText, oldText);
    }

    return this.onHandleTextTyped();
  }

  /**
   * Handles a TYPING key received by the component
   *
   * @returns whether the key was handled or not
   */
  protected onHandleTextTyped(): boolean {
    return false;
  }

  /**
   * Handles a BACK key received by the component
   *
   * Do NOT override this method - override {@link onHandleBack} instead
   *
   * @returns whether the key was handled or not
   */
  public async handleBack(): Promise<boolean> {
    if (this.options.onBackPressed) {
      const handleByOptions = await this.options.onBackPressed();

      if (handleByOptions === true) {
        return true;
      }
    }

    return this.onHandleBack();
  }

  /**
   * Handles a BACK key received by the component
   *
   * @returns whether the key was handled or not
   */
  protected onHandleBack(): boolean {
    return false;
  }

  /**
   * Lifecycle event called when the field loses focus.
   *
   * Do NOT override this method - override {@link onHandleLoseFocus} instead
   *
   * @returns whether the key was handled or not
   */
  public async handleLoseFocus(): Promise<boolean> {
    if (this.options.onLoseFocus) {
      const handleByOptions = await this.options.onLoseFocus(this.typedText.get());

      if (handleByOptions === true) {
        return true;
      }
    }

    return this.onHandleLoseFocus();
  }

  /**
   * Lifecycle event called when the field loses focus.
   *
   * @returns whether the key was handled or not
   */
  protected onHandleLoseFocus(): boolean {
    return false;
  }
}

/** The params object for a UnsOverrideableTextInputField */
export interface UnsOverrideableTextInputFieldParams<U, V extends U | null = U | null> {
  /** The default value to display. */
  defaultValue: Subscribable<U>,
  /** The manual override value to display. */
  overrideValue: MutableSubscribable<V>,
  /** The function with which to parse the input. */
  parseFunction: (input: string) => V | Promise<V>,
  /** Same as the UnsTextInputField option. */
  maxInputCharacterCount: number,
  /** The null value string to display. */
  nullValueString: string,
  /** The formatter for the default value. */
  defaultValFormatter: (defaultVal: NonNullable<V>, typedText: string) => string,
  /** The formatter for displaying a highlighted field's typed text. */
  typedTextFormatter: (typedText: string) => string,
  /** The formatter for the override value. */
  overrideValFormatter: (overrideVal: NonNullable<V>, typedText: string) => string,
  /** The formatter for the override value when the field is highlighted. */
  overrideValHighlightedFormatter: (overrideVal: NonNullable<V>, typedText: string) => string,
  /** Optional, passes the value through to prefix field. */
  prefix?: string,
}

/** The special value to signal the deletion of an override value. */
const DELETE_OVERRIDE: unique symbol = Symbol();

/** A UNS text input field where the value has a default, but can be overridden.
 * `U` = The default value's type. `V` = The override value's type (which much necessarily include null). */
export class UnsOverrideableTextInputField<U, V extends U | null = U | null>
  extends UnsTextInputField<readonly [U, V, boolean], V | typeof DELETE_OVERRIDE> {

  /** @inheritDoc */
  constructor(page: UnsFmcPage, params: UnsOverrideableTextInputFieldParams<U, V>) {
    // Can't be a class field as this subject is referenced in the `options` object before `super` is called.
    const hideOverride = Subject.create(false);

    const options: UnsTextInputFieldOptions<readonly [U, V, boolean], V | typeof DELETE_OVERRIDE> = {
      acceptEmptyInput: true,
      formatter: {
        parse: async (input: string) =>
          params.overrideValue.get() && !input && hideOverride.get() ?
            DELETE_OVERRIDE :
            await params.parseFunction(input),
        format: ([[defaultVal, overrideVal, hideOverrideVal], isHighlighted, typedText]): string => {
          if (isHighlighted) {
            if (
              (defaultVal && overrideVal && hideOverrideVal) ||
              (!defaultVal && !overrideVal && !hideOverrideVal) ||
              (defaultVal && !overrideVal && !hideOverrideVal)
            ) {
              // Show typed text with highlighted style
              return params.typedTextFormatter(typedText);
            }
            if (defaultVal !== null && overrideVal && !hideOverrideVal) {
              // Show override value with highlighted style
              return params.overrideValHighlightedFormatter(overrideVal as NonNullable<V>, typedText);
            }
          } else {
            if (defaultVal !== null && !hideOverrideVal && !typedText) {
              if (overrideVal !== null) {
                // Show override destination
                return params.overrideValFormatter(overrideVal as NonNullable<V>, typedText);
              } else {
                // Show default destination
                return params.defaultValFormatter(defaultVal as NonNullable<V>, typedText);
              }
            }
            if (!defaultVal && !hideOverrideVal && !typedText) {
              // Show null string
              return params.nullValueString;
            }
          }

          console.error('Formatting condition not covered');
          return params.nullValueString;
        },
      },
      prefix: params.prefix,
      maxInputCharacterCount: params.maxInputCharacterCount,
      onSelected: async () => {
        page.screen.toggleFieldFocused(this);
        return true;
      },
      onTextTyped: async () => {
        return Boolean(params.overrideValue.get() && !hideOverride.get());
      },
      onModified: async (newValue: V | typeof DELETE_OVERRIDE) => {
        if (newValue === DELETE_OVERRIDE) {
          params.overrideValue.set(null as V);
        } else {
          params.overrideValue.set(newValue);
        }

        hideOverride.set(false);

        page.screen.interruptCursorPath();

        return true;
      },
      onBackPressed: async () => {
        if (params.overrideValue.get() && !hideOverride.get()) {
          hideOverride.set(true);
          return true;
        } else {
          return false;
        }
      },
      onLoseFocus: async () => {
        hideOverride.set(false);
        return false;
      },
    };

    super(page, options);

    const dataSub = MappedSubject.create(
      params.defaultValue,
      params.overrideValue,
      hideOverride,
    );
    this.page.addBinding(dataSub);
    this.bindWrappedData(dataSub);
  }
}
