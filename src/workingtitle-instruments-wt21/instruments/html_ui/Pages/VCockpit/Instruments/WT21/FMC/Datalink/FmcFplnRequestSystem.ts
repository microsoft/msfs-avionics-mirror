import { FacilityRepository, FacilityType, ICAO, SimbriefClient, SimbriefDataExtraction } from '@microsoft/msfs-sdk';

import { FmcUserSettings } from '@microsoft/msfs-wt21-shared';

import { WT21Fms } from '../FlightPlan/WT21Fms';
import { WT21PilotWaypointUtils } from '../Navigation/WT21PilotWaypointUtils';

/**
 * WT21 system to request flightplan from simbrief
 */
export class FmcFplnRequestSystem {

  private readonly fmcUserSettings = FmcUserSettings.getManager(this.fms.bus);


  /**
   * Ctor
   * @param fms Instance of the fms.
   */
  constructor(private readonly fms: WT21Fms) {

  }

  /**
   * Requests the flightplan from simbrief.
   * @returns A promise that resolves to a boolean indicating whether the flightplan request was successful.
   */
  public async requestFlightplan(): Promise<boolean> {

    const pilotId = this.fmcUserSettings.getSetting('simbriefPilotId').get();

    let ofp;
    let sbRte;
    try {
      ofp = await SimbriefClient.getOfp(pilotId);
      sbRte = await SimbriefDataExtraction.extractSimbriefRoute(ofp, this.fms.facLoader, FacilityRepository.getRepository(this.fms.bus),
        () => {
          const existingUserFacilities = this.fms.getUserFacilities();
          return `U      ${WT21PilotWaypointUtils.nextAutoGeneratedName(existingUserFacilities, 'LL')}`;
        });

      this.fms.emptyModFlightPlan(true);
      const plan = this.fms.getModFlightPlan();

      this.fms.setOrigin(sbRte.originAirport);
      this.fms.setDestination(sbRte.destinationAirport);

      for (const segment of sbRte.enroute) {
        if (segment.type === 'waypoint') {
          const facility = await this.fms.facLoader.getFacility(ICAO.getFacilityType(segment.icao), segment.icao);

          this.fms.insertWaypoint(facility);
        } else {
          const entryFacility = await this.fms.facLoader.getFacility(FacilityType.Intersection, segment.entryFixIcao);
          const exitFacility = await this.fms.facLoader.getFacility(FacilityType.Intersection, segment.exitFixIcao);

          const lastEnrouteSegmentIndex = this.fms.findLastEnrouteSegmentIndex(plan);
          const newSegment = plan.insertSegment(lastEnrouteSegmentIndex + 1);

          this.fms.insertAirwaySegment(segment.airwayObject, entryFacility, exitFacility, newSegment.segmentIndex, 0);
        }
      }


      if (ofp.alternate) {
        this.fms.setFlightPlanAlternate(sbRte.alternateAirport);
      }

      if (sbRte.flightNumber) {
        this.fmcUserSettings.getSetting('flightNumber').set(sbRte.flightNumber);
      }

      this.fms.performancePlanProxy.cruiseAltitude.set(sbRte.cruiseLevel);

    } catch (e) {
      console.warn(`SB REQ FAIL: ${e}`);
      return false;
    }

    return true;
  }
}
