"use strict";(self.webpackChunkdocs_api=self.webpackChunkdocs_api||[]).push([[9051],{3905:(e,t,a)=>{a.d(t,{Zo:()=>d,kt:()=>f});var n=a(67294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var o=n.createContext({}),u=function(e){var t=n.useContext(o),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},d=function(e){var t=u(e.components);return n.createElement(o.Provider,{value:t},e.children)},p="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,o=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),p=u(a),h=r,f=p["".concat(o,".").concat(h)]||p[h]||c[h]||i;return a?n.createElement(f,s(s({ref:t},d),{},{components:a})):n.createElement(f,s({ref:t},d))}));function f(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,s=new Array(i);s[0]=h;var l={};for(var o in t)hasOwnProperty.call(t,o)&&(l[o]=t[o]);l.originalType=e,l[p]="string"==typeof e?e:r,s[1]=l;for(var u=2;u<i;u++)s[u]=a[u];return n.createElement.apply(null,s)}return n.createElement.apply(null,a)}h.displayName="MDXCreateElement"},66204:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>o,contentTitle:()=>s,default:()=>c,frontMatter:()=>i,metadata:()=>l,toc:()=>u});var n=a(87462),r=(a(67294),a(3905));const i={sidebar_label:"Aural Alert System",sidebar_position:2},s="Aural Alert System",l={unversionedId:"sounds/aural-alert-system",id:"sounds/aural-alert-system",title:"Aural Alert System",description:"Introduction",source:"@site/docs/sounds/aural-alert-system.md",sourceDirName:"sounds",slug:"/sounds/aural-alert-system",permalink:"/msfs-avionics-mirror/docs/sounds/aural-alert-system",draft:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_label:"Aural Alert System",sidebar_position:2},sidebar:"sidebar",previous:{title:"SoundServer",permalink:"/msfs-avionics-mirror/docs/sounds/soundserver"},next:{title:"Defining Aural Alerts Using panel.xml",permalink:"/msfs-avionics-mirror/docs/sounds/defining-aural-alerts-using-panel-xml"}},o={},u=[{value:"Introduction",id:"introduction",level:2},{value:"System Description",id:"system-description",level:2},{value:"Registering Alerts",id:"registering-alerts",level:2},{value:"Activating Alerts",id:"activating-alerts",level:2},{value:"Triggering Alerts",id:"triggering-alerts",level:2},{value:"Customizing Alert Instances",id:"customizing-alert-instances",level:2},{value:"Alert Aliases",id:"alert-aliases",level:2},{value:"Alert Suffixes",id:"alert-suffixes",level:2},{value:"<code>AuralAlertSystem</code> Wake/Sleep State",id:"auralalertsystem-wakesleep-state",level:2},{value:"Using <code>CasAuralAlertTransporter</code>",id:"using-casauralalerttransporter",level:2}],d={toc:u},p="wrapper";function c(e){let{components:t,...a}=e;return(0,r.kt)(p,(0,n.Z)({},d,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"aural-alert-system"},"Aural Alert System"),(0,r.kt)("h2",{id:"introduction"},"Introduction"),(0,r.kt)("p",null,"Aural Alert System is an SDK API which sits on top of ",(0,r.kt)("a",{parentName:"p",href:"/msfs-avionics-mirror/docs/sounds/soundserver"},"SoundServer")," and provides a more powerful interface for playing avionics-based aural alerts. This API aims to abstract away some of the queue and state logic associated with playing aural alerts triggered by specific conditions. By using Aural Alert System, you can focus on defining your alerts and their triggers instead of having to worry about the mechanical details of how to get sounds to play at the correct times and in the correct order."),(0,r.kt)("h2",{id:"system-description"},"System Description"),(0,r.kt)("p",null,"Aural Alert System is based on queues. Each alert is assigned to a specific queue, and each queue can only play one alert at a time. If multiple alerts are set to play in the same queue, they will play in sequence instead of overlapping one another. Alerts with higher priority will play before alerts with lower priority in the same queue if they are set to play at the same time. However, a new alert will never interrupt an alert that is already playing, even if the new alert has higher priority. Alerts belonging to different queues can play simultaneously (overlap)."),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"AuralAlertSystem")," class handles the state logic governing aural alerts and controls which sounds are playing at any given moment. An airplane should have at most one instance of ",(0,r.kt)("inlineCode",{parentName:"p"},"AuralAlertSystem")," across all instruments. Because ",(0,r.kt)("inlineCode",{parentName:"p"},"AuralAlertSystem")," uses ",(0,r.kt)("inlineCode",{parentName:"p"},"SoundServer")," to play sounds, an instance of ",(0,r.kt)("inlineCode",{parentName:"p"},"SoundServer")," is required for ",(0,r.kt)("inlineCode",{parentName:"p"},"AuralAlertSystem")," to function properly. The instances do not necessarily have to be created on the same instrument, and there is no requirement to wait for ",(0,r.kt)("inlineCode",{parentName:"p"},"SoundServer")," to ",(0,r.kt)("a",{parentName:"p",href:"/msfs-avionics-mirror/docs/sounds/soundserver#setting-up-soundserver"},"initialize")," before creating or using ",(0,r.kt)("inlineCode",{parentName:"p"},"AuralAlertSystem"),"."),(0,r.kt)("h2",{id:"registering-alerts"},"Registering Alerts"),(0,r.kt)("p",null,"Alerts must be registered before they can be used. Registering an alert is done using the ",(0,r.kt)("inlineCode",{parentName:"p"},"AuralAlertRegistrationManager")," class:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"import { AuralAlertRegistrationManager, EventBus } from '@microsoft/msfs-sdk';\n\nconst bus = new EventBus();\nconst manager = new AuralAlertRegistrationManager(bus); // `bus` is the event bus\n\nmanager.register({\n  uuid: 'no-takeoff',\n  queue: 'my-queue',\n  priority: 0,\n  sequence: 'aural_no_takeoff',\n  continuous: false,\n  repeat: true\n});\n")),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"register()")," method takes in a single object that satisfies the ",(0,r.kt)("inlineCode",{parentName:"p"},"AuralAlertDefinition")," type. Each alert definition must define the properties seen in the above example."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"uuid")," is a unique string ID used to reference the alert."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"queue")," is the name of the queue to assign the alert."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"priority")," determines the priority of the alert within its queue."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"sequence")," defines which sound events are played for the alert. It can either be a single string or an array of strings. Each string in the sequence should be an avionics sound event ID defined in the airplane's ",(0,r.kt)("inlineCode",{parentName:"p"},"sound.xml"),". If an array of strings is used, then each sound event in the array is played in order."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"continuous")," determines whether the alert's sound event sequence plays in an infinite loop."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"repeat")," determines whether the alert should be re-queued to play again once it is finished playing as long as the alert is active. A repeating alert is not the same as a continuous alert. You can think of a continuous alert as an alert with an infinite duration - once the alert starts playing, it will continue to play forever (in a loop) unless forced to stop. This means that a continuous alert can never be interrupted by another alert. On the other hand, a repeating alert has a finite duration and will stop playing once the end of its sound event sequence is reached. At that point, if the alert is still active, it is inserted back into its queue. It will only begin playing again if there are no other alerts of higher priority in the queue. Therefore, repeating alerts can be interrupted by higher priority alerts (but only once the repeating alert has finished playing its sequence)."),(0,r.kt)("p",null,"In addition to the above required properties, ",(0,r.kt)("inlineCode",{parentName:"p"},"AuralAlertDefinition")," also defines an optional ",(0,r.kt)("inlineCode",{parentName:"p"},"timeout"),' property. This property determines the maximum amount of time the alert\'s sound event sequence is considered to be "still playing". After the timeout duration, the system proceeds as if the sequence has finished playing, regardless of whether all the sound events in the sequence have actually finished playing. This behavior is included to prevent the system from permanently locking up if a sound event fails to play. If ',(0,r.kt)("inlineCode",{parentName:"p"},"timeout")," is not included in the definition, it defaults to 10000 milliseconds."),(0,r.kt)("h2",{id:"activating-alerts"},"Activating Alerts"),(0,r.kt)("p",null,"Once an alert is registered with the system, it carries an activation state and can either be inactive or active at any given time. When an alert transitions from inactive to active, an instance of the alert is queued to play. When an alert transitions from active to inactive, the activated instance will be removed from the queue. If the activated instance of the alert is already playing when it is deactivated, it will continue to play. Repeating alerts are queued to play again when they finish playing as long as they are active."),(0,r.kt)("p",null,"To activate and deactivate alerts, use the event bus:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"import { AuralAlertControlEvents } from '@microsoft/msfs-sdk';\n\n// Activates the alert with ID 'no-takeoff'.\nbus.getPublisher<AuralAlertControlEvents>().pub('aural_alert_activate', 'no-takeoff', true, false);\n\n// Deactivates the alert with ID 'no-takeoff'.\nbus.getPublisher<AuralAlertControlEvents>().pub('aural_alert_deactivate', 'no-takeoff', true, false);\n")),(0,r.kt)("admonition",{type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"When publishing any of the topics defined by ",(0,r.kt)("inlineCode",{parentName:"p"},"AuralAlertControlEvents"),", you ",(0,r.kt)("strong",{parentName:"p"},"must")," specify that the topic be synced to other instruments and not cached (the third and fourth parameters of ",(0,r.kt)("inlineCode",{parentName:"p"},"pub()"),", respectively). Failure to specify these options will result in incorrect behavior.")),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"Activating an alert that is already active has no effect (the alert will not be queued to play again). If you wish to play alerts in response to a discrete event rather than a state transition, the ",(0,r.kt)("a",{parentName:"p",href:"#triggering-alerts"},"trigger function")," may be more useful.")),(0,r.kt)("h2",{id:"triggering-alerts"},"Triggering Alerts"),(0,r.kt)("p",null,"Sometimes you will want an alert to play as a response to a discrete event instead of a state transition. You can do this by ",(0,r.kt)("em",{parentName:"p"},"triggering")," the alert instead of activating it."),(0,r.kt)("p",null,"Each alert has a trigger state in addition to its activation state; an alert can either be triggered or untriggered. When an alert transitions from untriggered to triggered, an instance of the alert is queued to play. Once a triggered alert is finished playing, it automatically reverts to the untriggered state. You may also manually untrigger an alert. When an alert transitions from triggered to untriggered, the triggered instance will be removed from the queue. If the triggered instance of the alert is already playing when it is untriggered, it will continue to play. Triggered alerts do not repeat."),(0,r.kt)("p",null,"Triggered instances of alerts are treated entirely independently of activated instances. The activation state of an alert has no effect on any triggered instances and vice versa. If an alert is activated and triggered at the same time, both the activated and triggered instances will be queued to play and the alert will be heard twice."),(0,r.kt)("p",null,"To trigger and untrigger alerts, use the event bus:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"import { AuralAlertControlEvents } from '@microsoft/msfs-sdk';\n\n// Triggers the alert with ID 'no-takeoff'.\nbus.getPublisher<AuralAlertControlEvents>().pub('aural_alert_trigger', 'no-takeoff', true, false);\n\n// Untriggers the alert with ID 'no-takeoff'.\nbus.getPublisher<AuralAlertControlEvents>().pub('aural_alert_untrigger', 'no-takeoff', true, false);\n")),(0,r.kt)("h2",{id:"customizing-alert-instances"},"Customizing Alert Instances"),(0,r.kt)("p",null,"You are allowed to customize the instance of an alert that is queued to play when activating and triggering alerts. In doing so, you alter how the alert instance is played compared to how the alert was defined during registration. You can change the alert's sound event sequence, whether it is continuous, and whether it is repeating. A customized alert always retains its original queue and priority."),(0,r.kt)("p",null,"To activate/trigger a customized alert instance, send an ",(0,r.kt)("inlineCode",{parentName:"p"},"AuralAlertActivation")," object as the event data instead of just an ID string when activating/triggering the alert:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"const manager = new AuralAlertRegistrationManager(bus);\n\nmanager.register({\n  uuid: 'no-takeoff',\n  queue: 'my-queue',\n  priority: 0,\n  sequence: 'aural_no_takeoff',\n  continuous: false,\n  repeat: true\n});\n\n// Activates the alert with ID 'no-takeoff'.\n// The alert will play the 'aural_no_takeoff' sound event twice instead of repeatedly.\nbus.getPublisher<AuralAlertControlEvents>().pub('aural_alert_activate', {\n  uuid: 'no-takeoff',\n  sequence: ['aural_no_takeoff', 'aural_no_takeoff'],\n  repeat: false\n}, true, false);\n")),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"Activating or triggering a customized alert instance while the alert is already active or triggered, respectively, has no effect. The new custom instance will not replace the one that is already activated/triggered. To force the new custom instance to replace the existing one, you must deactivate/untrigger the alert first.")),(0,r.kt)("h2",{id:"alert-aliases"},"Alert Aliases"),(0,r.kt)("p",null,"Normally, only one activated and one triggered instance of an alert can be queued simultaneously. However, there are cases where you may want to queue multiple similar and related alerts simultaneously. One solution would be to register a separate alert for each simultaneous instance that can be queued. But this isn't possible if you don't know beforehand how many simultaneous instances can be queued, or if the number of queued instances is unbounded."),(0,r.kt)("p",null,"To get around the above limitations, Aural Alert System allows you to activate and trigger alerts using ",(0,r.kt)("em",{parentName:"p"},"aliases"),". When an alert is activated/triggered with an alias, the alias effectively replaces the alert's registered ID string for that instance of the alert. An alert that is activated/triggered without an explicit alias can be considered to spawn an instance with an alias equal to its registered ID. The system treats alert instances with different aliases as ",(0,r.kt)("em",{parentName:"p"},"separate")," alerts. Therefore, alert instances with different aliases are allowed to co-exist in the queue, even if they were spawned from the same alert."),(0,r.kt)("admonition",{type:"caution"},(0,r.kt)("p",{parentName:"admonition"},"Alert aliases, like IDs, must be ",(0,r.kt)("em",{parentName:"p"},"unique"),". Do not choose aliases that match existing alert IDs or other aliases that are in use.")),(0,r.kt)("p",null,"When deactivating or untriggering aliased alerts, you must use the alias everywhere an ID is normally expected."),(0,r.kt)("p",null,"The following example shows how to use aliased alerts to queue a separate alert whenever a new traffic advisory is issued:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"/**\n * Called when a new traffic advisory is issued.\n * @param threatId The ID of the intruder.\n * @param bus The event bus.\n */\nfunction onTrafficAdvisoryIssued(intruderId: string, bus: EventBus): void {\n  bus.getPublisher<AuralAlertControlEvents>().pub('aural_alert_activate', {\n    uuid: 'traffic',\n    alias: `traffic-${intruderId}`\n  }, true, false);\n}\n\n/**\n * Called when a traffic advisory is cancelled.\n * @param threatId The ID of the intruder.\n * @param bus The event bus.\n */\nfunction onTrafficAdvisoryCancelled(threatId: string, bus: EventBus): void {\n  bus.getPublisher<AuralAlertControlEvents>().pub('aural_alert_deactivate', `traffic-${intruderId}`, true, false);\n}\n")),(0,r.kt)("h2",{id:"alert-suffixes"},"Alert Suffixes"),(0,r.kt)("p",null,"Suppose you want to queue an alert if and only if at least one of a number of separate conditions has been met. Aural Alert System supports this type of logic through the use of alert ",(0,r.kt)("em",{parentName:"p"},"suffixes"),"."),(0,r.kt)("p",null,"When an alert is activated or triggered using a suffix, the activation/trigger state of each suffix is tracked independently. The activation/trigger state of the alert as a whole then becomes dependent on the states of the suffixes such that the alert is considered to be active or triggered if and only if at least ",(0,r.kt)("em",{parentName:"p"},"one")," of its suffixes is active or triggered, respectively. An alert that is activated/triggered without an explicit suffix can be considered to activate/trigger the ",(0,r.kt)("em",{parentName:"p"},"empty")," suffix, which is treated the same as any other suffix. Suffixes are applied on a per-alias basis, so activating/triggering a suffix on alias ",(0,r.kt)("em",{parentName:"p"},"A")," has no effect on the activation/trigger state of alias ",(0,r.kt)("em",{parentName:"p"},"B"),"."),(0,r.kt)("p",null,"When deactivating or untriggering suffixed alerts, you must use a suffixed form of the alert ID/alias equal to ",(0,r.kt)("inlineCode",{parentName:"p"},"`${uuid}::${suffix}`")," everywhere an ID is normally expected."),(0,r.kt)("p",null,"The following example shows how to use suffixed alerts to implement a master warning alert that is queued to play as long as one warning is active:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"/**\n * Called when a warning is activated.\n * @param warningId The ID of the warning.\n * @param bus The event bus.\n */\nfunction onWarningActivated(warningId: string, bus: EventBus): void {\n  bus.getPublisher<AuralAlertControlEvents>().pub('aural_alert_trigger', {\n    uuid: 'master-warning',\n    suffix: warningId\n  }, true, false);\n}\n\n/**\n * Called when a warning is deactivated.\n * @param warningId The ID of the warning.\n * @param bus The event bus.\n */\nfunction onWarningDeactivated(warningId: string, bus: EventBus): void {\n  bus.getPublisher<AuralAlertControlEvents>().pub('aural_alert_untrigger', `master-warning::${warningId}`, true, false);\n}\n")),(0,r.kt)("h2",{id:"auralalertsystem-wakesleep-state"},(0,r.kt)("inlineCode",{parentName:"h2"},"AuralAlertSystem")," Wake/Sleep State"),(0,r.kt)("p",null,"When instantiating ",(0,r.kt)("inlineCode",{parentName:"p"},"AuralAlertSystem"),", it is initialized to a sleeping state. While asleep, it will continue to track alert state but will not play any sounds. This is meant to model what would occur when the avionics' sound subsystem is turned off. To wake the system, call the ",(0,r.kt)("inlineCode",{parentName:"p"},"wake()")," method. Waking the system will cause it to queue any continuous or repeating alerts that are active. Active alerts that are neither continuous nor repeating will not be queued. However, any alert that becomes activated or triggered while the system is awake will be queued normally."),(0,r.kt)("p",null,"Calling the ",(0,r.kt)("inlineCode",{parentName:"p"},"sleep()")," method will put the system back to sleep. Putting the system to sleep will immediately unqueue all alerts and untrigger any triggered alerts. Activated alerts will remain active until they are deactivated normally. Any alerts that are already playing will be stopped at the earliest opportunity without waiting for them to finish. While the system is asleep, alerts cannot be triggered. Alerts can still be activated but will not be queued."),(0,r.kt)("h2",{id:"using-casauralalerttransporter"},"Using ",(0,r.kt)("inlineCode",{parentName:"h2"},"CasAuralAlertTransporter")),(0,r.kt)("p",null,"A common pattern found in many avionics systems is to bind the activation state of aural alerts to CAS (crew alerting system) alerts. If your CAS is implemented using the ",(0,r.kt)("a",{parentName:"p",href:"/msfs-avionics-mirror/docs/cas/cas-system"},"CAS System API"),", you can use ",(0,r.kt)("inlineCode",{parentName:"p"},"CasAuralAlertTransporter")," to activate alerts based on whether a particular CAS alert is displayed as a message."),(0,r.kt)("p",null,"Let's say that we want to activate the ",(0,r.kt)("inlineCode",{parentName:"p"},"no-takeoff")," aural alert whenever the associated ",(0,r.kt)("inlineCode",{parentName:"p"},"cas-no-takeoff")," CAS alert is displayed as a message with warning priority:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-typescript"},"import { AnnunciationType, CasAuralAlertTransporter } from '@microsoft/msfs-sdk';\n\nCasAuralAlertTransporter.create(\n  bus,                        // event bus\n  'no-takeoff',               // aural alert ID\n  undefined,                  // optional AuralAlertActivation object to customize the aural alert\n  'cas-no-takeoff',           // CAS alert ID\n  AnnunciationType.Warning,   // CAS alert priority level\n  undefined,                  // CAS alert suffix - in this case the alert has no suffixes\n  true                        // whether to activate the aural alert if the CAS alert has been acknowledged\n);\n")),(0,r.kt)("p",null,"When creating a ",(0,r.kt)("inlineCode",{parentName:"p"},"CasAuralAlertTransporter"),", you can optionally provide a reference to ",(0,r.kt)("inlineCode",{parentName:"p"},"CasSystem"),". Doing so will ensure that the aural alert activation state is initialized correctly (e.g. if the bound CAS alert is already displayed when the transporter is created). If the reference is not provided, then care must be taken to create the transporter ",(0,r.kt)("em",{parentName:"p"},"before")," the bound CAS alert has a chance to be activated and displayed."),(0,r.kt)("p",null,"For more detailed information on ",(0,r.kt)("inlineCode",{parentName:"p"},"CasAuralAlertTransporter"),", please refer to the ",(0,r.kt)("a",{parentName:"p",href:"../framework/classes/index.CasAuralAlertTransporter.md"},"API documentation"),"."))}c.isMDXComponent=!0}}]);