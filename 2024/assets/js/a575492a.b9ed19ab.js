"use strict";(self.webpackChunkdocs_api=self.webpackChunkdocs_api||[]).push([["137424"],{237637:function(e,t,i){i.r(t),i.d(t,{metadata:()=>n,contentTitle:()=>c,default:()=>d,assets:()=>a,toc:()=>l,frontMatter:()=>o});var n=JSON.parse('{"id":"framework-systems/checklist/extending-the-checklist-api","title":"Extending the Checklist API","description":"Custom Item Definitions","source":"@site/docs/framework-systems/checklist/extending-the-checklist-api.md","sourceDirName":"framework-systems/checklist","slug":"/framework-systems/checklist/extending-the-checklist-api","permalink":"/msfs-avionics-mirror/2024/docs/framework-systems/checklist/extending-the-checklist-api","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_label":"Extending the Checklist API","sidebar_position":3},"sidebar":"sidebar","previous":{"title":"Parsing Checklists from DOM","permalink":"/msfs-avionics-mirror/2024/docs/framework-systems/checklist/parsing-checklists-from-dom"},"next":{"title":"Avionics Development","permalink":"/msfs-avionics-mirror/2024/docs/avionics/"}}'),s=i("785893"),r=i("250065");let o={sidebar_label:"Extending the Checklist API",sidebar_position:3},c="Extending the Checklist API",a={},l=[{value:"Custom Item Definitions",id:"custom-item-definitions",level:2},{value:"Extending <code>ChecklistDOMParser</code>",id:"extending-checklistdomparser",level:2}];function m(e){let t={a:"a",code:"code",h1:"h1",h2:"h2",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"extending-the-checklist-api",children:"Extending the Checklist API"})}),"\n",(0,s.jsx)(t.h2,{id:"custom-item-definitions",children:"Custom Item Definitions"}),"\n",(0,s.jsxs)(t.p,{children:["The Checklist API provides a set of ",(0,s.jsx)(t.a,{href:"/msfs-avionics-mirror/2024/docs/framework-systems/checklist/checklist-api#item-definition",children:"default"})," checklist item definitions that are mapped from checklist item types according to the mapping defined by ",(0,s.jsx)(t.a,{href:"/msfs-avionics-mirror/2024/docs/api/framework/type-aliases/ChecklistItemTypeDefMap",children:(0,s.jsx)(t.code,{children:"ChecklistItemTypeDefMap"})}),". If a specific checklist implementation needs to define additional or different properties for checklist items, then it can do so by creating its own set of custom item definitions and associated mapping."]}),"\n",(0,s.jsxs)(t.p,{children:["First, define type aliases for each custom definition. Each type alias must satisfy the types defined in ",(0,s.jsx)(t.a,{href:"/msfs-avionics-mirror/2024/docs/api/framework/type-aliases/BaseChecklistItemTypeDefMap",children:(0,s.jsx)(t.code,{children:"BaseChecklistItemTypeDefMap"})}),". Then, define a mapping from checklist item types to the custom item definitions. The mapping must satisfy ",(0,s.jsx)(t.code,{children:"BaseChecklistItemTypeDefMap"}),"."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:"import {\r\n  CoreChecklistItemDef, ChecklistActionableItemDef, ChecklistItemType, ChecklistNoteItemDef, ChecklistTitleItemDef\r\n} from '@microsoft/msfs-sdk';\r\n\r\n// Extend the default actionable item definition with an 'indent' property.\r\ntype CustomActionableItemDef = ChecklistActionableItemDef & {\r\n  indent: number;\r\n};\r\n\r\n// Extend the default note item definition with a 'textColor' property.\r\ntype CustomNoteItemDef = ChecklistNoteItemDef & {\r\n  textColor: string;\r\n};\r\n\r\n// Remove the 'height' property from the default spacer item definition.\r\ntype CustomSpacerItemDef = CoreChecklistItemDef<ChecklistItemType.Spacer>;\r\n\r\n// Mapping from checklist item types to custom item definitions.\r\ntype CustomChecklistItemTypeDefMap = {\r\n  [ChecklistItemType.Actionable]: CustomActionableItemDef;\r\n  [ChecklistItemType.Branch]: ChecklistBranchItemDef;\r\n  [ChecklistItemType.Link]: ChecklistLinkItemDef;\r\n  [ChecklistItemType.Note]: CustomNoteItemDef;\r\n  [ChecklistItemType.Title]: ChecklistTitleItemDef;\r\n  [ChecklistItemType.Spacer]: CustomSpacerItemDef;\r\n};\n"})}),"\n",(0,s.jsx)(t.p,{children:"Once the custom item definitions and the custom mapping are declared, use the mapping type alias where appropriate to ensure the custom item definitions get used:"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:"import {\r\n  ChecklistItemType, ChecklistSetDef, DefaultChecklistStateProvider\r\n} from '@microsoft/msfs-sdk';\r\n\r\n// Item definitions in setDef are now the custom ones defined in CustomChecklistItemTypeDefMap.\r\nconst setDef: ChecklistSetDef<CustomChecklistItemTypeDefMap> = ...\r\n\r\n// We can also define a type alias to cut down on boilerplate.\r\ntype CustomChecklistSetDef<S = unknown, G = unknown, L = unknown, B = unknown>\r\n  = ChecklistSetDef<CustomChecklistItemTypeDefMap, S, G, L, B>;\r\n\r\nconst firstItemDef = setDef.groups[0].lists[0].items[0];\r\nif (firstItemDef.type === ChecklistItemType.Actionable) {\r\n  // firstItemDef now has type CustomActionableItemDef, so we can access the 'indent' property on it.\r\n  console.log(`First item has indent of ${firstItemDef.indent}`);\r\n}\r\n\r\n// Explicitly passing CustomChecklistItemTypeDefMap to DefaultChecklistStateProvider's first type parameter will\r\n// ensure the state object the latter provides uses the custom item definitions.\r\n// Alternatively, we could have left out the explicit type parameter and allowed TypeScript to infer the correct type\r\n// from setDef.\r\nconst provider = new DefaultChecklistStateProvider<CustomChecklistItemTypeDefMap>(1, bus, setDef);\r\nconst firstItem = provider.state.groups[0].lists[0].items[0];\r\nif (firstItem.type === ChecklistItemType.Actionable) {\r\n  // firstItem now has type CustomActionableItemDef, so we can access the 'indent' property on it.\r\n  console.log(`First item has indent of ${firstItem.indent}`);\r\n}\n"})}),"\n",(0,s.jsxs)(t.h2,{id:"extending-checklistdomparser",children:["Extending ",(0,s.jsx)(t.code,{children:"ChecklistDOMParser"})]}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.a,{href:"/msfs-avionics-mirror/2024/docs/framework-systems/checklist/parsing-checklists-from-dom",children:(0,s.jsx)(t.code,{children:"ChecklistDOMParser"})})," parses ",(0,s.jsx)(t.a,{href:"/msfs-avionics-mirror/2024/docs/framework-systems/checklist/checklist-api#item-definition",children:"default"})," item definitions. If you wish to parse custom item definitions from DOM, you must extend ",(0,s.jsx)(t.code,{children:"ChecklistDOMParser"})," with a subclass."]}),"\n",(0,s.jsx)(t.p,{children:"Subclasses that parse custom item definitions should override one or more of the following methods:"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.code,{children:"parseActionableItemDef()"})}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.code,{children:"parseBranchItemDef()"})}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.code,{children:"parseLinkItemDef()"})}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.code,{children:"parseNoteItemDef()"})}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.code,{children:"parseTitleItemDef()"})}),"\n",(0,s.jsx)(t.li,{children:(0,s.jsx)(t.code,{children:"parseSpacerItemDef()"})}),"\n"]}),"\n",(0,s.jsxs)(t.p,{children:["For example, the following class parses the custom item definitions used in the examples from the ",(0,s.jsx)(t.a,{href:"#custom-item-definitions",children:"previous section"}),"."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-typescript",children:"import {\r\n  ChecklistDOMParser, ChecklistDOMParseOptionsToUse, ChecklistItemType, DefaultChecklistStateProvider\r\n} from '@microsoft/msfs-sdk';\r\n\r\nclass CustomChecklistDOMParser extends ChecklistDOMParser<CustomChecklistItemTypeDefMap> {\r\n\r\n  protected override parseActionableItemDef(\r\n    element: Element,\r\n    groupName: string,\r\n    listName: string,\r\n    options: ChecklistDOMParseOptionsToUse<CustomChecklistItemTypeDefMap>\r\n  ): CustomChecklistItemTypeDefMap[ChecklistItemType.Actionable] | undefined {\r\n    const baseItemDef = super.parseActionableItemDef(element, groupName, listName, options);\r\n    if (!baseItemDef) {\r\n      return undefined;\r\n    }\r\n\r\n    const indentAttr = element.getAttribute('indent');\r\n    const indent = Number(indentAttr ?? 0);\r\n    if (!Number.isInteger(indent) || indent < 0) {\r\n      options.onError(`CustomChecklistDOMParser: invalid indent ${indentAttr} for an actionable checklist item in list ${listName} (group ${groupName}).`);\r\n      return undefined;\r\n    }\r\n\r\n    return {\r\n      ...baseItemDef,\r\n      indent\r\n    };\r\n  }\r\n\r\n  protected override parseNoteItemDef(\r\n    element: Element,\r\n    groupName: string,\r\n    listName: string,\r\n    options: ChecklistDOMParseOptionsToUse<CustomChecklistItemTypeDefMap>\r\n  ): CustomChecklistItemTypeDefMap[ChecklistItemType.Note] | undefined {\r\n    const baseItemDef = super.parseNoteItemDef(element, groupName, listName, options);\r\n    if (!baseItemDef) {\r\n      return undefined;\r\n    }\r\n\r\n    const textColor = element.getAttribute('text-color');\r\n    if (!textColor) {\r\n      options.onError(`CustomChecklistDOMParser: missing text color for a note checklist item in list ${listName} (group ${groupName}).`);\r\n      return undefined;\r\n    }\r\n\r\n    return {\r\n      ...baseItemDef,\r\n      textColor\r\n    };\r\n  }\r\n\r\n  // parseTitleItemDef() does not need to be overridden because the custom mapping\r\n  // still uses the default title item definition.\r\n\r\n  protected override parseSpacerItemDef(): CustomChecklistItemTypeDefMap[ChecklistItemType.Spacer] | undefined {\r\n    return { type: ChecklistItemType.Spacer };\r\n  }\r\n\r\n}\n"})})]})}function d(e={}){let{wrapper:t}={...(0,r.a)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(m,{...e})}):m(e)}},250065:function(e,t,i){i.d(t,{Z:function(){return c},a:function(){return o}});var n=i(667294);let s={},r=n.createContext(s);function o(e){let t=n.useContext(r);return n.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),n.createElement(r.Provider,{value:t},e.children)}}}]);