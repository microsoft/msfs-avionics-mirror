"use strict";(self.webpackChunkdocs_api=self.webpackChunkdocs_api||[]).push([["504065"],{462938:function(e,s,t){t.r(s),t.d(s,{metadata:()=>n,contentTitle:()=>o,default:()=>d,assets:()=>c,toc:()=>l,frontMatter:()=>a});var n=JSON.parse('{"id":"framework-systems/subscriptions/subscribables","title":"Subscribables","description":"Overview","source":"@site/docs/framework-systems/subscriptions/subscribables.md","sourceDirName":"framework-systems/subscriptions","slug":"/framework-systems/subscriptions/subscribables","permalink":"/msfs-avionics-mirror/2024/docs/framework-systems/subscriptions/subscribables","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_label":"Subscribables","sidebar_position":2},"sidebar":"sidebar","previous":{"title":"Intro to Subscriptions","permalink":"/msfs-avionics-mirror/2024/docs/framework-systems/subscriptions/intro-to-subscriptions"},"next":{"title":"Specialized Subscribables","permalink":"/msfs-avionics-mirror/2024/docs/framework-systems/subscriptions/specialized-subscribables"}}'),i=t("785893"),r=t("250065");let a={sidebar_label:"Subscribables",sidebar_position:2},o="Subscribables",c={},l=[{value:"Overview",id:"overview",level:2},{value:"Subjects",id:"subjects",level:2},{value:"<code>Subject</code>",id:"subject",level:3},{value:"<code>ComputedSubject</code>",id:"computedsubject",level:3},{value:"<code>ConsumerSubject</code>",id:"consumersubject",level:3},{value:"Specialized Subscribables",id:"specialized-subscribables",level:3},{value:"Using Subscribables",id:"using-subscribables",level:2},{value:"Getting and Subscribing to Values",id:"getting-and-subscribing-to-values",level:3},{value:"Using <code>initialNotify</code> when Subscribing",id:"using-initialnotify-when-subscribing",level:3},{value:"Managing Subscriptions",id:"managing-subscriptions",level:3},{value:"Piping Values to Other Subscribables",id:"piping-values-to-other-subscribables",level:3},{value:"Mapping a Subscribable to New Subscribables",id:"mapping-a-subscribable-to-new-subscribables",level:3}];function u(e){let s={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",strong:"strong",...(0,r.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(s.header,{children:(0,i.jsx)(s.h1,{id:"subscribables",children:"Subscribables"})}),"\n",(0,i.jsx)(s.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsxs)(s.p,{children:["The avionics framework provides a variety of classes that provide ",(0,i.jsx)(s.a,{href:"https://en.wikipedia.org/wiki/Observer_pattern",children:"observable"})," values. These classes are collectively referred to as ",(0,i.jsx)(s.strong,{children:"subscribables"}),". The ",(0,i.jsx)(s.a,{href:"/msfs-avionics-mirror/2024/docs/api/framework/interfaces/Subscribable",children:(0,i.jsx)(s.code,{children:"Subscribable"})})," interface describes the most generic of these classes while other related interfaces exist for subscribables with more specialized values, such as arrays, sets, and maps."]}),"\n",(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.code,{children:"Subscribable"})," interface (and its more specialized versions) define a common API with which consumers can access observed values from implementing classes. However, the interface is purposely non-prescriptive about where its observed value is sourced from or when/how/why the value can be changed (or even ",(0,i.jsx)(s.em,{children:"if"})," it can be changed). This keeps the interface flexible and allows a for a wide variety of implementing classes."]}),"\n",(0,i.jsx)(s.h2,{id:"subjects",children:"Subjects"}),"\n",(0,i.jsxs)(s.p,{children:["Most of the classes included in the framework that are subscribables fall under the umbrella of ",(0,i.jsx)(s.strong,{children:"subjects"}),". A subject is a generic subscribable that provides some degree of control over the value it provides."]}),"\n",(0,i.jsx)(s.p,{children:"Below are some of the basic types of subjects included in the framework."}),"\n",(0,i.jsx)(s.h3,{id:"subject",children:(0,i.jsx)(s.a,{href:"/msfs-avionics-mirror/2024/docs/api/framework/classes/Subject",children:(0,i.jsx)(s.code,{children:"Subject"})})}),"\n",(0,i.jsxs)(s.p,{children:["This is the most generic and flexible subject. A ",(0,i.jsx)(s.code,{children:"Subject"})," can provide any type of value and allows its value to be modified without restriction using the ",(0,i.jsx)(s.code,{children:"set()"})," method:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-typescript",children:"import { Subject } from '@microsoft/msfs-sdk';\r\n\r\n// The first argument passed to create() defines the new subject's initial value.\r\nconst numberSubject = Subject.create<number>(0);\r\nnumberSubject.set(10);\r\n\r\nconst stringSubject = Subject.create<string>('');\r\nstringSubject.set('foo');\r\n\r\nconst objectSubject = Subject.create<Record<string, any>>({});\r\nobjectSubject.set({ a: 10, b: false });\n"})}),"\n",(0,i.jsxs)(s.p,{children:["By default, ",(0,i.jsx)(s.code,{children:"Subject"}),' uses Javascript\'s built-in "strict equality" operator (',(0,i.jsx)(s.code,{children:"==="}),") to determine whether two values are equal. This is important to keep in mind because ",(0,i.jsx)(s.code,{children:"Subject"})," will notify subscribers after its value is modified if and only if the old and new values are considered not equal. When working with primitive types, the strict equality operator usually gives the desired behavior. However, sometimes this isn't the case, in which case you can define your own equality logic:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-typescript",children:"// Here we define a custom equality function to avoid the surprising convention where NaN === NaN is false.\r\nconst numberSubject = Subject.create<number>(NaN, (a, b) => {\r\n  if (isNaN(a) && isNaN(b)) {\r\n    return true;\r\n  } else {\r\n    return a === b;\r\n  }\r\n});\r\n\r\nnumberSubject.set(NaN); // Will not trigger a notification.\n"})}),"\n",(0,i.jsx)(s.p,{children:"Custom equality logic is especially useful when working with object-valued subjects:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-typescript",children:"type LatLon = {\r\n  lat: number;\r\n  lon: number;\r\n};\r\n\r\nconst latLonSubject1 = Subject.create<LatLon>({ lat: 0, lon: 0 });\r\nlatLonSubject1.set({ lat: 0, lon: 0 }); // Will trigger a notification!\r\n\r\nconst latLonSubject2 = Subject.create<LatLon>({ lat: 0, lon: 0 }, (a, b) => {\r\n  return a.lat === b.lat && a.lon === b.lon;\r\n});\r\nlatLonSubject2.set({ lat: 0, lon: 0 }); // Will not trigger a notification.\r\nlatLonSubject2.set({ lat: 5, lon: 0 }); // Will trigger a notification.\n"})}),"\n",(0,i.jsxs)(s.p,{children:["When dealing with object values, ",(0,i.jsx)(s.code,{children:"Subject"})," works best when using immutable objects. When mutable objects must be used, keep in mind that any mutable object that is the value of a ",(0,i.jsx)(s.code,{children:"Subject"})," must be changed through the ",(0,i.jsx)(s.code,{children:"Subject"})," for the changes to trigger a notification."]}),"\n",(0,i.jsxs)(s.p,{children:["Defining a custom mutator function will allow you to mutate the value of a ",(0,i.jsx)(s.code,{children:"Subject"})," in-place using ",(0,i.jsx)(s.code,{children:"set()"})," rather than having the new value replace the existing value by reference:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-typescript",children:"type LatLon = {\r\n  lat: number;\r\n  lon: number;\r\n};\r\n\r\nconst latLonSubject = Subject.create<LatLon>(\r\n  // Initial value\r\n  { lat: 0, lon: 0 },\r\n  // Equality function\r\n  (a, b) => a.lat === b.lat && a.lon === b.lon,\r\n  // Mutator function\r\n  (existingVal, newVal) => {\r\n    existingVal.lat = newVal.lat;\r\n    existingVal.lon = newVal.lon;\r\n  }\r\n);\r\n\r\nconst newLatLon = { lat: 5, lon: 0 };\r\nlatLonSubject.set(newLatLon); // latLonSubject's value is now { lat: 5, lon: 0 }.\r\n\r\nnewLatLon.lon = 10; // latLonSubject's value is still { lat: 5, lon: 0 }.\r\nlatLonSubject.set(newLatLon); // latLonSubject's value is now { lat: 5, lon: 10 }.\n"})}),"\n",(0,i.jsx)(s.admonition,{type:"tip",children:(0,i.jsxs)(s.p,{children:["When defining a custom mutator function, it is ",(0,i.jsx)(s.em,{children:"highly recommended"})," that you also define a custom equality function. The default equality-by-reference behavior is almost never desired when working with mutable objects."]})}),"\n",(0,i.jsx)(s.h3,{id:"computedsubject",children:(0,i.jsx)(s.a,{href:"/msfs-avionics-mirror/2024/docs/api/framework/classes/ComputedSubject",children:(0,i.jsx)(s.code,{children:"ComputedSubject"})})}),"\n",(0,i.jsxs)(s.p,{children:["This is a subject which, like ",(0,i.jsx)(s.code,{children:"Subject"}),", allows you to freely change its value via a ",(0,i.jsx)(s.code,{children:"set()"})," method but applies a transformation function to all inputs passed to ",(0,i.jsx)(s.code,{children:"set()"}),":"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-typescript",children:"import { ComputedSubject } from '@microsoft/msfs-sdk';\r\n\r\n// Creates a ComputedSubject that converts numeric inputs to their string values.\r\n// The initial value is set to '0' (converted from the number 0).\r\nconst subject = ComputedSubject.create<number, string>(0, input => input.toString());\r\n\r\nsubject.set(1); // subject's value is now '1'.\n"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"ComputedSubject"})," does not support custom equality or mutator functions. Therefore, it is recommended to only use it with primitive-typed values."]}),"\n",(0,i.jsx)(s.h3,{id:"consumersubject",children:(0,i.jsx)(s.a,{href:"/msfs-avionics-mirror/2024/docs/api/framework/classes/ConsumerSubject",children:(0,i.jsx)(s.code,{children:"ConsumerSubject"})})}),"\n",(0,i.jsxs)(s.p,{children:["This is a subject which takes its value from the data published to an event bus topic. You cannot freely change the value of a ",(0,i.jsx)(s.code,{children:"ConsumerSubject"}),". However, you can change the topic and/or ",(0,i.jsx)(s.code,{children:"Consumer"})," from which the subject's value is sourced:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-typescript",children:"import { ConsumerSubject } from '@microsoft/msfs-sdk';\r\n\r\n// Creates a ConsumerSubject that sources its value from the 'n1_1' topic.\r\n// The initial value is set to 0 in case a cached value has not yet been published to the topic.\r\nconst subject = ConsumerSubject.create<number>(bus.getSubscriber<EngineEvents>().on('n1_1'), 0);\r\n\r\nbus.getPublisher<EngineEvents>().pub('n1_1', 50, false, true); // subject's value is now 50.\r\nbus.getPublisher<EngineEvents>().pub('n1_1', 100, false, true); // subject's value is still 50.\r\n\r\n// Removes subject's consumer source. It will now stop updating its value.\r\nsubject.setConsumer(null); // subject's value is still 100.\r\nbus.getPublisher<EngineEvents>().pub('n1_1', 75, false, true); // subject's value is still 100.\r\n\r\nbus.getPublisher<EngineEvents>().pub('n1_2', 25, false, true);\r\n// Sets a new consumer source for subject such that it now sources its value from the 'n1_2' topic.\r\nsubject.setConsumer(bus.getSubscriber<EngineEvents>().on('n1_2')) // subject's value is now 25.\n"})}),"\n",(0,i.jsxs)(s.p,{children:["Like with ",(0,i.jsx)(s.code,{children:"Subject"}),", you can specify custom equality and mutator functions when creating a ",(0,i.jsx)(s.code,{children:"ConsumerSubject"}),". The default behavior for both is the same as the default behavior for ",(0,i.jsx)(s.code,{children:"Subject"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"ConsumerSubject"})," also implements the ",(0,i.jsxs)(s.a,{href:"/msfs-avionics-mirror/2024/docs/framework-systems/subscriptions/intro-to-subscriptions",children:[(0,i.jsx)(s.code,{children:"Subscription"})," interface"]}),". This is meant to represent the subscription to the event bus that updates the value of the subject. By manipulating ",(0,i.jsx)(s.code,{children:"ConsumerSubject"})," as a subscription, you can control control when its value is updated from the event bus:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-typescript",children:"const subject = ConsumerSubject.create<number>(bus.getSubscriber<EngineEvents>().on('n1_1'), 0);\r\n\r\nbus.getPublisher<EngineEvents>().pub('n1_1', 50, false, true); // subject's value is now 50.\r\n\r\nsubject.pause();\r\nbus.getPublisher<EngineEvents>().pub('n1_1', 100, false, true); // subject's value is still 50.\r\n\r\nsubject.resume(); // subject's value is now 100.\r\n\r\nbus.getPublisher<EngineEvents>().pub('n1_1', 25, false, true); // subject's value is now 25.\n"})}),"\n",(0,i.jsxs)(s.p,{children:["You may have noticed in the above example that calling ",(0,i.jsx)(s.code,{children:"resume()"})," immediately updated the subject's value to the latest cached value published to the event bus even though we didn't specify that an ",(0,i.jsx)(s.a,{href:"/msfs-avionics-mirror/2024/docs/framework-systems/subscriptions/intro-to-subscriptions#initial-notify-on-resume",children:"initial notification"})," should be triggered. This is because resuming ",(0,i.jsx)(s.code,{children:"ConsumerSubject"})," always triggers an initial notification from its source. This forced initial notification guarantees that the subject's value will immediately be updated (if possible) when the subject is resumed. However, the ",(0,i.jsx)(s.em,{children:"subject's"})," subscribers will only be notified if the subject's value changes as a result of the update."]}),"\n",(0,i.jsxs)(s.p,{children:["Like with all subscriptions, ",(0,i.jsx)(s.code,{children:"ConsumerSubject"})," should be cleaned up by calling its ",(0,i.jsx)(s.code,{children:"destroy()"})," method when it is no longer needed in order to prevent memory leaks."]}),"\n",(0,i.jsx)(s.h3,{id:"specialized-subscribables",children:"Specialized Subscribables"}),"\n",(0,i.jsxs)(s.p,{children:["The framework provides a number of more specialized subscribable classes. Read more about them ",(0,i.jsx)(s.a,{href:"/msfs-avionics-mirror/2024/docs/framework-systems/subscriptions/specialized-subscribables",children:"here"}),"."]}),"\n",(0,i.jsx)(s.h2,{id:"using-subscribables",children:"Using Subscribables"}),"\n",(0,i.jsx)(s.h3,{id:"getting-and-subscribing-to-values",children:"Getting and Subscribing to Values"}),"\n",(0,i.jsxs)(s.p,{children:["The two most basic operations you can perform with a subscribable is to retrieve its value and to subscribe to it. Retrieving a subscribable's value is straightforward and accomplished using the ",(0,i.jsx)(s.code,{children:"get()"})," method. Subscribing to a subscribable allows a handler function to be executed when the subscribable's value changes and is accomplished using the ",(0,i.jsx)(s.code,{children:"sub()"})," method:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-typescript",children:"const subject = Subject.create(0);\r\n\r\nsubject.sub(value => { console.log(`Value changed to ${value}`); });\r\n\r\nsubject.set(1); // 'Value changed to 1' is logged to the console.\r\nsubject.set(1); // Nothing is logged to the console.\r\nsubject.set(5); // 'Value changed to 5' is logged to the console.\n"})}),"\n",(0,i.jsxs)(s.h3,{id:"using-initialnotify-when-subscribing",children:["Using ",(0,i.jsx)(s.code,{children:"initialNotify"})," when Subscribing"]}),"\n",(0,i.jsxs)(s.p,{children:["In the above example, you may have noticed that nothing was logged to the console when ",(0,i.jsx)(s.code,{children:"sub()"})," was called. This is because by default, ",(0,i.jsx)(s.code,{children:"sub()"})," will not notify the handler of the subscribable's current value when the method is called; the first opportunity for the handler to be notified is the next time the subscribable's value changes ",(0,i.jsx)(s.em,{children:"after"})," calling ",(0,i.jsx)(s.code,{children:"sub()"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:["However, oftentimes you will want a handler to be notified of a subscribable's current value immediately upon subscribing. You can accomplish this by passing ",(0,i.jsx)(s.code,{children:"true"})," to the ",(0,i.jsx)(s.code,{children:"initialNotify"})," parameter of ",(0,i.jsx)(s.code,{children:"sub()"}),":"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-typescript",children:"const subject = Subject.create(0);\r\n\r\nsubject.sub(value => {\r\n  console.log(`Value changed to ${value}`);\r\n}, true); // 'Value changed to 0' is logged to the console.\n"})}),"\n",(0,i.jsx)(s.h3,{id:"managing-subscriptions",children:"Managing Subscriptions"}),"\n",(0,i.jsxs)(s.p,{children:["Calling the ",(0,i.jsx)(s.code,{children:"sub()"})," method returns a ",(0,i.jsx)(s.code,{children:"Subscription"})," object which allows you to manage the new subscription set up by the method. For more information on subscriptions, refer to ",(0,i.jsx)(s.a,{href:"/msfs-avionics-mirror/2024/docs/framework-systems/subscriptions/intro-to-subscriptions",children:"this page"}),"."]}),"\n",(0,i.jsxs)(s.p,{children:["You can use the subscriptions returned by ",(0,i.jsx)(s.code,{children:"sub()"})," to pause and resume notifications. Initial notify on resume is supported and guaranteed to work for all of these subscriptions. You can also use ",(0,i.jsx)(s.code,{children:"sub()"})," to create subscriptions that are initially paused and resume them later when appropriate:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-typescript",children:"const subject = Subject.create(0);\r\n\r\n// Creates a paused subscription. Initially paused subscriptions ignore the `initialNotify` argument,\r\n// so nothing is logged to the console when the subscription is created.\r\nconst sub = subject.sub(value => {\r\n  console.log(`Value changed to ${value}`);\r\n}, true, true);\r\n\r\nsubject.set(5); // Nothing is logged to the console.\r\n\r\nsub.resume(true); // 'Value changed to 5' is logged to the console.\n"})}),"\n",(0,i.jsx)(s.p,{children:"Finally, subscriptions can be destroyed. Once a subscription is destroyed, notifications will no longer be sent to the handler. It is recommended to always destroy subscriptions when they are no longer needed in order to allow the appropriate resources to be garbage collected and prevent memory leaks."}),"\n",(0,i.jsx)(s.h3,{id:"piping-values-to-other-subscribables",children:"Piping Values to Other Subscribables"}),"\n",(0,i.jsxs)(s.p,{children:["If you want to sync the value of one subscribable to another, you can do so using ",(0,i.jsx)(s.code,{children:"sub()"})," and an appropriate handler:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-typescript",children:"const source = Subject.create(1);\r\nconst target = Subject.create(0);\r\n\r\nsource.sub(value => { target.set(value); }, true); // target's value is now 1.\r\n\r\nsource.set(5); // target's value is now 5.\n"})}),"\n",(0,i.jsxs)(s.p,{children:["However, we can avoid the boilerplate associated with the above approach by taking advantage of the ",(0,i.jsx)(s.code,{children:"pipe()"})," method:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-typescript",children:"const source = Subject.create(1);\r\nconst target = Subject.create(0);\r\n\r\nsource.pipe(this.target); // target's value is now 1.\r\n\r\nsource.set(5); // target's value is now 5.\n"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"pipe()"})," sets up a value pipe from one subscribable to another subscribable that implements the ",(0,i.jsx)(s.a,{href:"/msfs-avionics-mirror/2024/docs/api/framework/interfaces/MutableSubscribable",children:(0,i.jsx)(s.code,{children:"MutableSubscribable"})})," interface. The key feature of a ",(0,i.jsx)(s.code,{children:"MutableSubscribable"})," is the presence of a ",(0,i.jsx)(s.code,{children:"set()"})," method. Note that there is no requirement for ",(0,i.jsx)(s.code,{children:"set()"})," to directly set the value of the subscribable, or even that it accept inputs of the same type as the subscribable's value. For example, ",(0,i.jsx)(s.code,{children:"ComputedSubject"})," implements ",(0,i.jsx)(s.code,{children:"MutableSubscribable"})," and is a perfectly valid target for ",(0,i.jsx)(s.code,{children:"pipe()"})," as long as the ",(0,i.jsx)(s.em,{children:"value"})," type of the source subscribable matches the ",(0,i.jsx)(s.em,{children:"input"})," type of the ",(0,i.jsx)(s.code,{children:"ComputedSubject"}),":"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-typescript",children:"const source = Subject.create<number>(1);\r\nconst target = ComputedSubject.create<number, string>(0, value => value.toString());\r\n\r\nsource.pipe(this.target); // target's value is now '1'.\r\n\r\nsource.set(5); // target's value is now '5'.\n"})}),"\n",(0,i.jsxs)(s.p,{children:["You can also specify an optional mapping function to ",(0,i.jsx)(s.code,{children:"pipe()"})," in order to pipe a ",(0,i.jsx)(s.em,{children:"transformed"})," version of the source subscribable's value to the input of the target subscribable:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-typescript",children:"const source = Subject.create(1);\r\nconst target = Subject.create(0);\r\n\r\nsource.pipe(this.target, value => value * 2); // target's value is now 2.\r\n\r\nsource.set(5); // target's value is now 10.\n"})}),"\n",(0,i.jsxs)(s.p,{children:["Like ",(0,i.jsx)(s.code,{children:"sub()"}),", ",(0,i.jsx)(s.code,{children:"pipe()"})," returns a ",(0,i.jsx)(s.code,{children:"Subscription"})," object which can be used to pause, resume, and destroy the newly created pipe. You can also create an initially paused pipe. Importantly, there is no equivalent to ",(0,i.jsx)(s.code,{children:"sub()"}),"'s ",(0,i.jsx)(s.code,{children:"initialNotify"})," parameter. A new pipe ",(0,i.jsx)(s.em,{children:"always"})," immediately pipes the current value of the source subscribable at the time the pipe was created to the target unless it is initially paused."]}),"\n",(0,i.jsxs)(s.admonition,{type:"tip",children:[(0,i.jsx)(s.p,{children:"If for some reason you want to create a pipe without initial notify, you can create a paused pipe and then resume the pipe without initial notify:"}),(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-typescript",children:"source.pipe(target, mapFunc, true).resume();\n"})})]}),"\n",(0,i.jsx)(s.p,{children:'An important caveat to keep in mind is that establishing a pipe does not prevent the value of the target subscribable from being changed through other means, including by other pipes. Therefore, a pipe is only guaranteed to keep the values of the source and target in "sync" if nothing else changes the value of the target:'}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-typescript",children:"const source = Subject.create(1);\r\nconst target = Subject.create(0);\r\n\r\nsource.pipe(target); // target's value is now 1.\r\nsource.set(2);       // target's value is now 2.\r\n\r\ntarget.set(0);       // target's value is now 0.\r\n\r\nsource.set(3);       // target's value is now 3.\n"})}),"\n",(0,i.jsx)(s.h3,{id:"mapping-a-subscribable-to-new-subscribables",children:"Mapping a Subscribable to New Subscribables"}),"\n",(0,i.jsx)(s.p,{children:"In the previous section, we discussed how pipes can be used to sync the transformed value of one subscribable to another. Pipes are useful for mapping transformed values into pre-existing subscribables or when the source and/or target subscribable need to change over time:"}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-typescript",children:"const pipe1 = source1.pipe(target, mapFunc);\r\n// ... time passes\r\npipe1.destroy();\r\nconst pipe2 = source2.pipe(target, mapFunc);\r\n// ... time passes\r\npipe2.destroy();\r\nconst pipe3 = source3.pipe(target, mapFunc);\r\n// ... and so on...\n"})}),"\n",(0,i.jsxs)(s.p,{children:["However, when you are allowed to create a single new subscribable to hold the mapped value and the source never changes, you can use the ",(0,i.jsx)(s.code,{children:"map()"})," method instead:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-typescript",children:"const source = Subject.create(1);\r\n// Map source to twice its value.\r\nconst mapped = source.map(value => value * 2); // mapped's value is initialized to 2.\r\nsource.set(5); // mapped's value is now 10.\n"})}),"\n",(0,i.jsxs)(s.p,{children:[(0,i.jsx)(s.code,{children:"map()"})," creates and returns a new subscribable which implements the ",(0,i.jsx)(s.a,{href:"/msfs-avionics-mirror/2024/docs/api/framework/interfaces/MappedSubscribable",children:(0,i.jsx)(s.code,{children:"MappedSubscribable"})})," interface. The mapped subscribable's value is derived from the source subscribable's value after applying a mapping function. Whenever the source subscribable's value changes and triggers a notification to subscribers, the mapped subscribable's value will automatically be updated. The mapped subscribable can be used just like any other subscribable. You can even chain mapped subscribables ad infinitum:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-typescript",children:"Subject.create(1)\r\n  .map(value => value * 2)\r\n  .map(value => 1 / value)\r\n  .map(value => value.toString()); // The last subscribable is initialized with a value of '0.5'.\n"})}),"\n",(0,i.jsx)(s.admonition,{type:"note",children:(0,i.jsx)(s.p,{children:"Chaining mapped subscribables is only useful when the code creating the downstream mappings don't have control over the upstream mappings or when access to all of the intermediate values is needed. If neither of these conditions is true, then it is more efficient to combine the mapping functions into a single function and collapse the chain to just one mapping step."})}),"\n",(0,i.jsxs)(s.p,{children:["The mapping function passed to ",(0,i.jsx)(s.code,{children:"map()"})," can take an additional optional parameter. This additional parameter is ",(0,i.jsx)(s.code,{children:"undefined"})," the first time the mapping function is called when the mapped subscribable is created. Afterwards, the parameter will provide the value of the mapped subscribable at the time the mapping function was invoked. This additional parameter can be used to map a value with hysteresis:"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-typescript",children:"const source = Subject.create(9);\r\nconst mapped = source.map((value: number, previousVal?: boolean): boolean => {\r\n  return value >= (previousVal === true ? 8 : 10);\r\n}); // mapped's value is initialized to false.\r\nsource.set(20); // mapped's value is now true.\r\nsource.set(9); // mapped's value is still true.\r\nsource.set(0); // mapped's value is now false.\n"})}),"\n",(0,i.jsx)(s.admonition,{type:"tip",children:(0,i.jsxs)(s.p,{children:["The ",(0,i.jsx)(s.a,{href:"/msfs-avionics-mirror/2024/docs/api/framework/classes/SubscribableMapFunctions",children:(0,i.jsx)(s.code,{children:"SubscribableMapFunctions"})})," class can help you to create some common mapping functions."]})}),"\n",(0,i.jsxs)(s.p,{children:["A mapped subscribable implements the ",(0,i.jsx)(s.code,{children:"Subscription"})," interface because it effectively acts as a subscription to its parent subscribable that updates the mapped value. As such, it can be paused, resumed, and destroyed."]}),"\n",(0,i.jsxs)(s.p,{children:["Pausing a mapped subscribable will temporarily stop its value from updating when its source subscribable's value changes until the mapped subscribable is resumed again. Resuming a mapped subscribable always triggers an initial notification from its source (even when ",(0,i.jsx)(s.code,{children:"false"})," is passed as the ",(0,i.jsx)(s.code,{children:"initialNotify"})," argument to ",(0,i.jsx)(s.code,{children:"resume()"}),") - this causes its value to immediately be updated from the current value of its source subscribable. Note that the ",(0,i.jsx)(s.em,{children:"mapped subscribable's"})," subscribers will still only be notified if the resume operation changes the mapped subscribable's value. Once the mapped subscribable is resumed, it will continue to update its value in response to changes in the value of its source subscribable."]}),"\n",(0,i.jsxs)(s.p,{children:["Destroying a mapped subscribable permanently stops its value from updating. Once destroyed, a mapped subscribable can no longer be paused or resumed. The value of a destroyed mapped subscribable can still be accessed via ",(0,i.jsx)(s.code,{children:"get()"}),", subscriptions to it will persist, and new subscriptions can even be created through ",(0,i.jsx)(s.code,{children:"sub()"}),", ",(0,i.jsx)(s.code,{children:"pipe()"}),", and ",(0,i.jsx)(s.code,{children:"map()"}),", but its value will be fixed to whatever it was when the subscribable was destroyed."]}),"\n",(0,i.jsx)(s.admonition,{type:"info",children:(0,i.jsxs)(s.p,{children:["While ",(0,i.jsx)(s.code,{children:"map()"})," allows you to create mappings from one source/input to one output, sometimes you will need to map from multiple inputs to an output. For the latter case, you should use ",(0,i.jsx)(s.a,{href:"/msfs-avionics-mirror/2024/docs/framework-systems/subscriptions/specialized-subscribables#mappedsubject",children:(0,i.jsx)(s.code,{children:"MappedSubject"})})," instead."]})}),"\n",(0,i.jsxs)(s.p,{children:["Mapped subscribables created by ",(0,i.jsx)(s.code,{children:"map()"})," by default use the strict equality operator (",(0,i.jsx)(s.code,{children:"==="}),") to compare values for equality and replace old values with new values by reference. You can choose to override this default behavior by specifying custom equality and mutator functions in the same way you would when creating a new ",(0,i.jsx)(s.code,{children:"Subject"}),":"]}),"\n",(0,i.jsx)(s.pre,{children:(0,i.jsx)(s.code,{className:"language-typescript",children:"const source = Subject.create(1);\r\n// Map source to its natural logarithm.\r\nconst mapped = source.map(Math.log, (a, b) => {\r\n  if (isNaN(a) && isNaN(b)) {\r\n    return true;\r\n  } else {\r\n    return a === b;\r\n  }\r\n});\r\n\r\nmapped.sub(value => {\r\n  console.log(`Value changed to ${value}`);\r\n}, true); // 'Value changed to 0' is logged to the console.\r\n\r\nsource.set(-1); // 'Value changed to NaN' is logged to the console.\r\nsource.set(-2); // Nothing is logged to the console.\n"})}),"\n",(0,i.jsx)(s.admonition,{type:"note",children:(0,i.jsxs)(s.p,{children:["The equality function used to create a mapped subscribable compares ",(0,i.jsx)(s.em,{children:"mapped"})," values, ",(0,i.jsx)(s.strong,{children:"not"})," source values."]})})]})}function d(e={}){let{wrapper:s}={...(0,r.a)(),...e.components};return s?(0,i.jsx)(s,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}},250065:function(e,s,t){t.d(s,{Z:function(){return o},a:function(){return a}});var n=t(667294);let i={},r=n.createContext(i);function a(e){let s=n.useContext(r);return n.useMemo(function(){return"function"==typeof e?e(s):{...s,...e}},[s,e])}function o(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),n.createElement(r.Provider,{value:s},e.children)}}}]);