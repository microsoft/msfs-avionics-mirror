"use strict";(self.webpackChunkdocs_api=self.webpackChunkdocs_api||[]).push([["888521"],{280848:function(e,n,i){i.r(n),i.d(n,{metadata:()=>r,contentTitle:()=>a,default:()=>h,assets:()=>l,toc:()=>c,frontMatter:()=>o});var r=JSON.parse('{"id":"avionics/g3000/features/esp","title":"G3000 Electronic Stability and Protection (ESP)","description":"Introduction","source":"@site/docs/avionics/g3000/features/esp.md","sourceDirName":"avionics/g3000/features","slug":"/avionics/g3000/features/esp","permalink":"/msfs-avionics-mirror/2024/docs/avionics/g3000/features/esp","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_label":"ESP","sidebar_position":2},"sidebar":"sidebar","previous":{"title":"Autopilot","permalink":"/msfs-avionics-mirror/2024/docs/avionics/g3000/features/autopilot"},"next":{"title":"CAS","permalink":"/msfs-avionics-mirror/2024/docs/avionics/g3000/features/cas"}}'),t=i("785893"),s=i("250065");let o={sidebar_label:"ESP",sidebar_position:2},a="G3000 Electronic Stability and Protection (ESP)",l={},c=[{value:"Introduction",id:"introduction",level:2},{value:"Enabling ESP",id:"enabling-esp",level:2},{value:"Accessing ESP Data",id:"accessing-esp-data",level:2},{value:"Defining ESP Parameters",id:"defining-esp-parameters",level:2},{value:"Arming Criteria",id:"arming-criteria",level:3},{value:"Configuring AGL Arming Criteria",id:"configuring-agl-arming-criteria",level:4},{value:"Configuring Pitch/Roll Angle Arming Criteria",id:"configuring-pitchroll-angle-arming-criteria",level:4},{value:"Miscellaneous Arming Critera",id:"miscellaneous-arming-critera",level:4},{value:"Control Force Parameters",id:"control-force-parameters",level:3},{value:"Engagement Time Tracking",id:"engagement-time-tracking",level:3},{value:"Defining ESP Modules",id:"defining-esp-modules",level:2},{value:"Roll Engagement",id:"roll-engagement",level:3},{value:"Roll Limit Indicators",id:"roll-limit-indicators",level:4},{value:"Pitch Engagement",id:"pitch-engagement",level:3},{value:"Airspeed Protection",id:"airspeed-protection",level:3},{value:"Angle of Attack Protection",id:"angle-of-attack-protection",level:3},{value:"Handling Applied ESP Force",id:"handling-applied-esp-force",level:2},{value:"Default ESP Force Handling",id:"default-esp-force-handling",level:3},{value:"Model Behaviors ESP Force Handling",id:"model-behaviors-esp-force-handling",level:3}];function d(e){let n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"g3000-electronic-stability-and-protection-esp",children:"G3000 Electronic Stability and Protection (ESP)"})}),"\n",(0,t.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,t.jsx)(n.p,{children:"The G3000 optionally supports simulation of Garmin's Electronic Stability and Protection (ESP) feature. ESP is a safety feature that automatically applies forces to an airplane's pitch/roll controls to aid in recovery from unusual attitude, overspeed, or underspeed conditions. ESP can only be engaged when the autopilot is off and typically also requires a minimum above-ground height for engagement."}),"\n",(0,t.jsx)(n.p,{children:"The following sections will walk you through how to enable and configure ESP for the G3000."}),"\n",(0,t.jsx)(n.h2,{id:"enabling-esp",children:"Enabling ESP"}),"\n",(0,t.jsx)(n.p,{children:"By default, ESP is disabled. To enable ESP, two things need to be done."}),"\n",(0,t.jsxs)(n.p,{children:["First, the ",(0,t.jsx)(n.a,{href:"/msfs-avionics-mirror/2024/docs/avionics/g3000/panel-xml-tag-documentation#esp",children:(0,t.jsx)(n.code,{children:"<Esp>"})})," tag must be added to ",(0,t.jsx)(n.code,{children:"panel.xml"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["Second, an MFD plugin must return an instance of ",(0,t.jsx)(n.a,{href:"/msfs-avionics-mirror/2024/docs/api/g3000common/type-aliases/G3000EspDefinition",children:(0,t.jsx)(n.code,{children:"G3000EspDefinition"})})," from its ",(0,t.jsxs)(n.a,{href:"/msfs-avionics-mirror/2024/docs/avionics/g3000/mfd-plugins#electronic-stability-and-protection",children:[(0,t.jsx)(n.code,{children:"getEspDefinition()"})," method"]}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"accessing-esp-data",children:"Accessing ESP Data"}),"\n",(0,t.jsxs)(n.p,{children:["When ESP is enabled, the MFD plugin's ",(0,t.jsx)(n.code,{children:"onEspCreated()"})," method is called. The method is passed references to two objects:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["The created ESP instance, which implements ",(0,t.jsx)(n.a,{href:"/msfs-avionics-mirror/2024/docs/api/g3000mfd/interfaces/G3000EspInterface",children:(0,t.jsx)(n.code,{children:"G3000EspInterface"})}),"."]}),"\n",(0,t.jsxs)(n.li,{children:["The provider from which ESP sources its data, which implements ",(0,t.jsx)(n.a,{href:"/msfs-avionics-mirror/2024/docs/api/garminsdk/interfaces/EspDataProvider",children:(0,t.jsx)(n.code,{children:"EspDataProvider"})}),"."]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"A plugin can use these references to observe and react to ESP data."}),"\n",(0,t.jsx)(n.h2,{id:"defining-esp-parameters",children:"Defining ESP Parameters"}),"\n",(0,t.jsxs)(n.p,{children:["ESP parameters are defined by the ",(0,t.jsx)(n.a,{href:"/msfs-avionics-mirror/2024/docs/api/g3000common/type-aliases/G3000EspDefinition",children:(0,t.jsx)(n.code,{children:"G3000EspDefinition"})})," object returned by the MFD plugin's ",(0,t.jsx)(n.code,{children:"getEspDefinition()"})," method."]}),"\n",(0,t.jsx)(n.h3,{id:"arming-criteria",children:"Arming Criteria"}),"\n",(0,t.jsx)(n.p,{children:"ESP must be armed before it can apply control forces during abnormal attitude or speed conditions. Non-configurable criteria for ESP arming include:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Attitude data must be available."}),"\n",(0,t.jsx)(n.li,{children:"The autopilot must be off."}),"\n",(0,t.jsx)(n.li,{children:"The airplane cannot be on the ground."}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"There are also additional configurable arming criteria:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"The airplane's above ground height (AGL)."}),"\n",(0,t.jsx)(n.li,{children:"The airplane's pitch angle."}),"\n",(0,t.jsx)(n.li,{children:"The airplane's roll angle."}),"\n"]}),"\n",(0,t.jsx)(n.h4,{id:"configuring-agl-arming-criteria",children:"Configuring AGL Arming Criteria"}),"\n",(0,t.jsxs)(n.p,{children:["To configure the AGL criteria for arming, use the following properties of ",(0,t.jsx)(n.code,{children:"G3000EspDefinition"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"armAglThreshold"})," (required)"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.code,{children:"disarmAglThreshold"})," (required)"]}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"canArmWhenAglInvalid"})}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"The following example configures ESP to arm when AGL is greater than or equal to 220 feet and disarm when AGL is less than 200 feet. It also allows arming when AGL data is not available."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"import { registerPlugin } from '@microsoft/msfs-sdk';\r\nimport { G3000EspDefinition } from '@microsoft/msfs-wtg3000-common';\r\nimport { AbstractG3000MfdPlugin } from '@microsoft/msfs-wtg3000-mfd';\r\n\r\nclass EspPlugin extends AbstractG3000MfdPlugin {\r\n\r\n  public getEspDefinition(): G3000EspDefinition {\r\n    return {\r\n      armAglThreshold: 220,\r\n      disarmAglThreshold: 200,\r\n      canArmWhenAglInvalid: true,\r\n      // ...\r\n    };\r\n  }\r\n\r\n}\r\n\r\nregisterPlugin(EspPlugin);\n"})}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsx)(n.p,{children:"AGL data is sourced from GPS/FMS position data."})}),"\n",(0,t.jsx)(n.h4,{id:"configuring-pitchroll-angle-arming-criteria",children:"Configuring Pitch/Roll Angle Arming Criteria"}),"\n",(0,t.jsxs)(n.p,{children:["To configure the pitch and roll angle criteria for arming, use the following properties of ",(0,t.jsx)(n.code,{children:"G3000EspDefinition"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"armMinPitchLimit"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"armMaxPitchLimit"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"armRollLimit"})}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"The following example configures ESP to arm only when pitch angle is between -50 and 50 degrees and when roll angle is less than or equal to 75 degrees."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"import { registerPlugin } from '@microsoft/msfs-sdk';\r\nimport { G3000EspDefinition } from '@microsoft/msfs-wtg3000-common';\r\nimport { AbstractG3000MfdPlugin } from '@microsoft/msfs-wtg3000-mfd';\r\n\r\nclass EspPlugin extends AbstractG3000MfdPlugin {\r\n\r\n  public getEspDefinition(): G3000EspDefinition {\r\n    return {\r\n      armMinPitchLimit: -50,\r\n      armMaxPitchLimit: 50,\r\n      armRollLimit: 75,\r\n      // ...\r\n    };\r\n  }\r\n\r\n}\r\n\r\nregisterPlugin(EspPlugin);\n"})}),"\n",(0,t.jsx)(n.admonition,{type:"warning",children:(0,t.jsxs)(n.p,{children:["Pitch angles for ESP use the sim's sign convention for pitch: ",(0,t.jsx)(n.em,{children:"positive"})," angles represent ",(0,t.jsx)(n.em,{children:"downward"})," pitch."]})}),"\n",(0,t.jsx)(n.h4,{id:"miscellaneous-arming-critera",children:"Miscellaneous Arming Critera"}),"\n",(0,t.jsxs)(n.p,{children:["In addition to the built-in arming criteria, you can define additional miscellaneous arming criteria by using the ",(0,t.jsx)(n.code,{children:"isArmingInhibited"})," property of ",(0,t.jsx)(n.code,{children:"G3000EspDefinition"}),". This optional property accepts a boolean-valued ",(0,t.jsx)(n.a,{href:"/msfs-avionics-mirror/2024/docs/api/framework/interfaces/Accessible",children:(0,t.jsx)(n.code,{children:"Accessible"})})," that controls whether arming is inhibited. Arming will be inhibited as long as the accessible's value is ",(0,t.jsx)(n.code,{children:"true"}),". When the accessible's value is ",(0,t.jsx)(n.code,{children:"false"}),", arming is still subject to the built-in arming criteria."]}),"\n",(0,t.jsxs)(n.p,{children:["If ",(0,t.jsx)(n.code,{children:"isArmingInhibited"})," is not defined, then only the built-in arming criteria are used."]}),"\n",(0,t.jsx)(n.h3,{id:"control-force-parameters",children:"Control Force Parameters"}),"\n",(0,t.jsxs)(n.p,{children:["ESP applies force to the airplane's pitch and roll controls to aid in recovery when the airplane exceeds certain attitude or speed limits. The way this is implemented in the sim is that when ESP applies a force to a control axis (either pitch or roll), the control axis position that commands a neutral control surface position (aka the ",(0,t.jsx)(n.strong,{children:"neutral command"}),' position) is moved away from the neutral control axis position in the direction opposite to the force being applied. The end result is that at the neutral control axis position, control surfaces are deflected as if the control axis were being "pushed" in the direction of the force, and the user must apply opposite input to return the associated control surface to the neutral position.']}),"\n",(0,t.jsxs)(n.p,{children:["Due to the above implementation, the force applied by ESP is defined in terms of how far it moves the neutral command position away from the neutral control axis position (or equivalently, how much control surface deflection is commanded by the neutral control axis position while the force is applied). A force of magnitude ",(0,t.jsx)(n.code,{children:"1"})," moves the neutral command position to the maximum control axis extent (or equivalently, the neutral control axis position commands maximum control surface deflection). A force of magnitude ",(0,t.jsx)(n.code,{children:"0.5"})," moves the neutral command position to half the maximum control axis extent, etc."]}),"\n",(0,t.jsxs)(n.p,{children:["The following properties of ",(0,t.jsx)(n.code,{children:"G3000EspDefinition"})," are used to customize the amount of force ESP applies:"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"pitchAxisMaxForceUp"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"pitchAxisMaxForceDown"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"pitchAxisForceRate"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"pitchAxisUnloadRate"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"rollAxisMaxForce"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"rollAxisForceRate"})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsx)(n.code,{children:"rollAxisUnloadRate"})}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"The maximum force properties control the maximum amount of force ESP can apply to a control axis (for the pitch axis, the maximum is defined separately for pitch-up and pitch-down forces). The force rate properties control how quickly ESP can change the amount of force it applies to a control axis while it is armed. The unload rate properties control how quickly ESP can remove force when it changes from armed to disarmed. All rate properties are defined in units of force per second."}),"\n",(0,t.jsx)(n.h3,{id:"engagement-time-tracking",children:"Engagement Time Tracking"}),"\n",(0,t.jsx)(n.p,{children:"ESP can track the amount of time it has been engaged on a rolling basis. ESP is considered engaged when it is applying force to a control axis. Engagement time is usually used to activate the autopilot's LVL mode once engagement time within the rolling window exceeds a certain threshold."}),"\n",(0,t.jsxs)(n.p,{children:["The window size for engagement time tracking can be configured with the ",(0,t.jsx)(n.code,{children:"engagementTimeWindow"})," property of ",(0,t.jsx)(n.code,{children:"G3000EspDefinition"}),". For example, a value of ",(0,t.jsx)(n.code,{children:"20"})," will cause ESP to track the amount of time it has been engaged for the past 20 seconds. Engagement time data can be accessed from the ",(0,t.jsx)(n.a,{href:"#accessing-esp-data",children:"ESP instance"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"A value less than or equal to zero disables engagement time tracking (the default)."}),"\n",(0,t.jsx)(n.h2,{id:"defining-esp-modules",children:"Defining ESP Modules"}),"\n",(0,t.jsxs)(n.p,{children:["The logic that allows ESP to apply force in response to limits being exceeded is provided by ",(0,t.jsx)(n.strong,{children:"modules"}),". ESP does not include any modules by default, so it is up to the plugin to define and add modules to ESP."]}),"\n",(0,t.jsxs)(n.p,{children:["Modules are added to ESP by including factories that create and return modules in the ",(0,t.jsx)(n.code,{children:"moduleFactories"})," property of ",(0,t.jsx)(n.code,{children:"G3000EspDefinition"}),". Generally, each module is responsible for applying force in response to a single type of limit exceedance. Modules must implement the ",(0,t.jsx)(n.a,{href:"/msfs-avionics-mirror/2024/docs/api/garminsdk/interfaces/EspModule",children:(0,t.jsx)(n.code,{children:"EspModule"})})," interface."]}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsx)(n.p,{children:"If multiple modules apply force to the same control axis simultaneously, then the forces are summed."})}),"\n",(0,t.jsxs)(n.p,{children:["You can create modules from scratch if you wish. However, it is recommended to use one of the pre-defined modules provided in ",(0,t.jsx)(n.code,{children:"msfs-garminsdk"})," for convenience. The following subsections will describe how to use the pre-defined modules to implement the most commonly encountered real-world ESP behaviors."]}),"\n",(0,t.jsx)(n.h3,{id:"roll-engagement",children:"Roll Engagement"}),"\n",(0,t.jsx)(n.p,{children:"Roll engagement protects against excessive roll angles. When roll angle (in either direction) exceeds a threshold value, roll engagement will apply a force to the roll axis in the opposite direction. The magnitude of the force is typically proportional to the amount by which roll angle has exceeded the limit. Force is applied until roll angle is reduced below a threshold value that is usually lower than the threshold for engagement."}),"\n",(0,t.jsxs)(n.p,{children:["Roll engagement is implemented by ",(0,t.jsx)(n.a,{href:"/msfs-avionics-mirror/2024/docs/api/garminsdk/classes/EspRollModule",children:(0,t.jsx)(n.code,{children:"EspRollModule"})}),". The following example shows how to add a typical roll engagement setup to ESP using ",(0,t.jsx)(n.code,{children:"EspRollModule"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"import { MathUtils, registerPlugin } from '@microsoft/msfs-sdk';\r\nimport { EspData, EspRollModule } from '@microsoft/msfs-garminsdk';\r\nimport { G3000EspDefinition } from '@microsoft/msfs-wtg3000-common';\r\nimport { AbstractG3000MfdPlugin } from '@microsoft/msfs-wtg3000-mfd';\r\n\r\nclass EspPlugin extends AbstractG3000MfdPlugin {\r\n\r\n  public getEspDefinition(): G3000EspDefinition {\r\n    return {\r\n      // ...\r\n      moduleFactories: [\r\n        () => new EspRollModule(\r\n          'roll', // ID is used to identify the module. Must be unique.\r\n          {\r\n            engageRoll: 45, // Roll angle threshold for engagement\r\n            disengageRoll: 30, // Roll angle threshold for disengagement\r\n            getForceToApply: (data: Readonly<EspData>): number => {\r\n              // Applies a force in the direction opposite to the airplane's current roll angle.\r\n              // The magnitude of the force increases from a minimum of 0.1 at 30 degrees of roll\r\n              // to a maximum of 0.3 at 60 degrees roll.\r\n              return -Math.sign(data.roll) * MathUtils.lerp(Math.abs(data.roll), 30, 60, 0.1, 0.3, true, true);\r\n            },\r\n            canEngageWhenAglInvalid: true // Allow this module to engage when AGL data is invalid\r\n          }\r\n        )\r\n      ]\r\n    };\r\n  }\r\n\r\n}\r\n\r\nregisterPlugin(EspPlugin);\n"})}),"\n",(0,t.jsx)(n.h4,{id:"roll-limit-indicators",children:"Roll Limit Indicators"}),"\n",(0,t.jsx)(n.p,{children:"ESP roll engagement is typically accompanied by roll limit indicators on the PFD attitude indicator:"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"Roll Limit Indicators",src:i(75708).Z+"",width:"436",height:"312"})}),"\n",(0,t.jsx)(n.p,{children:"The roll limit indicators are generally used to depict the threshold for roll engagement when roll engagement is not active, and they move to depict the threshold for roll engagement deactivation when roll engagement is active."}),"\n",(0,t.jsxs)(n.p,{children:["To configure roll limit indicators with the above behavior, you can bind the roll limit indicators to specific event bus topics via ",(0,t.jsx)(n.a,{href:"/msfs-avionics-mirror/2024/docs/avionics/g3000/panel-xml-tag-documentation#rolllimit-horizon",children:(0,t.jsx)(n.code,{children:"panel.xml"})}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-xml",children:"<Horizon>\r\n  <RollLimit>\r\n    <LeftRoll>\r\n      <Bus>esp_roll_limit_indicator_left_limit</Bus>\r\n    </LeftRoll>\r\n    <RightRoll>\r\n      <Bus>esp_roll_limit_indicator_right_limit</Bus>\r\n    </RightRoll>\r\n  </RollLimit>\r\n</Horizon>\n"})}),"\n",(0,t.jsx)(n.p,{children:"Then use a plugin to publish the appropriate values to the event bus topics based on the state of ESP:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"import { ClockEvents, registerPlugin, Subject } from '@microsoft/msfs-sdk';\r\nimport { EspData, EspDataProvider, EspOperatingMode, EspRollModule } from '@microsoft/msfs-garminsdk';\r\nimport { G3000EspInterface } from '@microsoft/msfs-wtg3000-common';\r\nimport { AbstractG3000MfdPlugin } from '@microsoft/msfs-wtg3000-mfd';\r\n\r\nclass EspPlugin extends AbstractG3000MfdPlugin {\r\n\r\n  public onEspCreated(esp: G3000EspInterface, dataProvider: EspDataProvider): void {\r\n    const rollModule = esp.getModule('roll') as EspRollModule;\r\n\r\n    const leftRollLimit = Subject.create<number>(NaN, SubscribableUtils.NUMERIC_NAN_EQUALITY);\r\n    const rightRollLimit = Subject.create<number>(NaN, SubscribableUtils.NUMERIC_NAN_EQUALITY);\r\n\r\n    leftRollLimit.sub(limit => { this.binder.bus.pub('esp_roll_limit_indicator_left_limit', limit, true, true); }, true);\r\n    rightRollLimit.sub(limit => { this.binder.bus.pub('esp_roll_limit_indicator_right_limit', limit, true, true); }, true);\r\n\r\n    this.binder.bus.getSubscriber<ClockEvents>().sub('realTime')\r\n      .handle(() => {\r\n        if (esp.operatingMode.get() === EspOperatingMode.Armed) {\r\n          const engageData = rollModule.getEngageData();\r\n          leftRollLimit.set(engageData.engageMode === 'left' ? engageData.disengageRoll : engageData.engageRoll);\r\n          rightRollLimit.set(engageData.engageMode === 'right' ? engageData.disengageRoll : engageData.engageRoll);\r\n        } else {\r\n          // Hide the roll limit indicators when ESP is not armed.\r\n          leftRollLimit.set(NaN);\r\n          rightRollLimit.set(NaN);\r\n        }\r\n      });\r\n  }\r\n\r\n}\r\n\r\nregisterPlugin(EspPlugin);\n"})}),"\n",(0,t.jsx)(n.h3,{id:"pitch-engagement",children:"Pitch Engagement"}),"\n",(0,t.jsx)(n.p,{children:"Pitch engagement protects against excessive pitch angles. When pitch angle in a certain direction exceeds a threshold value, pitch engagement will apply a force to the pitch axis in the opposite direction. The magnitude of the force is typically dependent on the pitch angle and the direction of pitch travel. Force is applied until pitch angle is reduced below a threshold value that is usually lower than the threshold for engagement."}),"\n",(0,t.jsx)(n.p,{children:"Pitch engagement can be applied to excessive pitch up angles, excessive pitch down angles, both, or neither."}),"\n",(0,t.jsxs)(n.p,{children:["Pitch engagement is implemented by ",(0,t.jsx)(n.a,{href:"/msfs-avionics-mirror/2024/docs/api/garminsdk/classes/EspPitchModule",children:(0,t.jsx)(n.code,{children:"EspPitchModule"})}),". Each instance of ",(0,t.jsx)(n.code,{children:"EspPitchModule"})," implements pitch engagement for one direction (up or down) of excessive pitch angle. The following example shows how to add a typical pitch engagement setup (both directions) to ESP using ",(0,t.jsx)(n.code,{children:"EspPitchModule"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"import { MathUtils, registerPlugin } from '@microsoft/msfs-sdk';\r\nimport { EspData, EspPitchModule } from '@microsoft/msfs-garminsdk';\r\nimport { G3000EspDefinition } from '@microsoft/msfs-wtg3000-common';\r\nimport { AbstractG3000MfdPlugin } from '@microsoft/msfs-wtg3000-mfd';\r\n\r\nclass EspPlugin extends AbstractG3000MfdPlugin {\r\n\r\n  public getEspDefinition(): G3000EspDefinition {\r\n    return {\r\n      // ...\r\n      moduleFactories: [\r\n        () => new EspPitchModule(\r\n          'pitch-up', // ID is used to identify the module. Must be unique.\r\n          {\r\n            exceedDirection: 'up', // Module is configured for excessive pitch up engagement\r\n            engagePitch: -20, // Pitch angle threshold for engagement\r\n            disengagePitch: -15, // Pitch angle threshold for disengagement\r\n            getForceToApply: (data: Readonly<EspData>): number => {\r\n              // Applies a force in the direction opposite to the airplane's current pitch angle.\r\n              // The magnitude of the force increases as the magnitude of the pitch angle increases\r\n              // and decreases as the rate of change of pitch angle increases toward neutral pitch.\r\n              const pitchForce = MathUtils.lerp(data.pitch, -15, -25, 0.1, 0.3, true, true);\r\n              const pitchRateForce = data.pitchRate * -0.02;\r\n              return MathUtils.clamp(pitchForce + pitchRateForce, 0.1, 0.3);\r\n            },\r\n            canEngageWhenAglInvalid: false // Do not allow this module to engage when AGL data is invalid\r\n          }\r\n        ),\r\n        () => new EspPitchModule(\r\n          'pitch-down', // ID is used to identify the module. Must be unique.\r\n          {\r\n            exceedDirection: 'down', // Module is configured for excessive pitch down engagement\r\n            engagePitch: 22, // Pitch angle threshold for engagement\r\n            disengagePitch: 12, // Pitch angle threshold for disengagement\r\n            getForceToApply: (data: Readonly<EspData>): number => {\r\n              // Applies a force in the direction opposite to the airplane's current pitch angle.\r\n              // The magnitude of the force increases as the magnitude of the pitch angle increases\r\n              // and decreases as the rate of change of pitch angle increases toward neutral pitch.\r\n              const pitchForce = MathUtils.lerp(data.pitch, 12, 27, -0.1, -0.3, true, true);\r\n              const pitchRateForce = data.pitchRate * -0.02;\r\n              return MathUtils.clamp(pitchForce + pitchRateForce, -0.1, -0.3);\r\n            },\r\n            canEngageWhenAglInvalid: true // Allow this module to engage when AGL data is invalid\r\n          }\r\n        )\r\n      ]\r\n    };\r\n  }\r\n\r\n}\r\n\r\nregisterPlugin(EspPlugin);\n"})}),"\n",(0,t.jsx)(n.admonition,{type:"warning",children:(0,t.jsxs)(n.p,{children:["Pitch angles for ESP use the sim's sign convention for pitch: ",(0,t.jsx)(n.em,{children:"positive"})," angles represent ",(0,t.jsx)(n.em,{children:"downward"})," pitch."]})}),"\n",(0,t.jsx)(n.h3,{id:"airspeed-protection",children:"Airspeed Protection"}),"\n",(0,t.jsx)(n.p,{children:"Airspeed protection combats excessively high or low airspeed. When airspeed in a certain direction exceeds a threshold value, airspeed protection will apply a force to the pitch axis to raise or lower the nose in an attempt to decrease or increase airspeed. The magnitude of the force is typically proportional to the amount by which airspeed has exceeded the limit. Force is applied until airspeed is brought back within a threshold value that is usually more stringent than the threshold for engagement."}),"\n",(0,t.jsx)(n.p,{children:"Airspeed protection can be applied to high airspeeds, low airspeeds, both, or neither."}),"\n",(0,t.jsxs)(n.p,{children:["Airspeed protection is implemented by ",(0,t.jsx)(n.a,{href:"/msfs-avionics-mirror/2024/docs/api/garminsdk/classes/EspAirspeedModule",children:(0,t.jsx)(n.code,{children:"EspAirspeedModule"})}),". Each instance of ",(0,t.jsx)(n.code,{children:"EspAirspeedModule"})," implements airspeed protection for one direction (high or low) of excessive airspeed. The following example shows how to add a typical airspeed protection setup (both directions) to ESP using ",(0,t.jsx)(n.code,{children:"EspAirspeedModule"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"import { MathUtils, registerPlugin } from '@microsoft/msfs-sdk';\r\nimport { EspAirspeedModule, EspData } from '@microsoft/msfs-garminsdk';\r\nimport { G3000EspDefinition } from '@microsoft/msfs-wtg3000-common';\r\nimport { AbstractG3000MfdPlugin } from '@microsoft/msfs-wtg3000-mfd';\r\n\r\nclass EspPlugin extends AbstractG3000MfdPlugin {\r\n\r\n  public getEspDefinition(): G3000EspDefinition {\r\n    return {\r\n      // ...\r\n      moduleFactories: [\r\n        () => new EspAirspeedModule(\r\n          'airspeed-high', // ID is used to identify the module. Must be unique.\r\n          {\r\n            exceedDirection: 'high', // Module is configured for engagement for excessively high airspeeds\r\n            engageIas: 250, // indicated airspeed threshold for engagement\r\n            disengageIas: 240, // indicated airspeed threshold for disengagement\r\n            getForceToApply: (data: Readonly<EspData>): number => {\r\n              // Applies a force to raise the nose. The magnitude of the force increases from\r\n              // a minimum of 0.1 at 240 knots to a maximum of 0.3 at 270 knots.\r\n              return MathUtils.lerp(data.ias, 240, 270, -0.1, -0.3, true, true);\r\n            },\r\n            canEngageWhenAglInvalid: true // Allow this module to engage when AGL data is invalid\r\n          }\r\n        ),\r\n        () => new EspAirspeedModule(\r\n          'airspeed-low', // ID is used to identify the module. Must be unique.\r\n          {\r\n            exceedDirection: 'low', // Module is configured for engagement for excessively low airspeeds\r\n            engageIas: 75, // indicated airspeed threshold for engagement\r\n            disengageIas: 85, // indicated airspeed threshold for disengagement\r\n            getForceToApply: (data: Readonly<EspData>): number => {\r\n              // Applies a force to lower the nose. The magnitude of the force increases from\r\n              // a minimum of 0.1 at 85 knots to a maximum of 0.3 at 65 knots.\r\n              return MathUtils.lerp(data.ias, 85, 65, 0.1, 0.3, true, true);\r\n            },\r\n            canEngageWhenAglInvalid: false // Do not allow this module to engage when AGL data is invalid\r\n          }\r\n        )\r\n      ]\r\n    };\r\n  }\r\n\r\n}\r\n\r\nregisterPlugin(EspPlugin);\n"})}),"\n",(0,t.jsx)(n.admonition,{type:"warning",children:(0,t.jsxs)(n.p,{children:["Pitch angles for ESP use the sim's sign convention for pitch: ",(0,t.jsx)(n.em,{children:"positive"})," angles represent ",(0,t.jsx)(n.em,{children:"downward"})," pitch."]})}),"\n",(0,t.jsx)(n.h3,{id:"angle-of-attack-protection",children:"Angle of Attack Protection"}),"\n",(0,t.jsx)(n.p,{children:"Angle of attack protection combats excessively high angle of attack (AOA). When AOA exceeds a threshold value, AOA protection will apply a force to the pitch axis to lower the nose. The magnitude of the force is typically proportional to the amount by which AOA has exceeded the limit. Force is applied until AOA is brought back within a threshold value that is usually lower than the threshold for engagement."}),"\n",(0,t.jsxs)(n.p,{children:["AOA protection is implemented by ",(0,t.jsx)(n.a,{href:"/msfs-avionics-mirror/2024/docs/api/garminsdk/classes/EspAoaModule",children:(0,t.jsx)(n.code,{children:"EspAoaModule"})}),". The following example shows how to add a typical AOA protection setup to ESP using ",(0,t.jsx)(n.code,{children:"EspAoaModule"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"import { MathUtils, registerPlugin } from '@microsoft/msfs-sdk';\r\nimport { EspAoaModule, EspData } from '@microsoft/msfs-garminsdk';\r\nimport { G3000EspDefinition } from '@microsoft/msfs-wtg3000-common';\r\nimport { AbstractG3000MfdPlugin } from '@microsoft/msfs-wtg3000-mfd';\r\n\r\nclass EspPlugin extends AbstractG3000MfdPlugin {\r\n\r\n  public getEspDefinition(): G3000EspDefinition {\r\n    return {\r\n      // ...\r\n      moduleFactories: [\r\n        () => new EspAoaModule(\r\n          'aoa', // ID is used to identify the module. Must be unique.\r\n          {\r\n            engageAoa: 22, // AOA threshold (degrees) for engagement\r\n            disengageAoa: 20, // AOA threshold (degrees) for disengagement\r\n            getForceToApply: (data: Readonly<EspData>): number => {\r\n              // Applies a force to lower the nose. The magnitude of the force increases from\r\n              // a minimum of 0.1 at 20 degrees AOA to a maximum of 0.3 at 25 degrees AOA.\r\n              return MathUtils.lerp(data.aoa, 20, 25, 0.1, 0.3, true, true);\r\n            },\r\n            canEngageWhenAglInvalid: false // Do not allow this module to engage when AGL data is invalid\r\n          }\r\n        )\r\n      ]\r\n    };\r\n  }\r\n\r\n}\r\n\r\nregisterPlugin(EspPlugin);\n"})}),"\n",(0,t.jsx)(n.admonition,{type:"warning",children:(0,t.jsxs)(n.p,{children:["Pitch angles for ESP use the sim's sign convention for pitch: ",(0,t.jsx)(n.em,{children:"positive"})," angles represent ",(0,t.jsx)(n.em,{children:"downward"})," pitch."]})}),"\n",(0,t.jsx)(n.h2,{id:"handling-applied-esp-force",children:"Handling Applied ESP Force"}),"\n",(0,t.jsx)(n.p,{children:"When ESP applies a force to a control axis, this force must be handled in some way to make the control axis behave appropriately as if the force were applied. Without any handling, ESP force won't have any effect on the pitch and roll control axes."}),"\n",(0,t.jsx)(n.p,{children:"By default, when ESP is enabled, it creates a manager that adjusts how pitch and roll control axis inputs are interpreted to obtain the desired behavior for applied ESP forces. This manager requires no additional setup. However, because the manager runs in the JS environment and uses key event intercepts to reinterpret control axis inputs, it incurs a small but non-negligible input delay (roughly 2 frames, which translates to ~66 milliseconds at an average framerate of 30)."}),"\n",(0,t.jsxs)(n.p,{children:["If this input delay is not acceptable, then you may opt to use an alternate strategy for handling ESP force that relies on XML ",(0,t.jsx)(n.a,{href:"https://docs.flightsimulator.com/msfs2024/html/5_Content_Configuration/Models/ModelBehaviors/Model_Behaviors.htm",children:"model behaviors"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"The following subsections describe how to use the default and model behaviors strategies."}),"\n",(0,t.jsx)(n.h3,{id:"default-esp-force-handling",children:"Default ESP Force Handling"}),"\n",(0,t.jsxs)(n.p,{children:["To use the default handling strategy, ensure that the ",(0,t.jsx)(n.code,{children:"omitControlInputManager"})," property of ",(0,t.jsx)(n.code,{children:"G3000EspDefinition"})," is set to ",(0,t.jsx)(n.code,{children:"false"}),". If the property is left undefined, it will default to ",(0,t.jsx)(n.code,{children:"false"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["Next, control axis input handling can be configured using the ",(0,t.jsx)(n.code,{children:"controlInputManagerOptions"})," property of ",(0,t.jsx)(n.code,{children:"G3000EspDefinition"}),". This property accepts an instance of ",(0,t.jsx)(n.a,{href:"/msfs-avionics-mirror/2024/docs/api/garminsdk/type-aliases/EspControlInputManagerOptions",children:(0,t.jsx)(n.code,{children:"EspControlInputManagerOptions"})}),". Most options should be left to their default values, since the defaults were chosen to replicate the sim's native handling of control axis inputs. However, it is recommended (but not required) to manually configure the options in the following example code:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"import { registerPlugin } from '@microsoft/msfs-sdk';\r\nimport { G3000EspDefinition } from '@microsoft/msfs-wtg3000-common';\r\nimport { AbstractG3000MfdPlugin } from '@microsoft/msfs-wtg3000-mfd';\r\n\r\nclass EspPlugin extends AbstractG3000MfdPlugin {\r\n\r\n  public getEspDefinition(): G3000EspDefinition {\r\n    return {\r\n      // ...\r\n      omitControlInputManager: false,\r\n      controlInputManagerOptions: {\r\n\r\n        pitchAxisIncrOptions: {\r\n          oneHalfTas: 100,\r\n          oneEighthTas: 180\r\n        },\r\n\r\n        rollAxisIncrOptions: {\r\n          oneHalfTas: 200,\r\n          oneEighthTas: 1000\r\n        }\r\n\r\n      }\r\n    };\r\n  }\r\n\r\n}\r\n\r\nregisterPlugin(EspPlugin);\n"})}),"\n",(0,t.jsxs)(n.p,{children:["When processing inputs that increment or decrement the control axis position, the above options define the the true airspeeds, in knots, at which the input increment is reduced to one-half and one-eighth the base amount. For best results, these parameters should be set to match what is defined in the ",(0,t.jsx)(n.a,{href:"https://docs.flightsimulator.com/msfs2024/html/5_Content_Configuration/CFG_Files/gameplay_cfg.htm",children:(0,t.jsx)(n.code,{children:"gameplay.cfg"})})," file's ",(0,t.jsx)(n.code,{children:"elevator"})," (pitch) and ",(0,t.jsx)(n.code,{children:"aileron"})," (roll) parameters, under the ",(0,t.jsx)(n.code,{children:"[KEYBOARD_RESPONSE]"})," section."]}),"\n",(0,t.jsx)(n.h3,{id:"model-behaviors-esp-force-handling",children:"Model Behaviors ESP Force Handling"}),"\n",(0,t.jsxs)(n.p,{children:["To use the model behaviors handling strategy, first disable the default handling by setting the ",(0,t.jsx)(n.code,{children:"omitControlInputManager"})," property of ",(0,t.jsx)(n.code,{children:"G3000EspDefinition"})," to ",(0,t.jsx)(n.code,{children:"true"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"import { registerPlugin } from '@microsoft/msfs-sdk';\r\nimport { G3000EspDefinition } from '@microsoft/msfs-wtg3000-common';\r\nimport { AbstractG3000MfdPlugin } from '@microsoft/msfs-wtg3000-mfd';\r\n\r\nclass EspPlugin extends AbstractG3000MfdPlugin {\r\n\r\n  public getEspDefinition(): G3000EspDefinition {\r\n    return {\r\n      // ...\r\n      omitControlInputManager: true\r\n    };\r\n  }\r\n\r\n}\r\n\r\nregisterPlugin(EspPlugin);\n"})}),"\n",(0,t.jsx)(n.p,{children:"Next, publish the applied ESP forces to two scoped LVars. The LVars can be named as you wish, but the recommended names are given in the example code below:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"import { registerPlugin, SimVarValueType } from '@microsoft/msfs-sdk';\r\nimport { EspData, EspDataProvider } from '@microsoft/msfs-garminsdk';\r\nimport { G3000EspInterface } from '@microsoft/msfs-wtg3000-common';\r\nimport { AbstractG3000MfdPlugin } from '@microsoft/msfs-wtg3000-mfd';\r\n\r\nclass EspPlugin extends AbstractG3000MfdPlugin {\r\n\r\n  public onEspCreated(esp: G3000EspInterface, dataProvider: EspDataProvider): void {\r\n    esp.pitchAxisForce.sub(force => {\r\n      SimVar.SetSimVarValue('L:1:Esp_Pitch_Control_Axis_Force', SimVarValueType.Number, force);\r\n    }, true);\r\n\r\n    esp.rollAxisForce.sub(force => {\r\n      SimVar.SetSimVarValue('L:1:Esp_Roll_Control_Axis_Force', SimVarValueType.Number, force);\r\n    }, true);\r\n  }\r\n\r\n}\r\n\r\nregisterPlugin(EspPlugin);\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Finally, use the ",(0,t.jsx)(n.code,{children:"WT_G3000_ESP_Pitch_Control_Axis_Template"})," and ",(0,t.jsx)(n.code,{children:"WT_G3000_ESP_Roll_Control_Axis_Template"})," model behaviors templates in your airplane. These templates can be imported from the G3000 ",(0,t.jsx)(n.code,{children:"ESP.xml"})," model behaviors file included in the SDK:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-xml",children:'<Include ModelBehaviorFile="WorkingTitle\\GlassCockpit\\G3000v2\\BehaviorsV1\\ESP.xml"/>\n'})}),"\n",(0,t.jsxs)(n.p,{children:["The templates can be used in either interior or exterior model behaviors. If you are using the ",(0,t.jsx)(n.a,{href:"https://docs.flightsimulator.com/msfs2024/html/5_Content_Configuration/Modular_SimObjects/Modular_SimObjects.htm",children:"modular SimObject format"})," for your airplane, the templates can be used in any attachment, as long as the attachment is ",(0,t.jsx)(n.a,{href:"https://docs.flightsimulator.com/msfs2024/html/5_Content_Configuration/CFG_Files/attached_objects.htm#SIM_ATTACHMENT",children:"set to always run its model behaviors"}),"."]}),"\n",(0,t.jsxs)(n.p,{children:["When using the templates, you must provide the names of the LVars (without the ",(0,t.jsx)(n.code,{children:"L:1:"})," prefix) to which the ESP force values have been published (this can be omitted if you used the recommended LVar names in the above example). Additionally, it is recommended to provide the following parameters:"]}),"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Parameter"}),(0,t.jsx)(n.th,{children:"Description"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"INCR_RESP_HALF_TAS"})}),(0,t.jsx)(n.td,{children:"When processing inputs that increment or decrement the control axis position: the true airspeed, in knots, at which the input increment is reduced to one-half the base amount. A value less than or equal to zero disables all adjustments to the increment based on airspeed. Defaults to 0."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"INCR_RESP_EIGHTH_TAS"})}),(0,t.jsx)(n.td,{children:"When processing inputs that increment or decrement the control axis position: the true airspeed, in knots, at which the input increment is reduced to one-eighth the base amount. Defaults to 0."})]})]})]}),"\n",(0,t.jsxs)(n.p,{children:["For best results, these parameters should be set to match what is defined in the ",(0,t.jsx)(n.a,{href:"https://docs.flightsimulator.com/msfs2024/html/5_Content_Configuration/CFG_Files/gameplay_cfg.htm",children:(0,t.jsx)(n.code,{children:"gameplay.cfg"})})," file's ",(0,t.jsx)(n.code,{children:"elevator"})," (pitch) and ",(0,t.jsx)(n.code,{children:"aileron"})," (roll) parameters, under the ",(0,t.jsx)(n.code,{children:"[KEYBOARD_RESPONSE]"})," section."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-xml",children:'<UseTemplate Name="WT_G3000_ESP_Pitch_Control_Axis_Template">\r\n  <FORCE_VAR>Esp_Pitch_Control_Axis_Force</FORCE_VAR>\r\n  <INCR_RESP_HALF_TAS>100</INCR_RESP_HALF_TAS>\r\n  <INCR_RESP_EIGHTH_TAS>180</INCR_RESP_EIGHTH_TAS>\r\n</UseTemplate>\r\n<UseTemplate Name="WT_G3000_ESP_Roll_Control_Axis_Template">\r\n  <FORCE_VAR>Esp_Roll_Control_Axis_Force</FORCE_VAR>\r\n  <INCR_RESP_HALF_TAS>200</INCR_RESP_HALF_TAS>\r\n  <INCR_RESP_EIGHTH_TAS>1000</INCR_RESP_EIGHTH_TAS>\r\n</UseTemplate>\n'})}),"\n",(0,t.jsx)(n.p,{children:"The templates accept additional parameters that can be used to adjust how control axis input events are processed. It is recommended to omit these parameters in order to use their default values, since the defaults were chosen to replicate the sim's native handling of control axis inputs."})]})}function h(e={}){let{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},75708:function(e,n,i){i.d(n,{Z:function(){return r}});let r=i.p+"assets/images/roll-limit-indicators-dcef9da3e5702142a4ede06c5a0fb1ea.jpg"},250065:function(e,n,i){i.d(n,{Z:function(){return a},a:function(){return o}});var r=i(667294);let t={},s=r.createContext(t);function o(e){let n=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);