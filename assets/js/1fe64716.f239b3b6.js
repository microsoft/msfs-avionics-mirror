"use strict";(self.webpackChunkdocs_api=self.webpackChunkdocs_api||[]).push([[53952],{3905:(e,t,n)=>{n.d(t,{Zo:()=>l,kt:()=>m});var a=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var p=a.createContext({}),c=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},l=function(e){var t=c(e.components);return a.createElement(p.Provider,{value:t},e.children)},u="mdxType",d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},b=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,p=e.parentName,l=s(e,["components","mdxType","originalType","parentName"]),u=c(n),b=i,m=u["".concat(p,".").concat(b)]||u[b]||d[b]||r;return n?a.createElement(m,o(o({ref:t},l),{},{components:n})):a.createElement(m,o({ref:t},l))}));function m(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=b;var s={};for(var p in t)hasOwnProperty.call(t,p)&&(s[p]=t[p]);s.originalType=e,s[u]="string"==typeof e?e:i,o[1]=s;for(var c=2;c<r;c++)o[c]=n[c];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}b.displayName="MDXCreateElement"},62950:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>o,default:()=>d,frontMatter:()=>r,metadata:()=>s,toc:()=>c});var a=n(87462),i=(n(67294),n(3905));const r={sidebar_label:"Specialized Subscribables",sidebar_position:3},o="Specialized Subscribables",s={unversionedId:"subscriptions/specialized-subscribables",id:"subscriptions/specialized-subscribables",title:"Specialized Subscribables",description:"MappedSubject",source:"@site/docs/subscriptions/specialized-subscribables.md",sourceDirName:"subscriptions",slug:"/subscriptions/specialized-subscribables",permalink:"/msfs-avionics-mirror/docs/subscriptions/specialized-subscribables",draft:!1,tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_label:"Specialized Subscribables",sidebar_position:3},sidebar:"sidebar",previous:{title:"Subscribables",permalink:"/msfs-avionics-mirror/docs/subscriptions/subscribables"},next:{title:"Intro to the FMC Framework",permalink:"/msfs-avionics-mirror/docs/fmc/intro-to-the-fmc-framework"}},p={},c=[{value:"<code>MappedSubject</code>",id:"mappedsubject",level:2},{value:"<code>ObjectSubject</code>",id:"objectsubject",level:2},{value:"<code>ArraySubject</code>",id:"arraysubject",level:2},{value:"<code>SetSubject</code>",id:"setsubject",level:2},{value:"<code>MapSubject</code>",id:"mapsubject",level:2}],l={toc:c},u="wrapper";function d(e){let{components:t,...n}=e;return(0,i.kt)(u,(0,a.Z)({},l,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"specialized-subscribables"},"Specialized Subscribables"),(0,i.kt)("h2",{id:"mappedsubject"},(0,i.kt)("a",{parentName:"h2",href:"https://microsoft.github.io/msfs-avionics-mirror/docs/framework/classes/MappedSubject"},(0,i.kt)("inlineCode",{parentName:"a"},"MappedSubject"))),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"/msfs-avionics-mirror/docs/subscriptions/subscribables#mapping-a-subscribable-to-new-subscribables"},"This section")," on subscribables discusses how a subscribable can be mapped to a new subscribable via the ",(0,i.kt)("inlineCode",{parentName:"p"},"map()")," method. While ",(0,i.kt)("inlineCode",{parentName:"p"},"map()")," works for mapping a single input to an output, it can't handle mapping ",(0,i.kt)("em",{parentName:"p"},"multiple")," inputs to an output. For the multiple-input case, we can use ",(0,i.kt)("inlineCode",{parentName:"p"},"MappedSubject")," instead."),(0,i.kt)("p",null,"Let's see how we can use ",(0,i.kt)("inlineCode",{parentName:"p"},"MappedSubject")," to map a subscribable that provides the current headwind component from multiple inputs:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"import { MappedSubject, MathUtils } from '@microsoft/msfs-sdk';\n\nconst planeHeading: Subscribable<number> = ...;\nconst windDirection: Subscribable<number> = ...;\nconst windSpeed: Subscribable<number> = ...;\n\nconst headwind = MappedSubject.create(\n  ([planeHeading, windDirection, windSpeed]) => {\n    const relativeWindAngle = MathUtils.diffAngleDeg(planeHeading, windDirection);\n    return windSpeed * Math.cos(relativeWindAngle * Math.PI / 180);\n  },\n  this.planeHeading,\n  this.windDirection,\n  this.windSpeed\n);\n")),(0,i.kt)("p",null,"In the above example, ",(0,i.kt)("inlineCode",{parentName:"p"},"MappedSubject.create()")," takes a mapping function and an ordered sequence of input subscribables and returns a new ",(0,i.kt)("inlineCode",{parentName:"p"},"MappedSubject")," (which implements ",(0,i.kt)("inlineCode",{parentName:"p"},"MappedSubscribable"),") whose value is the result of applying the mapping function to the values of the input subscribables. The values of the input subscribables are provided to the mapping function as a parameter in the form of an ordered ",(0,i.kt)("inlineCode",{parentName:"p"},"readonly")," tuple. In the above example the input parameter has a type of ",(0,i.kt)("inlineCode",{parentName:"p"},"readonly [number, number, number]")," and is destructured into the ",(0,i.kt)("inlineCode",{parentName:"p"},"planeHeading"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"windDirection"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"windSpeed")," components."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"MappedSubject")," supports any number of inputs (including zero!). You don't even need to know the exact number of inputs at compile time by taking advantage of the spread operator:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"const inputArray: Subscribable<number>[] = ...;\n\n// Maps n inputs, where n is in the range [0, \u221e), to their sum.\nconst sum = MappedSubject.create(\n  inputs => inputs.reduce((sum, value) => sum + value, 0),\n  ...inputArray\n);\n")),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"The mapping function used to create a ",(0,i.kt)("inlineCode",{parentName:"p"},"MappedSubject")," is executed whenever ",(0,i.kt)("em",{parentName:"p"},"any")," of the inputs change. For mappings with many inputs that frequently change, the performance cost of running the mapping function should be taken into account when designing it.")),(0,i.kt)("p",null,"You can choose to omit the mapping function from ",(0,i.kt)("inlineCode",{parentName:"p"},"MappedSubject.create()"),", in which case the inputs will be mapped to an ordered ",(0,i.kt)("inlineCode",{parentName:"p"},"readonly")," n-tuple (the same tuple that would be passed into the mapping function). This can be useful if a handler needs to be called whenever any one of multiple values changes:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"const a: Subscribable<number> = ...;\nconst b: Subscribable<boolean> = ...;\nconst c: Subscribable<string> = ...;\n\n// Instead of...\n\nconst handler = (): void => {\n  const aVal = a.get();\n  const bVal = b.get();\n  const cVal = c.get();\n\n  // Do something...\n}\n\na.sub(handler);\nb.sub(handler);\nc.sub(handler);\n\n// ... We can do...\n\nMappedSubject.create(a, b, c).sub(([aVal, bVal, cVal]) => {\n  // Do something...\n});\n")),(0,i.kt)("p",null,"When ",(0,i.kt)("inlineCode",{parentName:"p"},"MappedSubject")," is used to map inputs to an n-tuple, the mapped n-tuple is considered to have changed (and therefore will trigger notifications to subscribers) whenever any of the inputs change. For ",(0,i.kt)("inlineCode",{parentName:"p"},"MappedSubject"),"s created with a mapping function, the standard strict equality (",(0,i.kt)("inlineCode",{parentName:"p"},"==="),") logic is used to compare values unless a custom equality function is defined:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"const inputArray: Subscribable<number>[] = ...;\n\nconst sum = MappedSubject.create(\n  inputs => inputs.reduce((sum, value) => sum + value, 0),\n  // Custom equality function that ensures NaN is considered equal to itself.\n  (a, b) => {\n    if (isNaN(a) && isNaN(b)) {\n      return true;\n    } else {\n      return a === b;\n    }\n  },\n  ...inputArray\n);\n")),(0,i.kt)("admonition",{type:"note"},(0,i.kt)("p",{parentName:"admonition"},"The equality function used to create a ",(0,i.kt)("inlineCode",{parentName:"p"},"MappedSubject")," compares ",(0,i.kt)("em",{parentName:"p"},"mapped")," values, ",(0,i.kt)("strong",{parentName:"p"},"not")," input values.")),(0,i.kt)("p",null,"Finally, because ",(0,i.kt)("inlineCode",{parentName:"p"},"MappedSubject")," implements ",(0,i.kt)("inlineCode",{parentName:"p"},"MappedSubscribable")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Subscription"),", it supports the standard pause, resume, and destroy operations. These operations function in the same manner as described for mapped subscribables ",(0,i.kt)("a",{parentName:"p",href:"subscribables#mapping-a-subscribable-to-new-subscribables"},"returned by ",(0,i.kt)("inlineCode",{parentName:"a"},"map()")),"."),(0,i.kt)("h2",{id:"objectsubject"},(0,i.kt)("a",{parentName:"h2",href:"https://microsoft.github.io/msfs-avionics-mirror/docs/framework/classes/ObjectSubject"},(0,i.kt)("inlineCode",{parentName:"a"},"ObjectSubject"))),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"ObjectSubject")," is a subscribable with an object value whose enumerable properties represent a set of key-value pairs. Once defined, properties (keys) can't be added or removed from the object. The object value is considered to change when the value of any of its properties changes. Property values are compared using the strict equality operator (",(0,i.kt)("inlineCode",{parentName:"p"},"==="),")."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"ObjectSubject")," allows in-place mutation of its object value on a per-property basis or using a syntax similar to ",(0,i.kt)("inlineCode",{parentName:"p"},"Object.assign()"),". Handlers subscribed to an ",(0,i.kt)("inlineCode",{parentName:"p"},"ObjectSubject")," via ",(0,i.kt)("inlineCode",{parentName:"p"},"sub()")," are notified of changes to each individual property:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"import { ObjectSubject } from '@microsoft/msfs-sdk';\n\nconst subject = ObjectSubject.create({\n  'prop1': 0,\n  'prop2': false,\n  'prop3': ''\n});\n\nsubject.sub((obj, prop, value) => {\n  console.log(`Property ${prop} changed to ${value}`);\n});\n\n// 'Property prop1 changed to 5' is logged to the console.\nsubject.set('prop1', 5);\n\n// 'Property prop2 changed to false' is logged to the console.\nsubject.set('prop2', true);\n\n// 'Property prop1 changed to 10', then 'Property prop3 changed to qwerty'\n// are logged to the console.\nsubject.set({ 'prop1': 10, 'prop3': 'qwerty' });\n")),(0,i.kt)("admonition",{type:"caution"},(0,i.kt)("p",{parentName:"admonition"},"Mutating the object value of an ",(0,i.kt)("inlineCode",{parentName:"p"},"ObjectSubject")," through means other than ",(0,i.kt)("inlineCode",{parentName:"p"},"ObjectSubject"),"'s ",(0,i.kt)("inlineCode",{parentName:"p"},"set()")," method will not trigger notifications to subscribers:"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"const obj = { 'prop1': 0 }\nconst subject = ObjectSubject.create(obj);\n\n// None of the following will trigger notifications:\nobj.prop1 = 1;\nobj['prop1'] = 5;\nObject.assign(obj, { 'prop1': 10 });\n")),(0,i.kt)("p",{parentName:"admonition"},"To help prevent errors like the above, ",(0,i.kt)("inlineCode",{parentName:"p"},"ObjectSubject")," only provides a readonly version of its object value through the ",(0,i.kt)("inlineCode",{parentName:"p"},"get()")," method and to subscribers.")),(0,i.kt)("h2",{id:"arraysubject"},(0,i.kt)("a",{parentName:"h2",href:"https://microsoft.github.io/msfs-avionics-mirror/docs/framework/classes/ArraySubject"},(0,i.kt)("inlineCode",{parentName:"a"},"ArraySubject"))),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"ArraySubject")," is a subscribable whose value is an array. Importantly, ",(0,i.kt)("inlineCode",{parentName:"p"},"ArraySubject")," does not implement the ",(0,i.kt)("inlineCode",{parentName:"p"},"Subscribable")," interface. Instead, it implements the ",(0,i.kt)("a",{parentName:"p",href:"https://microsoft.github.io/msfs-avionics-mirror/docs/framework/interfaces/SubscribableArray"},(0,i.kt)("inlineCode",{parentName:"a"},"SubscribableArray"))," interface."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"ArraySubject")," allows in-place mutation of its array value in various ways, including insertion and deletion of indexes and changing the value stored at an index. Handlers subscribed to an ",(0,i.kt)("inlineCode",{parentName:"p"},"ArraySubject")," via ",(0,i.kt)("inlineCode",{parentName:"p"},"sub()")," are notified of changes in the array and provided information on which indexes changed:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"import { ArraySubject, SubscribableArrayEventType } from '@microsoft/msfs-sdk';\n\n// The subject's value is initialized to an empty array.\nconst subject = ArraySubject.create<number>();\n\nsubject.sub((index: number, type: SubscribableArrayEventType, items: number | number[], array: readonly number[]) => {\n  if (type === SubscribableArrayEventType.Cleared) {\n    console.log('Array was cleared');\n  } else {\n    console.log(`${type === SubscribableArrayEventType.Added ? 'Added' : 'Removed'} at index ${index}: ${items}`);\n  }\n});\n\nsubject.insert(1); // 'Added at index 0: 1' is logged to the console.\nsubject.insertRange(1, [2, 3, 4]); // 'Added at index 1: [2, 3, 4]' is logged to the console.\nconsole.log(subject.getArray()); // '[1, 2, 3, 4]' is logged to the console.\n\nsubject.removeAt(2); // 'Removed at index 2: 3' is logged to the console.\nconsole.log(subject.getArray()); // '[1, 2, 4]' is logged to the console.\n\n// 'Array was cleared', then 'Added at index 0: [4, 3, 2, 1]' are logged to the console.\nsubject.set([4, 3, 2, 1]);\n")),(0,i.kt)("admonition",{type:"caution"},(0,i.kt)("p",{parentName:"admonition"},"Mutating the array value of an ",(0,i.kt)("inlineCode",{parentName:"p"},"ArraySubject")," through means other than ",(0,i.kt)("inlineCode",{parentName:"p"},"ArraySubject"),"'s built-in methods will not trigger notifications to subscribers:"),(0,i.kt)("pre",{parentName:"admonition"},(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"const arr: number[] = [];\nconst subject = ArraySubject.create(arr);\n\n// None of the following will trigger notifications:\narr.push(0);\narr.splice(0, 1);\narr[0] = 5;\n")),(0,i.kt)("p",{parentName:"admonition"},"To help prevent errors like the above, ",(0,i.kt)("inlineCode",{parentName:"p"},"ArraySubject")," only provides a readonly version of its array value through the ",(0,i.kt)("inlineCode",{parentName:"p"},"getArray()")," method and to subscribers.")),(0,i.kt)("h2",{id:"setsubject"},(0,i.kt)("a",{parentName:"h2",href:"https://microsoft.github.io/msfs-avionics-mirror/docs/framework/classes/SetSubject"},(0,i.kt)("inlineCode",{parentName:"a"},"SetSubject"))),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"SetSubject")," is a subscribable whose value is a Javascript ",(0,i.kt)("inlineCode",{parentName:"p"},"Set")," object. A set is a collection of keys in which each key appears at most once. Keys can be freely added to and removed from a ",(0,i.kt)("inlineCode",{parentName:"p"},"SetSubject")," using syntax that mirrors the one used by ",(0,i.kt)("inlineCode",{parentName:"p"},"Set"),". Subscribers are notified of each key that is added or removed."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"import { SetSubject, SubscribableSetEventType } from '@microsoft/msfs-sdk';\n\n// Creates a new SetSubject whose initial keys include the numbers 1, 2, 3.\nconst subject = SetSubject.create<number>([1, 2, 3]);\n\nsubject.sub((set: ReadonlySet<number>, type: SubscribableSetEventType, key: number) => {\n  console.log(`Key ${key} was ${type === SubscribableSetEventType.Added ? 'added' : 'removed'}`);\n});\n\n// 'Key 4 was added' is logged to the console.\nsubject.add(4);\n\n// 'Key 1 was removed' is logged to the console.\nsubject.delete(1);\n\n// Nothing is logged to the console (the set remains unchanged).\nsubject.add(4);\n\n// 'Key 0 was added' is logged to the console.\nsubject.toggle(0);\n\n// 'Key 0 was removed' is logged to the console.\nsubject.toggle(0);\n\n// '[2, 3, 4]' is logged to the console.\nconsole.log([...subject.get()]);\n\n// 'Key 4 was removed', then 'Key 1 was added' are logged to the console.\nsubject.set([1, 2, 3]);\n")),(0,i.kt)("admonition",{type:"caution"},(0,i.kt)("p",{parentName:"admonition"},"Mutating the set value of a ",(0,i.kt)("inlineCode",{parentName:"p"},"SetSubject")," through means other than ",(0,i.kt)("inlineCode",{parentName:"p"},"SetSubject"),"'s built-in methods will not trigger notifications to subscribers. ",(0,i.kt)("inlineCode",{parentName:"p"},"SetSubject")," only provides a readonly version of its set value (",(0,i.kt)("inlineCode",{parentName:"p"},"ReadonlySet"),") through the ",(0,i.kt)("inlineCode",{parentName:"p"},"get()")," method and to subscribers in order to prevent code from changing the set in inappropriate ways. As long as the value is not explicitly cast to the mutable version (",(0,i.kt)("inlineCode",{parentName:"p"},"Set"),"), Typescript should protect you from unintentionally changing it outside of ",(0,i.kt)("inlineCode",{parentName:"p"},"SetSubject"),"."),(0,i.kt)("p",{parentName:"admonition"},"Additionally, if you pass an existing ",(0,i.kt)("inlineCode",{parentName:"p"},"Set")," into ",(0,i.kt)("inlineCode",{parentName:"p"},"SetSubject.create()"),", the passed-in set is ",(0,i.kt)("strong",{parentName:"p"},"copied")," into a newly created set. Therefore, any further changes to the passed-in set will not be reflected in the new ",(0,i.kt)("inlineCode",{parentName:"p"},"SetSubject"),"'s value.")),(0,i.kt)("p",null,"In addition to the standard ",(0,i.kt)("inlineCode",{parentName:"p"},"Subscribable")," ",(0,i.kt)("inlineCode",{parentName:"p"},"pipe()"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"SetSubject")," supports piping individual keys into objects implementing the ",(0,i.kt)("a",{parentName:"p",href:"https://microsoft.github.io/msfs-avionics-mirror/docs/framework/interfaces/MutableSubscribableSet"},(0,i.kt)("inlineCode",{parentName:"a"},"MutableSubscribableSet"))," interface (this includes ",(0,i.kt)("inlineCode",{parentName:"p"},"SetSubject")," itself). What distinguishes this set-specific pipe from the more general version is the ability to transform keys through the pipe. For example, we can use this feature to maintain a set containing keys that are the string representations of the values of another set:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},'const numbers = SetSubject.create<number>([1, 2, 3]);\nconst strings = SetSubject.create<string>();\n\nnumbers.pipe(strings, key => key.toString());\nconsole.log([...strings.get()]); // \'["1", "2", "3"]\'\n\nnumbers.delete(2);\nconsole.log([...strings.get()]); // \'["1", "3"]\'\n\nnumbers.add(0);\nconsole.log([...strings.get()]); // \'["1", "3", "0"]\'\n')),(0,i.kt)("p",null,'When establishing set pipes that do not use an injective ("one-to-one") transform function, removing a key from the source set removes the transformed key in the target set if and only if there does not exist another key in the source set that maps to the same transformed key:'),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"const numbers = SetSubject.create<number>([1.1, 1.2, 3.5, 5]);\nconst rounded = SetSubject.create<number>();\n\nnumbers.pipe(rounded, Math.round);\nconsole.log([...rounded.get()]); // '[1, 4, 5]'\n\nnumbers.delete(3.5);\nconsole.log([...rounded.get()]); // '[1, 5]'\n\nnumbers.delete(1.1);\nconsole.log([...rounded.get()]); // '[1, 5]'\n\nnumbers.delete(1.2);\nconsole.log([...rounded.get()]); // '[5]'\n")),(0,i.kt)("h2",{id:"mapsubject"},(0,i.kt)("a",{parentName:"h2",href:"https://microsoft.github.io/msfs-avionics-mirror/docs/framework/classes/MapSubject"},(0,i.kt)("inlineCode",{parentName:"a"},"MapSubject"))),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"MapSubject")," is a subscribable whose value is a Javascript ",(0,i.kt)("inlineCode",{parentName:"p"},"Map")," object. A map is a collection of key-value pairs in which each key appears at most once. Key-value pairs can be freely manipulated (adding/removing keys, changing the value of a key) in ",(0,i.kt)("inlineCode",{parentName:"p"},"MapSubject")," using syntax that mirrors the one used by ",(0,i.kt)("inlineCode",{parentName:"p"},"Map"),". Subscribers are notified of each key-value pair that is changed."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"import { MapSubject, SubscribableMapEventType } from '@microsoft/msfs-sdk';\n\n// Creates a new MapSubject whose initial key-value pairs are: 'a': 1, 'b': 2, and 'c': 3.\nconst subject = MapSubject.create<string, number>([['a', 1], ['b', 2], ['c', 3]]);\n\nsubject.sub((map: ReadonlyMap<string, number>, type: SubscribableMapEventType, key: string, value: number) => {\n  switch (type) {\n    case SubscribableMapEventType.Added:\n      console.log(`Key ${key} was added with value ${value}`);\n    case SubscribableMapEventType.Changed:\n      console.log(`Key ${key} was changed with value ${value}`);\n    case SubscribableMapEventType.Deleted:\n      console.log(`Key ${key} was removed with value ${value}`);\n  }\n});\n\n// 'Key d was added with value 4' is logged to the console.\nsubject.setValue('d', 4);\n\n// 'Key a was removed with value 1' is logged to the console.\nsubject.delete('a');\n\n// 'Key b was changed with value 5' is logged to the console.\nsubject.setValue('b', 5);\n\n// '[[\"b\", 5], [\"c\", 3], [\"d\", 4]]' is logged to the console.\nconsole.log([...subject.get()]);\n\n// 'Key b was removed with value 5', then 'Key c was changed with value 0', then 'Key e was added with value 5'\n// are logged to the console.\nsubject.set([['c', 0], ['e', 5]]);\n")),(0,i.kt)("admonition",{type:"caution"},(0,i.kt)("p",{parentName:"admonition"},"Mutating the map value of a ",(0,i.kt)("inlineCode",{parentName:"p"},"MapSubject")," through means other than ",(0,i.kt)("inlineCode",{parentName:"p"},"MapSubject"),"'s built-in methods will not trigger notifications to subscribers. ",(0,i.kt)("inlineCode",{parentName:"p"},"MapSubject")," only provides a readonly version of its map value (",(0,i.kt)("inlineCode",{parentName:"p"},"ReadonlyMap"),") through the ",(0,i.kt)("inlineCode",{parentName:"p"},"get()")," method and to subscribers in order to prevent code from changing the map in inappropriate ways. As long as the value is not explicitly cast to the mutable version (",(0,i.kt)("inlineCode",{parentName:"p"},"Map"),"), Typescript should protect you from unintentionally changing it outside of ",(0,i.kt)("inlineCode",{parentName:"p"},"MapSubject"),"."),(0,i.kt)("p",{parentName:"admonition"},"Additionally, if you pass an existing ",(0,i.kt)("inlineCode",{parentName:"p"},"Map")," into ",(0,i.kt)("inlineCode",{parentName:"p"},"MapSubject.create()"),", the passed-in map is ",(0,i.kt)("strong",{parentName:"p"},"copied")," into a newly created map. Therefore, any further changes to the passed-in map will not be reflected in the new ",(0,i.kt)("inlineCode",{parentName:"p"},"MapSubject"),"'s value.")))}d.isMDXComponent=!0}}]);