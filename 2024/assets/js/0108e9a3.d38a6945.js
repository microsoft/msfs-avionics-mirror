"use strict";(self.webpackChunkdocs_api=self.webpackChunkdocs_api||[]).push([["491185"],{175009:function(e,n,i){i.r(n),i.d(n,{metadata:()=>t,contentTitle:()=>l,default:()=>u,assets:()=>a,toc:()=>d,frontMatter:()=>o});var t=JSON.parse('{"id":"plugins/creating-plugins","title":"Creating Plugins","description":"The Plugin API is included as part of the MSFS SDK library (@microsoft/msfs-sdk). In order to use the API, the first step is to make sure your plugin imports @microsoft/msfs-sdk. Once the library is imported, you can start using the Plugin API classes.","source":"@site/docs/plugins/creating-plugins.md","sourceDirName":"plugins","slug":"/plugins/creating-plugins","permalink":"/msfs-avionics-mirror/2024/docs/plugins/creating-plugins","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"sidebar","previous":{"title":"Adding Plugin Support","permalink":"/msfs-avionics-mirror/2024/docs/plugins/adding-plugin-support"},"next":{"title":"Intro to Subscriptions","permalink":"/msfs-avionics-mirror/2024/docs/framework-systems/subscriptions/intro-to-subscriptions"}}'),s=i("785893"),r=i("250065");let o={sidebar_position:3},l="Creating Plugins",a={},d=[{value:"Setting Up Your Plugin Class",id:"setting-up-your-plugin-class",level:2},{value:"Loading Your Plugin",id:"loading-your-plugin",level:2},{value:"Loading Global Plugins",id:"loading-global-plugins",level:3},{value:"Loading Airplane Plugins",id:"loading-airplane-plugins",level:3},{value:"Getting Data from the Instrument",id:"getting-data-from-the-instrument",level:2},{value:"Overriding Rendered Components",id:"overriding-rendered-components",level:2},{value:"Component Hooks",id:"component-hooks",level:2}];function c(e){let n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,r.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"creating-plugins",children:"Creating Plugins"})}),"\n",(0,s.jsxs)(n.p,{children:["The Plugin API is included as part of the MSFS SDK library (",(0,s.jsx)(n.code,{children:"@microsoft/msfs-sdk"}),"). In order to use the API, the first step is to make sure your plugin imports ",(0,s.jsx)(n.code,{children:"@microsoft/msfs-sdk"}),". Once the library is imported, you can start using the Plugin API classes."]}),"\n",(0,s.jsx)(n.h2,{id:"setting-up-your-plugin-class",children:"Setting Up Your Plugin Class"}),"\n",(0,s.jsxs)(n.p,{children:["Plugins are implemented as classes that extend the abstract class ",(0,s.jsx)(n.code,{children:"AvionicsPlugin"}),". Individual instruments have the option to define their own plugin interfaces, so before doing anything else, you should take a minute to look up the specific interface required by the instrument for which you are developing your plugin. Once you have done that, simply create a class that both inherits from ",(0,s.jsx)(n.code,{children:"AvionicsPlugin"})," and implements the instrument-specific plugin interface (if one exists)."]}),"\n",(0,s.jsxs)(n.p,{children:["Below is an example of a very basic plugin. To keep things simple, the example assumes that there is no instrument-specific plugin interface, so we just have to extend ",(0,s.jsx)(n.code,{children:"AvionicsPlugin"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"import { AvionicsPlugin } from '@microsoft/msfs-sdk';\r\n\r\n// Don't worry about the type parameter for now; we'll get to that later.\r\nclass MyPlugin extends AvionicsPlugin<void> {\r\n  public onInstalled(): void {\r\n    // ...\r\n  }\r\n}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"AvionicsPlugin"})," only requires one method to be implemented: ",(0,s.jsx)(n.code,{children:"onInstalled()"}),". This is a callback method that is called when the plugin is first loaded by the instrument. It is a good place to run initialization code."]}),"\n",(0,s.jsxs)(n.p,{children:["Once you have defined your plugin class, the next step is to register it with the plugin system. You can do this using the global function ",(0,s.jsx)(n.code,{children:"registerPlugin()"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"import { AvionicsPlugin, registerPlugin } from '@microsoft/msfs-sdk';\r\n\r\n// Don't worry about the type parameter for now; we'll get to that later.\r\nclass MyPlugin extends AvionicsPlugin<void> {\r\n  public onInstalled(): void {\r\n    // ...\r\n  }\r\n}\r\n\r\nregisterPlugin(MyPlugin);\n"})}),"\n",(0,s.jsx)(n.h2,{id:"loading-your-plugin",children:"Loading Your Plugin"}),"\n",(0,s.jsx)(n.p,{children:"Next, you need to build your plugin code to a Javascript (.js) file and place the file in a directory that will be loaded by the sim's virtual file system."}),"\n",(0,s.jsxs)(n.p,{children:["If you are creating an airplane-specific plugin, then a good location would be under the airplane's ",(0,s.jsx)(n.code,{children:"panel/Instruments/"})," directory. Another possible location is under the global ",(0,s.jsx)(n.code,{children:"html_ui/"})," directory; however care must be used when adding files here to avoid conflicts with files from the base sim or other third-party packages."]}),"\n",(0,s.jsxs)(n.p,{children:["After you have chosen a suitable location for your plugin file, you need to tell the sim where your plugin file is located so it can be loaded. The method to do this depends on if your plugin is a ",(0,s.jsx)(n.a,{href:"/msfs-avionics-mirror/2024/docs/plugins/overview#global-vs-airplane-plugins",children:"global plugin or an airplane plugin"}),"."]}),"\n",(0,s.jsx)(n.h3,{id:"loading-global-plugins",children:"Loading Global Plugins"}),"\n",(0,s.jsx)(n.p,{children:"Global plugins are loaded using XML files placed in the following directory:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"html_ui/Plugins\n"})}),"\n",(0,s.jsx)(n.admonition,{type:"warning",children:(0,s.jsx)(n.p,{children:"While you are free to choose any name for your global plugin XML files, please take care to choose names that are not likely to conflict with files used by other plugins. Files with the same names will overwrite one another and will cause issues if the overwriting is not intended."})}),"\n",(0,s.jsxs)(n.p,{children:["Global plugin XML files should contain the ",(0,s.jsx)(n.code,{children:"<Plugins>"})," tag at the root. The ",(0,s.jsx)(n.code,{children:"<Plugins>"})," tag should in turn contain one or more ",(0,s.jsx)(n.code,{children:"<Plugin>"})," tags. Each ",(0,s.jsx)(n.code,{children:"<Plugin>"})," tag loads one plugin .js file:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:'<Plugins>\r\n\r\n  <Plugin target="MyInstrument">\r\n    coui://html_ui/Path/To/My/Plugin/MyPlugin.js\r\n  </Plugin>\r\n\r\n  <Plugin target="MyOtherInstrument">\r\n    coui://html_ui/Path/To/My/Plugin/MyOtherPlugin.js\r\n  </Plugin>\r\n\r\n</Plugins>\n'})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"target"})," attribute of each ",(0,s.jsx)(n.code,{children:"<Plugin>"})," tag defines the ",(0,s.jsx)(n.em,{children:"target"})," of all plugins loaded from the tag's .js file. The target is used by instruments to determine whether to use a particular global plugin. This allows instruments to avoid using plugins that were not meant to be applied to them. Each instrument that supports plugins is free to filter global plugins based on whatever arbitrary criteria it chooses, so please always confirm that your plugin's declared target matches what is expected by the instrument. If you want your plugin to apply to multiple instruments that expect different target strings, create separate ",(0,s.jsx)(n.code,{children:"<Plugin>"})," tags with the appropriate target strings for the different instruments."]}),"\n",(0,s.jsx)(n.h3,{id:"loading-airplane-plugins",children:"Loading Airplane Plugins"}),"\n",(0,s.jsxs)(n.p,{children:["Airplane plugins are loaded using the airplane's ",(0,s.jsx)(n.code,{children:"panel.xml"})," file. Find (or create) the ",(0,s.jsx)(n.code,{children:"<Instrument>"})," tag associated with your plugin's parent instrument, then add a ",(0,s.jsx)(n.code,{children:"<Plugin>"})," tag as a child with the content of the tag specifying the full absolute path to the plugin file."]}),"\n",(0,s.jsxs)(n.p,{children:["For example, the following ",(0,s.jsx)(n.code,{children:"panel.xml"})," will cause the instrument with ID ",(0,s.jsx)(n.code,{children:"MyInstrument"})," to load ",(0,s.jsx)(n.code,{children:"MyPlugin.js"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-xml",children:"<PlaneHTMLConfig>\r\n  <Instrument>\r\n    <Name>MyInstrument</Name>\r\n    <Plugin>\r\n      coui://SimObjects/Airplanes/Company_MyAirplane/panel/Instruments/MyPlugin.js\r\n    </Plugin>\r\n  </Instrument>\r\n</PlaneHTMLConfig>\n"})}),"\n",(0,s.jsxs)(n.p,{children:["If you wish to load multiple plugins for a single instrument, you may either build them all to a single .js file and load that file or build each plugin to its own .js file and specify multiple files to be loaded in ",(0,s.jsx)(n.code,{children:"panel.xml"}),". When loading more than one .js file, create a separate ",(0,s.jsx)(n.code,{children:"<Plugin>"})," tag for each file to be loaded."]}),"\n",(0,s.jsx)(n.admonition,{type:"info",children:(0,s.jsxs)(n.p,{children:["If an airplane has multiple instances of an instrument that all need to load the same plugin(s), the plugin file(s) should be specified for ",(0,s.jsx)(n.em,{children:"all"})," instances of the instrument, each of which will have its own ",(0,s.jsx)(n.code,{children:"<Instrument>"})," tag in ",(0,s.jsx)(n.code,{children:"panel.xml"}),"."]})}),"\n",(0,s.jsx)(n.h2,{id:"getting-data-from-the-instrument",children:"Getting Data from the Instrument"}),"\n",(0,s.jsxs)(n.p,{children:["Instruments may choose pass data to plugins via a ",(0,s.jsx)(n.em,{children:"binder"}),", which is an object that is passed to plugins via their constructors. Instruments that use plugin binders should also declare an interface for such binders so that plugins are aware of what is contained in the binder. Once the binder interface is known, it can be used as the type parameter on ",(0,s.jsx)(n.code,{children:"AvionicsPlugin"})," to properly expose the type of the ",(0,s.jsx)(n.code,{children:"binder"})," class property:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// ------------------------------------\r\n// Declared by the instrument somewhere\r\nexport interface PluginBinder {\r\n  readonly bus: EventBus;\r\n}\r\n// ------------------------------------\r\n\r\nclass MyPlugin extends AvionicsPlugin<PluginBinder> {\r\n  public onInstalled(): void {\r\n    // 'this.binder' now has the type 'PluginBinder'\r\n    this.binder.bus\r\n      .getSubscriber<ClockEvents>()\r\n      .sub('realTime')\r\n      .handle(time => { console.log(`The time is now ${new Date(time).toTimeString()}`); });\r\n  }\r\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"overriding-rendered-components",children:"Overriding Rendered Components"}),"\n",(0,s.jsx)(n.p,{children:"Normally, instruments get to decide how plugin-specific functionality is integrated. For example, an instrument may allow plugins to render or replace certain display components through the use of specific methods declared by its plugin interface:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"export interface InstrumentPlugin extends AvionicsPlugin<void> {\r\n  /**\r\n   * Renders a component.\r\n   * @returns The rendered component, or null if this plugin does not support rendering the component.\r\n   */\r\n  renderComponent(): VNode | null;\r\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"This allows instruments a certain degree of control over what parts of themselves plugins can and cannot override. However, sometimes you may find yourself in the position of needing your plugin to override a display component in a manner that the instrument plugin interface does not explicitly support. The Plugin API allows you to accomplish this without resorting to forking the instrument code."}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"AvionicsPlugin"})," supports an optional callback method ",(0,s.jsx)(n.code,{children:"onComponentCreating()"}),". If this method is defined in a subclass, then it will be called whenever ",(0,s.jsx)(n.em,{children:"any"})," instance of ",(0,s.jsx)(n.code,{children:"DisplayComponent"})," is about to be created on the plugin's parent instrument. It is passed the constructor of the component and the props that are to be used to create the component. If ",(0,s.jsx)(n.code,{children:"onComponentCreating()"})," returns ",(0,s.jsx)(n.code,{children:"undefined"}),", then the original component will be created as usual. However, if ",(0,s.jsx)(n.code,{children:"onComponentCreating()"})," returns its own instance of ",(0,s.jsx)(n.code,{children:"DisplayComponent"}),", the returned instance will be used ",(0,s.jsx)(n.em,{children:"in place"})," of the original component. Effectively, you can use ",(0,s.jsx)(n.code,{children:"onComponentCreating()"})," to intercept the creation of certain components and silently replace them with your own versions."]}),"\n",(0,s.jsxs)(n.p,{children:["For example, the following code will cause all instances of ",(0,s.jsx)(n.code,{children:"MyComponent"})," to be replaced with ",(0,s.jsx)(n.code,{children:"MyPluginComponent"}),". Everywhere ",(0,s.jsx)(n.code,{children:"MyComponent"})," would have been rendered, there will instead be a ",(0,s.jsx)(n.code,{children:"<div>"}),' with the text "Hello, world!".']}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"class MyPluginComponent extends DisplayComponent<ComponentProps> {\r\n  public render(): VNode {\r\n    return (\r\n      <div>Hello, world!</div>\r\n    );\r\n  }\r\n}\r\n\r\nclass MyPlugin extends AvionicsPlugin<void> {\r\n  public onInstalled(): void {\r\n    // ...\r\n  }\r\n\r\n  public onComponentCreating = (ctor: DisplayComponentFactory<any>, props: any): DisplayComponent<any> | undefined => {\r\n    if (ctor.name === 'MyComponent') {\r\n      return new MyPluginComponent(props);\r\n    }\r\n\r\n    return undefined;\r\n  };\r\n}\n"})}),"\n",(0,s.jsx)(n.admonition,{type:"danger",children:(0,s.jsxs)(n.p,{children:["When replacing components with ",(0,s.jsx)(n.code,{children:"onComponentCreating()"}),", it is imperative that the replacement component implement the same interface as the original. Otherwise, you may cause runtime errors to be thrown when instrument code attempts to access properties on the replacement that do not exist."]})}),"\n",(0,s.jsx)(n.h2,{id:"component-hooks",children:"Component Hooks"}),"\n",(0,s.jsxs)(n.p,{children:["If your plugin needs to know when certain components are created or rendered in the instrument, you can subscribe to those events by defining the optional ",(0,s.jsx)(n.code,{children:"onComponentCreated()"})," and ",(0,s.jsx)(n.code,{children:"onComponentRendered()"})," methods in your plugin class. The former is called immediately after ",(0,s.jsx)(n.em,{children:"any"})," component is created in the instrument, and the latter is called immediately after ",(0,s.jsx)(n.em,{children:"any"})," component is rendered."]})]})}function u(e={}){let{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},250065:function(e,n,i){i.d(n,{Z:function(){return l},a:function(){return o}});var t=i(667294);let s={},r=t.createContext(s);function o(e){let n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);