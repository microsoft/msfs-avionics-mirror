"use strict";(self.webpackChunkdocs_api=self.webpackChunkdocs_api||[]).push([["793439"],{737851:function(e,n,i){i.r(n),i.d(n,{metadata:()=>t,contentTitle:()=>o,default:()=>h,assets:()=>d,toc:()=>c,frontMatter:()=>r});var t=JSON.parse('{"id":"framework-systems/fmc/displaying-and-managing-data-in-components","title":"Displaying and Managing Data in Components","description":"Formatting data for render","source":"@site/docs/framework-systems/fmc/displaying-and-managing-data-in-components.md","sourceDirName":"framework-systems/fmc","slug":"/framework-systems/fmc/displaying-and-managing-data-in-components","permalink":"/msfs-avionics-mirror/2024/docs/framework-systems/fmc/displaying-and-managing-data-in-components","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_label":"Displaying and Managing Data in Components","sidebar_position":5},"sidebar":"sidebar","previous":{"title":"Creating Your First Page","permalink":"/msfs-avionics-mirror/2024/docs/framework-systems/fmc/creating-your-first-page"},"next":{"title":"Interaction with Components","permalink":"/msfs-avionics-mirror/2024/docs/framework-systems/fmc/interaction-with-components"}}'),a=i("785893"),s=i("250065");let r={sidebar_label:"Displaying and Managing Data in Components",sidebar_position:5},o="Displaying and Managing Data in Components",d={},c=[{value:"Formatting data for render",id:"formatting-data-for-render",level:2},{value:"Accepting input data",id:"accepting-input-data",level:2},{value:"Data Binding",id:"data-binding",level:2},{value:"One-way binding",id:"one-way-binding",level:3},{value:"Two-way binding",id:"two-way-binding",level:3}];function l(e){let n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",strong:"strong",...(0,s.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"displaying-and-managing-data-in-components",children:"Displaying and Managing Data in Components"})}),"\n",(0,a.jsx)(n.h2,{id:"formatting-data-for-render",children:"Formatting data for render"}),"\n",(0,a.jsxs)(n.p,{children:["Any component extending ",(0,a.jsx)(n.a,{href:"/msfs-avionics-mirror/2024/docs/api/framework/classes/DisplayField",children:(0,a.jsx)(n.code,{children:"DisplayField"})}),' keeps\r\ntrack of a "current value". This value is stored internally in the component, but is not manually accessible. Values can be edited in\r\ntwo ways - the ',(0,a.jsx)(n.code,{children:"takeValue"})," method of ",(0,a.jsx)(n.code,{children:"DisplayField"}),", or via ",(0,a.jsx)(n.a,{href:"#data-binding",children:"data binding"}),". Because fields are initialized without an existing\r\nvalue, ",(0,a.jsx)(n.code,{children:"null"})," is always a valid type to pass into ",(0,a.jsx)(n.code,{children:"takeValue"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["Whenever the field receives a new value, it must render it for output to the screen. There is no default rendering behaviour, and therefore, a formatter must be specified in the ",(0,a.jsx)(n.code,{children:"options"})," object of a ",(0,a.jsx)(n.code,{children:"DisplayField<T>"}),"\r\n(see ",(0,a.jsx)(n.a,{href:"/msfs-avionics-mirror/2024/docs/api/framework/interfaces/DisplayFieldOptions",children:(0,a.jsx)(n.code,{children:"DisplayFieldOptions"})}),"):"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"const FieldA = new DisplayField<T>(this, {\r\n  formatter: {\r\n    // This is automatically picked if the value is `null` - it is optional, and defaults to an empty string.\r\n    nullValueString: 'NULL',\r\n\r\n    // This function is called when the value is **not** `null` - it is not optional, and can return either\r\n    // a string or an FmcRenderTemplate. This function takes `T`, because `nullValueString` handles\r\n    // the `null` case.\r\n    format(value: T): FmcFormatterOutput {\r\n      return value.someOperation();\r\n    },\r\n  },\r\n})\r\n\r\nconst FieldB = new DisplayField<T>(this, {\r\n  formatter: (value: T | null) => 'HELLO', // alternatively, a function taking `T | null` can be specified instead of an object\r\n})\r\n\r\nconst FieldC = new DisplayField<T>(this, {\r\n  formatter: RawFormatter, // a very basic formatter which calls `toString()` is available\r\n                           // for `string | number` types\r\n})\n"})}),"\n",(0,a.jsx)(n.h2,{id:"accepting-input-data",children:"Accepting input data"}),"\n",(0,a.jsxs)(n.p,{children:["Any component extending ",(0,a.jsx)(n.a,{href:"/msfs-avionics-mirror/2024/docs/api/framework/classes/EditableField",children:(0,a.jsx)(n.code,{children:"EditableField"})})," can\r\noutput a value. The type of this value is by default the same as the input type, but this can be changed by specifying two type parameters."]}),"\n",(0,a.jsxs)(n.p,{children:["This relies on another interface, ",(0,a.jsx)(n.a,{href:"/msfs-avionics-mirror/2024/docs/api/framework/interfaces/Validator",children:(0,a.jsx)(n.code,{children:"Validator<T>"})}),"\r\n(where ",(0,a.jsx)(n.code,{children:"T"})," is the component's output type), with a single method, ",(0,a.jsx)(n.code,{children:"parse(input: string): T | null"}),". This parsing method will convert any\r\nuser input into the value specified by type ",(0,a.jsx)(n.code,{children:"T"}),", or ",(0,a.jsx)(n.code,{children:"null"})," if the input is invalid. User input can be provided in two ways - the ",(0,a.jsx)(n.code,{children:"takeTextInput"})," method\r\nof ",(0,a.jsx)(n.a,{href:"/msfs-avionics-mirror/2024/docs/api/framework/classes/TextInputField",children:(0,a.jsx)(n.code,{children:"TextInputField"})}),", or via a ",(0,a.jsx)(n.a,{href:"#",children:"scratchpad"}),"."]}),"\n",(0,a.jsx)(n.p,{children:"These components expect this interface to be implemented on the same object that is passed as the formatter - this also means they cannot\r\naccept a single function instead of the formatter object."}),"\n",(0,a.jsx)(n.admonition,{type:"tip",children:(0,a.jsxs)(n.p,{children:["It is good practice to create avionics-specific formatters implementing\r\n",(0,a.jsx)(n.a,{href:"/msfs-avionics-mirror/2024/docs/api/framework/type-aliases/FmcFormatter",children:(0,a.jsx)(n.code,{children:"FmcFormatter<T>"})})," to share formatters between fields that\r\nhave similar data input/output formats. Likewise, you can also implement common parsers that implement ",(0,a.jsx)(n.code,{children:"Validator<T>"}),"."]})}),"\n",(0,a.jsx)(n.h2,{id:"data-binding",children:"Data Binding"}),"\n",(0,a.jsxs)(n.p,{children:["One of the major features of components is their ability to automatically render data they are bound to. This is done using\r\nthe generic subscribable facilities found in the SDK - about which more can be read in\r\nthe ",(0,a.jsx)(n.a,{href:"/msfs-avionics-mirror/2024/docs/framework-systems/subscriptions/intro-to-subscriptions",children:(0,a.jsx)(n.code,{children:"Subscriptions"})})," section."]}),"\n",(0,a.jsx)(n.admonition,{type:"info",children:(0,a.jsxs)(n.p,{children:["All data binding methods available on components exported by the SDK automatically manage the lifetime of the subscriptions\r\nthey create. This is done using the\r\n",(0,a.jsx)(n.a,{href:"/msfs-avionics-mirror/2024/docs/framework-systems/fmc/page-lifecycle#binding-subscriptions-to-the-pages-lifecycle",children:"page-bound subscription lifecycle management"})," feature."]})}),"\n",(0,a.jsxs)(n.admonition,{type:"warning",children:[(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.strong,{children:"However"}),", if you pass in a ",(0,a.jsx)(n.code,{children:"Subscribable"})," that is itself a ",(0,a.jsx)(n.code,{children:"Subscription"})," (such as a ",(0,a.jsx)(n.code,{children:"MappedSubject"}),"), it will ",(0,a.jsx)(n.em,{children:"not"})," be bound to the page's\r\nlifecycle automatically. This is because it would be undesirable, in most cases, to pause a ",(0,a.jsx)(n.code,{children:"MappedSubject"})," that may very well come from a data provider\r\nlocated outside the page class."]}),(0,a.jsx)(n.p,{children:"Therefore, it is important to take this into account to avoid potential memory leaks or unnecessary computation."})]}),"\n",(0,a.jsx)(n.h3,{id:"one-way-binding",children:"One-way binding"}),"\n",(0,a.jsxs)(n.p,{children:["This ability is introduced by the ",(0,a.jsx)(n.code,{children:"DisplayField"})," class's ",(0,a.jsx)(n.code,{children:"bind()"})," method. Any ",(0,a.jsx)(n.code,{children:"Subcribable"})," passed into it will be subscribed to in order to update the\r\nvalue the field is displaying."]}),"\n",(0,a.jsx)(n.p,{children:"Whenever said value changes, the formatter that is configured on the field is called to generate a new string to render."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"const data = Subject.create(0);\r\n\r\nconst FieldA = new DisplayField(this, {\r\n  formatter: (value) => value.toFixed(1),\r\n}).bind(data);\r\n\r\ndata.set(1);   // Field outputs `1.0`\r\ndata.set(2);   // Field outputs `2.0`\r\ndata.set(3.4); // Field outputs `3.4`\n"})}),"\n",(0,a.jsx)(n.h3,{id:"two-way-binding",children:"Two-way binding"}),"\n",(0,a.jsxs)(n.p,{children:["If a ",(0,a.jsx)(n.code,{children:"MutableSubscribable"})," is passed to the ",(0,a.jsx)(n.code,{children:"bind()"})," method of an ",(0,a.jsx)(n.code,{children:"EditableField"}),", the output of that component is automatically piped\r\ninto it. Note that this only works if the output type of a component is the same as its input type."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",children:"const data = Subject.create(0);\r\n\r\nconst FieldA = new TextInputField(this, {\r\n  formatter: {\r\n    format: (value) => value.toFixed(1),\r\n\r\n    parse(input: string): number {\r\n      const int = parseInt(input);\r\n\r\n      if (!Number.isFinite(int)) {\r\n        return null;\r\n      }\r\n\r\n      return int;\r\n    },\r\n  },\r\n}).bind(data);\r\n\r\n// *user types 1 into the field* -> `data` becomes 1, field displays `1.0`\r\n// *user types 2 into the field* -> `data` becomes 2, field displays `2.0`\n"})}),"\n",(0,a.jsx)(n.admonition,{type:"tip",children:(0,a.jsxs)(n.p,{children:["This behavior can be undesirable in certain cases - if there is a special process involved in modifying the data, add an ",(0,a.jsx)(n.code,{children:"onModified"})," callback, and\r\nreturn ",(0,a.jsx)(n.code,{children:"true"}),". This will prevent the default behavior from running."]})}),"\n",(0,a.jsxs)(n.p,{children:["Read more about the different interaction callbacks in ",(0,a.jsx)(n.a,{href:"/msfs-avionics-mirror/2024/docs/framework-systems/fmc/interaction-with-components",children:"Interaction with Components"}),"."]})]})}function h(e={}){let{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},250065:function(e,n,i){i.d(n,{Z:function(){return o},a:function(){return r}});var t=i(667294);let a={},s=t.createContext(a);function r(e){let n=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);