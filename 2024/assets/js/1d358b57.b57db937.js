"use strict";(self.webpackChunkdocs_api=self.webpackChunkdocs_api||[]).push([["833412"],{410780:function(e,n,t){t.r(n),t.d(n,{metadata:()=>r,contentTitle:()=>o,default:()=>u,assets:()=>c,toc:()=>l,frontMatter:()=>a});var r=JSON.parse('{"id":"getting-started/dealing-with-dynamic-data","title":"Dealing With Dynamic Data","description":"Where is My State?","source":"@site/docs/getting-started/dealing-with-dynamic-data.md","sourceDirName":"getting-started","slug":"/getting-started/dealing-with-dynamic-data","permalink":"/msfs-avionics-mirror/2024/docs/getting-started/dealing-with-dynamic-data","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5},"sidebar":"sidebar","previous":{"title":"Adding Component Props","permalink":"/msfs-avionics-mirror/2024/docs/getting-started/adding-component-props"},"next":{"title":"Using the Event Bus","permalink":"/msfs-avionics-mirror/2024/docs/getting-started/using-the-event-bus"}}'),i=t("785893"),s=t("250065");let a={sidebar_position:5},o="Dealing With Dynamic Data",c={},l=[{value:"Where is My State?",id:"where-is-my-state",level:2},{value:"Thinking in Subscriptions",id:"thinking-in-subscriptions",level:2},{value:"Creating Subscribable Props",id:"creating-subscribable-props",level:2}];function d(e){let n={admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",strong:"strong",...(0,s.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"dealing-with-dynamic-data",children:"Dealing With Dynamic Data"})}),"\n",(0,i.jsx)(n.h2,{id:"where-is-my-state",children:"Where is My State?"}),"\n",(0,i.jsxs)(n.p,{children:["Unlike in React, components using the FSComponent framework have no built in ",(0,i.jsx)(n.code,{children:"this.state"})," or ",(0,i.jsx)(n.code,{children:"setState()"})," method, because they do not have the concept of automatic re-rendering. Re-rendering components or portions of the tree is intentionally left to the developer; this gives the greatest ability to avoid stutter-causing garbage collection pauses triggered by DOM thrashing or the discarding of large numbers of virtual DOM nodes during the re-render and reconciliation process normally undergone by React."]}),"\n",(0,i.jsx)(n.p,{children:"However, manually re-rendering or updating DOM nodes can be a painful process, so FSComponent ships with a way to handle lots of usual cases."}),"\n",(0,i.jsx)(n.h2,{id:"thinking-in-subscriptions",children:"Thinking in Subscriptions"}),"\n",(0,i.jsxs)(n.p,{children:["FSComponent and the avionics framework are geared towards thinking of data as something that is ",(0,i.jsx)(n.em,{children:"pushed"})," to you, as opposed to something that is queried from inside components. This allows components to be notified when there are substantive changes and only take action when action needs to be taken."]}),"\n",(0,i.jsxs)(n.p,{children:["The avionics framework has a number of observable types available, all under the umbrella of the interface ",(0,i.jsx)(n.code,{children:"Subscribable"})," (for readers) and class ",(0,i.jsx)(n.code,{children:"Subject"})," (for readers and writers). These types can be subscribed to by consumers, and then will be notified when changes to the value occur."]}),"\n",(0,i.jsxs)(n.p,{children:["For example, you can create a ",(0,i.jsx)(n.code,{children:"Subject"})," on a numeric value, and then alert when the value changes:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"const numberValue = Subject.create<number>(0);\r\nnumberValue.sub(value => console.log(value));\r\n\r\nnumberValue.set(5); //Logs '5'\n"})}),"\n",(0,i.jsx)(n.p,{children:"Or, even create values that have different input and output types:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'const humanReadableNumber = ComputedSubject.create<number, string>(0, num => num === 5 ? "Five" : "Not Five");\r\nhumanReadableNumber.sub(value => console.log(value));\r\n\r\nhumanReadableValue.set(6); //Logs \'Not Five\'\n'})}),"\n",(0,i.jsx)(n.h2,{id:"creating-subscribable-props",children:"Creating Subscribable Props"}),"\n",(0,i.jsxs)(n.p,{children:["Taking our ",(0,i.jsx)(n.code,{children:"MyComponent"})," example, we can create a prop that accepts a subscribable version of the value instead of a static value by replace the simple ",(0,i.jsx)(n.code,{children:"string"})," type with ",(0,i.jsx)(n.code,{children:"Subscribable<string>"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"interface MyComponentProps extends ComponentProps {\r\n  text: Subscribable<string>;\r\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["And then in our ",(0,i.jsx)(n.code,{children:"MyInstrument"})," class:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"public connectedCallback(): void {\r\n  super.connectedCallback();\r\n\r\n  const text = Subject.create<string>('Hello MSFS!');\r\n  FSComponent.render(<MyComponent text={text} />, document.getElementById('InstrumentContent'));\r\n\r\n  text.set('Hello, subscribers!');\r\n}\n"})}),"\n",(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsxs)(n.p,{children:["Using ",(0,i.jsx)(n.code,{children:"Subscribable"})," and not the concrete ",(0,i.jsx)(n.code,{children:"Subject"})," types in your props interface definition is highly recommended. Using ",(0,i.jsx)(n.code,{children:"Subject"})," can allow the component itself to write value updates, which is often not what is desired."]})}),"\n",(0,i.jsxs)(n.p,{children:["You'll notice that we didn't change ",(0,i.jsx)(n.code,{children:"MyComponent"}),"'s ",(0,i.jsx)(n.code,{children:"render()"})," function at all: it still has ",(0,i.jsx)(n.code,{children:"this.props.text"}),' in the same place that it did before. Yet, if you rebuild/resync this, you\'ll notice that the text now reads "Hello, subscribers!". How did this happen?']}),"\n",(0,i.jsxs)(n.p,{children:["In FSComponent, subscribable values can appear within HTML elements in JSX and will be automatically re-rendered at their current DOM location, as long as they possess a ",(0,i.jsx)(n.code,{children:"toString()"})," method. Additionally, you can place subscribable values in place of HTML element attribute values, as long as the underlying value types match, and those attributes will also be automatically updated when the subscribable value notifies of a change. However, you ",(0,i.jsx)(n.strong,{children:"cannot"})," use a subscribable value as a child of a component to get automatic re-rendering:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"const subscribable = Subject.create<number>(0);\r\n\r\n//Valid\r\npublic render(): VNode {\r\n  return (\r\n    <div>{subscribable}</div>\r\n  );\r\n}\r\n\r\npublic render(): VNode {\r\n  return (\r\n    <div height={subscribable}>Some Text</div>\r\n  );\r\n}\r\n\r\n//Invalid\r\npublic render(): VNode {\r\n  return (\r\n    <SomeComponent>{subscribable}</SomeComponent>\r\n  );\r\n}\n"})})]})}function u(e={}){let{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},250065:function(e,n,t){t.d(n,{Z:function(){return o},a:function(){return a}});var r=t(667294);let i={},s=r.createContext(i);function a(e){let n=r.useContext(s);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);